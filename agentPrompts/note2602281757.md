# Swift コードのメソッド名をObjective-C メソッド名に書き直す

[rubicon-objc](https://github.com/beeware/rubicon-objc) を使って、Python でコードを書いている。

参照しているコードは、Swift で書かれている。実装をしていくにあたり、Swift でのメソッド名をObjective-C のメソッド名規則に書き換える必要がある。

Apple のドキュメントに存在するメソッド名は、検索をして書き換えることができるが、独自実装の場合は自分で考えて変換しなくてはならない。

それにあたり、以下のように整理をした。あなたは、以下の整理した内容を理解して、私からSwift で書かれたコードのメソッド名をObjective-C のメソッド名に書き直した例を提示して欲しい。

メソッド名に関して、複数候補があって問題ない。ただし、提示したSwift コードのメソッド名そのものを変更するような判断は禁止。

また、rubicon-objc の仕様で、`set〜` は内部で自動的にsetter として登録されるので、気をつけて欲しい。

## 整理した内容


Appleが公式に定めている「Cocoa Coding Guidelines（命名規則）」のすべてを洗いざらいお見せします。

Objective-Cのメソッド名において、引数をつなぐ**「接着剤（前置詞）」**には明確なパターンがあります。これらを網羅すれば、もうどんな関数の名前を考える時も迷わなくなります。

全パターンを「意味合い」ごとに分類しました。

---

### 1. 手段・材料（〜を使って）

最も頻繁に使われるパターンです。何かを構築したり、処理したりする際の「道具」や「材料」を渡す時に使います。

* **`With`**（〜を使って、〜と共に）
* **Swift:** `init(device: MTLDevice)`
* **Obj-C / Rubicon:** `initWithDevice_(self, device)`
* **例:** `buildPipelineStateWithDevice_`


* **`Using`**（〜を使用して ※主にブロックや特殊な設定を渡す時）
* **Swift:** `enumerateObjects(using: block)`
* **Obj-C / Rubicon:** `enumerateObjectsUsingBlock_(self, block)`



### 2. 場所・位置（〜の場所で、〜の中に）

配列のインデックスや、画面上の座標などを指定する時に使います。

* **`At`**（〜の場所で ※ピンポイントな位置、インデックス）
* **Swift:** `object(at: Int)`
* **Obj-C / Rubicon:** `objectAtIndex_(self, index)`
* **例:** `insertVertex_atIndex_`


* **`In`**（〜の中で ※領域、範囲）
* **Swift:** `draw(in: CGRect)`
* **Obj-C / Rubicon:** `drawInRect_(self, rect)`
* **例:** `drawInMTKView_` （←あなたが実装したメソッドもコレですね！）



### 3. 起点・終点・対象（〜から、〜へ、〜のために）

データの出入り口や、誰のために処理をするのかを明確にします。

* **`From`**（〜から ※読み込み元、起点）
* **Swift:** `distance(from: Location)`
* **Obj-C / Rubicon:** `distanceFromLocation_(self, location)`
* **例:** `readDataFromURL_`


* **`To`**（〜へ ※書き込み先、変化の終点）
* **Swift:** `write(to: URL)`
* **Obj-C / Rubicon:** `writeToURL_(self, url)`


* **`For`**（〜のための ※目的の対象）
* **Swift:** `cell(for: Row)`
* **Obj-C / Rubicon:** `cellForRowAtIndexPath_(self, indexPath)`
* **例:** `requestPermissionForDevice_`



### 4. 変化・方法（〜することによって）

「元のデータ」から「新しいデータ」を作り出す時によく使われます。

* **`By`**（〜することによって ※操作を加える）
* **Swift:** `appending(string: String)`
* **Obj-C / Rubicon:** `stringByAppendingString_(self, string)`
* **例:** `imageByApplyingFilter_`



---

### ⚠️ 超重要：「接着剤を一切使わない」パターン

ここまで接着剤を紹介してきましたが、実は**「接着剤を使ってはいけない（使わないのが正解）」**という絶対ルールもあります。

それは、**「動詞が、引数を『直接の目的語』にしている場合」**です。

* **❌ NG（接着剤を使っちゃう）**
* `addChildWithNode_(self, node)` （ノード**を使って**子を追加する…？不自然）
* `setPipelineWithState_(self, state)` （ステート**を使って**パイプラインをセットする…？くどい）


* **⭕ OK（直接くっつける）**
* `addChild_(self, node)` （子ノード**を**追加する）
* `setPipelineState_(self, state)` （パイプラインステート**を**セットする）



**【見分け方のコツ】**
英語の文法（SVO）にしたとき、

* `Add a child.` (子を追加する) 👉 直接目的語だから接着剤**なし**。
* `Render with a command encoder.` (エンコーダーを使って描画する) 👉 手段だから **`With`** が必要。

---

### （おまけ）デリゲート用の特殊な接着剤

UI部品などが「今からやるよ」「終わったよ」を報告するデリゲート（イベント通知）の関数では、時間軸を表す接着剤が使われます。これも非常に美しいルールです。

* **`Will`**（今から〜する直前）: `viewWillDisappear_`
* **`Did`**（〜した直後）: `viewDidAppear_`
* **`Should`**（〜してもいいですか？ ※許可を求める）: `shouldAutorotate(self)`

---

### あなたのコードの命名仕上げ

この「Appleの命名ルール全集」を踏まえて、先ほどのあなたの関数の完璧な姿を再確認します。

1. `init(device: MTLDevice)`
👉 デバイス**を使って**初期化するので **`initWithDevice_`**
2. `func buildBuffers(device: MTLDevice)`
👉 デバイス**を使って**バッファを作るので **`buildBuffersWithDevice_`**
3. `func render(commandEncoder: MTLRenderCommandEncoder, deltaTime: Float)`
👉 エンコーダー**を使って**、デルタタイム**を**（付与して）描画するので **`renderWithCommandEncoder_deltaTime_`**

これが Objective-C（Rubicon）における「プロが書く完璧な関数名」の全貌です。


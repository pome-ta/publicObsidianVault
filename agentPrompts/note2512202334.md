## v0.0.3.10

Phase 9

```js
// worker.js
// v0.0.3.10 Phase 9 clean implementation (completion / hover concrete minimal)

import { VfsCore } from './core/vfs-core.js';
import { LspCore } from './core/lsp-core.js';
import { postLog, setDebug } from './util/logger.js';

setDebug(true);

/**
 * ---- Internal document state ----
 * Phase 4〜7 で確立したモデルを完全維持
 */
const documents = new Map(); // uri -> { version, text }
let initialized = false;

/**
 * ---- Phase 8/9 debug observability ----
 */
let lastCompletion = null;
let lastHover = null;

const handlers = {
  // --- lifecycle ---
  'worker/ready': async () => ({ ok: true }),

  // --- VFS ---
  'vfs/ensureReady': async () => {
    await VfsCore.ensureReady();
    return { ok: true };
  },

  'vfs/getEnvInfo': async () => VfsCore.getEnvInfo(),

  'vfs/resetForTest': async () => {
    VfsCore.resetForTest();
    documents.clear();
    initialized = false;
    lastCompletion = null;
    lastHover = null;
    return { ok: true };
  },

  'vfs/openFile': async (params) => {
    if (
      !params ||
      typeof params.uri !== 'string' ||
      typeof params.content !== 'string'
    ) {
      throw Object.assign(new Error('Invalid params'), { code: -32602 });
    }

    if (!VfsCore.getEnvInfo().ready) {
      throw Object.assign(new Error('VFS is not ready'), { code: -32001 });
    }

    const prev = documents.get(params.uri);
    const version = prev ? prev.version + 1 : 1;

    documents.set(params.uri, {
      uri: params.uri,
      version,
      text: params.content,
    });

    return { ok: true };
  },

  // --- LSP ---
  'lsp/initialize': async (params) => {
    const result = await LspCore.initialize(params);
    initialized = true;
    return result;
  },

  /**
   * ---- Phase 9: completion (concrete minimal) ----
   */
  'textDocument/completion': async (params) => {
    lastCompletion = params ?? null;

    if (!initialized) {
      return { isIncomplete: false, items: [] };
    }

    const uri = params?.textDocument?.uri;
    const doc = uri ? documents.get(uri) : null;
    if (!doc) {
      return { isIncomplete: false, items: [] };
    }

    // Phase 9 最小実体：常に 1 件返す
    return {
      isIncomplete: false,
      items: [
        {
          label: 'Phase9Completion',
          kind: 6, // Variable
          detail: 'Phase 9 minimal completion',
          insertText: 'Phase9Completion',
        },
      ],
    };
  },

  /**
   * ---- Phase 9: hover (concrete minimal) ----
   */
  'textDocument/hover': async (params) => {
    lastHover = params ?? null;

    if (!initialized) {
      return null;
    }

    const uri = params?.textDocument?.uri;
    const doc = uri ? documents.get(uri) : null;
    if (!doc) {
      return null;
    }

    // Phase 9 最小実体：document 情報を返す
    return {
      contents: {
        kind: 'plaintext',
        value: `uri: ${doc.uri}\nversion: ${doc.version}`,
      },
    };
  },

  // --- debug ---
  'lsp/_debug/getLastCompletion': async () => lastCompletion,
  'lsp/_debug/getLastHover': async () => lastHover,
};

self.onmessage = async (e) => {
  const msg = e.data;
  if (!msg || msg.jsonrpc !== '2.0') return;

  const { id, method, params } = msg;
  const handler = handlers[method];

  if (!handler) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: -32601, message: `Method not found: ${method}` },
      });
    }
    return;
  }

  try {
    const result = await handler(params);
    if (id != null) {
      self.postMessage({ jsonrpc: '2.0', id, result });
    }
  } catch (err) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: {
          code: err?.code ?? -32000,
          message: err?.message ?? String(err),
        },
      });
    }
  }
};

// RPC ready
postLog('Worker loaded and ready.');
self.postMessage({ jsonrpc: '2.0', method: 'worker/ready' });
```

## v0.0.3.9

Phase 8

```js
// worker.js
// v0.0.3.9 Phase 8 clean implementation (completion / hover minimal)

import { VfsCore } from './core/vfs-core.js';
import { LspCore } from './core/lsp-core.js';
import { postLog, setDebug } from './util/logger.js';

setDebug(true);

/**
 * ---- Internal document state ----
 * Phase 4〜7 で確立したモデルを維持
 */
const documents = new Map(); // uri -> { version, text }
let initialized = false;

/**
 * ---- Phase 8 debug observability ----
 */
let lastCompletion = null;
let lastHover = null;

const handlers = {
  // --- lifecycle ---
  'worker/ready': async () => ({ ok: true }),

  // --- VFS ---
  'vfs/ensureReady': async () => {
    await VfsCore.ensureReady();
    return { ok: true };
  },

  'vfs/getEnvInfo': async () => VfsCore.getEnvInfo(),

  'vfs/resetForTest': async () => {
    VfsCore.resetForTest();
    documents.clear();
    initialized = false;
    lastCompletion = null;
    lastHover = null;
    return { ok: true };
  },

  'vfs/openFile': async (params) => {
    if (
      !params ||
      typeof params.uri !== 'string' ||
      typeof params.content !== 'string'
    ) {
      throw Object.assign(new Error('Invalid params'), { code: -32602 });
    }

    if (!VfsCore.getEnvInfo().ready) {
      throw Object.assign(new Error('VFS is not ready'), { code: -32001 });
    }

    const prev = documents.get(params.uri);
    const version = prev ? prev.version + 1 : 1;

    documents.set(params.uri, {
      uri: params.uri,
      version,
      text: params.content,
    });

    return { ok: true };
  },

  // --- LSP ---
  'lsp/initialize': async (params) => {
    const result = await LspCore.initialize(params);
    initialized = true;
    return result;
  },

  /**
   * ---- Phase 8: completion (minimal) ----
   */
  'textDocument/completion': async (params) => {
    lastCompletion = params ?? null;

    if (!initialized) {
      return { isIncomplete: false, items: [] };
    }

    const uri = params?.textDocument?.uri;
    if (!uri || !documents.has(uri)) {
      return { isIncomplete: false, items: [] };
    }

    return {
      isIncomplete: false,
      items: [],
    };
  },

  /**
   * ---- Phase 8: hover (minimal) ----
   */
  'textDocument/hover': async (params) => {
    lastHover = params ?? null;

    if (!initialized) {
      return null;
    }

    const uri = params?.textDocument?.uri;
    if (!uri || !documents.has(uri)) {
      return null;
    }

    return {
      contents: {
        kind: 'plaintext',
        value: '',
      },
    };
  },

  // --- debug ---
  'lsp/_debug/getLastCompletion': async () => lastCompletion,
  'lsp/_debug/getLastHover': async () => lastHover,
};

self.onmessage = async (e) => {
  const msg = e.data;
  if (!msg || msg.jsonrpc !== '2.0') return;

  const { id, method, params } = msg;
  const handler = handlers[method];

  if (!handler) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: -32601, message: `Method not found: ${method}` },
      });
    }
    return;
  }

  try {
    const result = await handler(params);
    if (id != null) {
      self.postMessage({ jsonrpc: '2.0', id, result });
    }
  } catch (err) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: {
          code: err?.code ?? -32000,
          message: err?.message ?? String(err),
        },
      });
    }
  }
};

// RPC ready
postLog('Worker loaded and ready.');
self.postMessage({ jsonrpc: '2.0', method: 'worker/ready' });
```

## v0.0.3.8

Phase 7

```js
// worker.js
// v0.0.3.8 Phase 7 clean
//
// 対応範囲:
// - didOpen / didChange / didClose lifecycle
// - incremental sync (range + text / full text fallback)
// - diagnostics 最小通知
// - テスト専用 debug API
//
// 非対応（意図的）:
// - completion / hover 実体
// - semantic tokens
// - diagnostics 内容生成

import { VfsCore } from './core/vfs-core.js';
import { LspCore } from './core/lsp-core.js';
import { postLog, setDebug } from './util/logger.js';

setDebug(true);

/* =========================
 * 内部 document state
 * ========================= */

const documents = new Map();
/*
documents.get(uri) = {
  uri,
  version,
  text,
  opened: boolean
}
*/

let initialized = false;

/* =========================
 * debug observation
 * ========================= */

let lastDidOpen = null;
let lastDidChange = null;
let lastDidClose = null;
let lastDiagnostics = null;

/* =========================
 * utility
 * ========================= */

function applyIncrementalChange(text, change) {
  if (!change.range) {
    return change.text;
  }

  const lines = text.split('\n');

  const { start, end } = change.range;

  const before = lines[start.line].slice(0, start.character);

  const after = lines[end.line].slice(end.character);

  lines.splice(
    start.line,
    end.line - start.line + 1,
    `${before}${change.text}${after}`
  );

  return lines.join('\n');
}

function emitDiagnostics(uri) {
  lastDiagnostics = {
    uri,
    diagnostics: [],
  };
}

/* =========================
 * handlers
 * ========================= */

const handlers = {
  // --- lifecycle ---
  'worker/ready': async () => ({ ok: true }),

  // --- vfs ---
  'vfs/ensureReady': async () => {
    await VfsCore.ensureReady();
    return { ok: true };
  },

  'vfs/getEnvInfo': async () => {
    return VfsCore.getEnvInfo();
  },

  'vfs/resetForTest': async () => {
    VfsCore.resetForTest();
    documents.clear();
    initialized = false;
    lastDidOpen = null;
    lastDidChange = null;
    lastDidClose = null;
    lastDiagnostics = null;
    return { ok: true };
  },

  'vfs/openFile': async (params) => {
    if (
      !params ||
      typeof params.uri !== 'string' ||
      typeof params.content !== 'string'
    ) {
      throw Object.assign(new Error('Invalid params'), {
        code: -32602,
      });
    }

    if (!VfsCore.getEnvInfo().ready) {
      throw Object.assign(new Error('VFS not ready'), {
        code: -32001,
      });
    }

    let doc = documents.get(params.uri);

    if (!doc) {
      doc = {
        uri: params.uri,
        version: 0,
        text: '',
        opened: false,
      };
      documents.set(params.uri, doc);
    }

    doc.text = params.content;
    doc.version += 1;
    doc.opened = true;

    return { ok: true };
  },

  // --- lsp ---
  'lsp/initialize': async (params) => {
    const result = await LspCore.initialize(params);
    initialized = true;

    for (const doc of documents.values()) {
      if (!doc.opened) continue;

      lastDidOpen = {
        uri: doc.uri,
        version: doc.version,
        text: doc.text,
      };

      emitDiagnostics(doc.uri);
    }

    return result;
  },

  'textDocument/didChange': async (params) => {
    if (!initialized) {
      return null;
    }

    const { textDocument, contentChanges } = params;
    const doc = documents.get(textDocument.uri);

    if (!doc || !doc.opened) {
      return null;
    }

    let text = doc.text;

    for (const change of contentChanges) {
      text = applyIncrementalChange(text, change);
    }

    doc.text = text;
    doc.version += 1;

    lastDidChange = {
      uri: doc.uri,
      version: doc.version,
      text: doc.text,
    };

    emitDiagnostics(doc.uri);

    return null;
  },

  'textDocument/didClose': async (params) => {
    if (!initialized) return null;

    const uri = params.textDocument.uri;
    const doc = documents.get(uri);

    if (!doc) return null;

    doc.opened = false;

    lastDidClose = { uri };

    return null;
  },

  // --- hover stub ---
  'textDocument/hover': async () => {
    return null;
  },

  // --- debug ---
  'lsp/_debug/getLastDidOpen': async () => lastDidOpen,
  'lsp/_debug/getLastDidChange': async () => lastDidChange,
  'lsp/_debug/getLastDidClose': async () => lastDidClose,
  'lsp/_debug/getLastDiagnostics': async () => lastDiagnostics,
};

/* =========================
 * message loop
 * ========================= */

self.onmessage = async (e) => {
  const msg = e.data;
  if (!msg || msg.jsonrpc !== '2.0') return;

  const { id, method, params } = msg;
  const handler = handlers[method];

  if (!handler) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: {
          code: -32601,
          message: `Method not found: ${method}`,
        },
      });
    }
    return;
  }

  try {
    const result = await handler(params);
    if (id != null) {
      self.postMessage({ jsonrpc: '2.0', id, result });
    }
  } catch (err) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: {
          code: err?.code ?? -32000,
          message: err?.message ?? String(err),
        },
      });
    }
  }
};

// ready
postLog('Worker loaded and ready.');
self.postMessage({ jsonrpc: '2.0', method: 'worker/ready' });
```

## v0.0.3.7

Phase 6

```js
// worker.js
// v0.0.3.7 (Phase 6 clean)

import { VfsCore } from './core/vfs-core.js';
import { LspCore } from './core/lsp-core.js';
import { postLog, setDebug } from './util/logger.js';

setDebug(true);

/*
 * documentStates:
 * {
 *   [uri]: {
 *     version: number,
 *     text: string,
 *     opened: boolean
 *   }
 * }
 */
const documentStates = new Map();

let initialized = false;

// --- debug observation ---
let lastDidOpen = null;
let lastDidChange = null;
let lastDidClose = null;

const handlers = {
  // --- lifecycle ---
  'worker/ready': async () => ({ ok: true }),

  // --- vfs ---
  'vfs/ensureReady': async () => {
    await VfsCore.ensureReady();
    return { ok: true };
  },

  'vfs/resetForTest': async () => {
    documentStates.clear();
    lastDidOpen = null;
    lastDidChange = null;
    lastDidClose = null;
    initialized = false;
    return { ok: true };
  },

  'vfs/openFile': async ({ uri, content }) => {
    if (typeof uri !== 'string' || typeof content !== 'string') {
      throw Object.assign(new Error('Invalid params'), { code: -32602 });
    }
    if (!VfsCore.getEnvInfo().ready) {
      throw Object.assign(new Error('VFS not ready'), { code: -32001 });
    }

    const prev = documentStates.get(uri);

    // --- initialize 前: state のみ保持 ---
    if (!initialized) {
      documentStates.set(uri, {
        version: prev ? prev.version + 1 : 1,
        text: content,
        opened: true,
      });
      return { ok: true };
    }

    // --- initialize 後 ---
    if (!prev) {
      // didOpen
      documentStates.set(uri, {
        version: 1,
        text: content,
        opened: true,
      });

      lastDidOpen = {
        uri,
        version: 1,
        text: content,
      };
    } else if (prev.opened) {
      // didChange
      const nextVersion = prev.version + 1;
      documentStates.set(uri, {
        version: nextVersion,
        text: content,
        opened: true,
      });

      lastDidChange = {
        uri,
        version: nextVersion,
        text: content,
      };
    } else {
      // reopen after close → didOpen with version=1
      documentStates.set(uri, {
        version: 1,
        text: content,
        opened: true,
      });

      lastDidOpen = {
        uri,
        version: 1,
        text: content,
      };
    }

    return { ok: true };
  },

  'vfs/closeFile': async ({ uri }) => {
    if (typeof uri !== 'string') {
      throw Object.assign(new Error('Invalid params'), { code: -32602 });
    }

    const state = documentStates.get(uri);
    if (!state || !state.opened) {
      return { ok: true };
    }

    // initialize 前は state 破棄のみ
    if (!initialized) {
      documentStates.delete(uri);
      return { ok: true };
    }

    // initialize 後: didClose
    documentStates.delete(uri);

    lastDidClose = { uri };

    return { ok: true };
  },

  // --- lsp ---
  'lsp/initialize': async (params) => {
    const result = await LspCore.initialize(params);
    initialized = true;
    return result;
  },

  // --- debug ---
  'lsp/_debug/getLastDidOpen': async () => lastDidOpen,
  'lsp/_debug/getLastDidChange': async () => lastDidChange,
  'lsp/_debug/getLastDidClose': async () => lastDidClose,
};

self.onmessage = async (e) => {
  const msg = e.data;
  if (!msg || msg.jsonrpc !== '2.0') return;

  const { id, method, params } = msg;
  const handler = handlers[method];

  if (!handler) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: -32601, message: `Method not found: ${method}` },
      });
    }
    return;
  }

  try {
    const result = await handler(params);
    if (id != null) {
      self.postMessage({ jsonrpc: '2.0', id, result });
    }
  } catch (err) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: {
          code: err?.code ?? -32000,
          message: err?.message ?? String(err),
        },
      });
    }
  }
};

// --- boot ---
postLog('Worker loaded and ready.');
self.postMessage({ jsonrpc: '2.0', method: 'worker/ready' });
```

## v0.0.3.6

Phase 5

```js
// worker.js
// v0.0.3.6
// Phase 5 clean minimal implementation

import { VfsCore } from './core/vfs-core.js';
import { LspCore } from './core/lsp-core.js';
import { postLog, setDebug } from './util/logger.js';

setDebug(true);

/* -------------------------
 * Phase 5 state
 * ------------------------- */

let isInitialized = false;

const documentState = {
  uri: null,
  version: 0,
  text: null,
};

// debug observation (no side effects)
let lastDidOpen = null;
let lastDidChange = null;

/* -------------------------
 * RPC handlers
 * ------------------------- */

const handlers = {
  // --- lifecycle ---
  'worker/ready': async () => ({ ok: true }),

  // --- vfs ---
  'vfs/ensureReady': async () => {
    await VfsCore.ensureReady();
    return { ok: true };
  },

  'vfs/getEnvInfo': async () => {
    return VfsCore.getEnvInfo();
  },

  'vfs/resetForTest': async () => {
    VfsCore.resetForTest();
    isInitialized = false;

    documentState.uri = null;
    documentState.version = 0;
    documentState.text = null;

    lastDidOpen = null;
    lastDidChange = null;

    return { ok: true };
  },

  'vfs/openFile': async (params) => {
    // params validation
    if (!params || typeof params.uri !== 'string' || params.uri.length === 0 || typeof params.content !== 'string') {
      throw Object.assign(new Error('Invalid params'), { code: -32602 });
    }

    // VFS ready check
    if (!VfsCore.getEnvInfo().ready) {
      throw Object.assign(new Error('VFS is not ready'), { code: -32001 });
    }

    const { uri, content } = params;

    // version management
    if (documentState.uri === uri) {
      documentState.version += 1;
    } else {
      documentState.uri = uri;
      documentState.version = 1;
    }

    documentState.text = content;

    // Phase 5: event-driven sync
    if (isInitialized) {
      if (documentState.version === 1) {
        lastDidOpen = {
          uri,
          version: 1,
          text: content,
        };
      } else {
        lastDidChange = {
          uri,
          version: documentState.version,
          text: content,
        };
      }
    }

    return { ok: true };
  },

  // --- lsp ---
  'lsp/initialize': async (params) => {
    const result = await LspCore.initialize(params);
    isInitialized = true;
    return result;
  },

  'textDocument/hover': async () => {
    return null;
  },

  // --- debug ---
  'lsp/_debug/getLastDidOpen': async () => {
    return lastDidOpen;
  },

  'lsp/_debug/getLastDidChange': async () => {
    return lastDidChange;
  },
};

/* -------------------------
 * JSON-RPC loop
 * ------------------------- */

self.onmessage = async (e) => {
  const msg = e.data;
  if (!msg || msg.jsonrpc !== '2.0') return;

  const { id, method, params } = msg;
  const handler = handlers[method];

  if (!handler) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: -32601, message: `Method not found: ${method}` },
      });
    }
    return;
  }

  try {
    const result = await handler(params);
    if (id != null) {
      self.postMessage({ jsonrpc: '2.0', id, result });
    }
  } catch (err) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: {
          code: err?.code ?? -32000,
          message: err?.message ?? String(err),
        },
      });
    }
  }
};

// ready notification
postLog('Worker loaded and ready.');
self.postMessage({ jsonrpc: '2.0', method: 'worker/ready' });
```

## v0.0.3.5

```js
// worker.js
// v0.0.3.5

import { VfsCore } from './core/vfs-core.js';
import { LspCore } from './core/lsp-core.js';
import { postLog, setDebug } from './util/logger.js';

// Enable debug by default for test runner visibility
setDebug(true);

// --- Phase 4: 観測用状態 ---
let lastDidOpen = null;
let lastDidChange = null;

// --- Phase 4: 単一ドキュメント状態 ---
const documentState = {
  uri: null,
  version: 0,
  text: null,
};

const handlers = {
  // --- lifecycle ---
  'worker/ready': async () => ({ ok: true }),

  // --- vfs ---
  'vfs/ensureReady': async () => {
    await VfsCore.ensureReady();
    return { ok: true };
  },

  'vfs/getEnvInfo': async () => {
    return VfsCore.getEnvInfo();
  },

  'vfs/resetForTest': async () => {
    VfsCore.resetForTest();
    documentState.uri = null;
    documentState.version = 0;
    documentState.text = null;
    lastDidOpen = null;
    lastDidChange = null;
    return { ok: true };
  },

  'vfs/openFile': async (params) => {
    // params validation
    if (
      !params ||
      typeof params.uri !== 'string' ||
      params.uri.length === 0 ||
      typeof params.content !== 'string'
    ) {
      throw Object.assign(new Error('Invalid params'), { code: -32602 });
    }

    // VFS ready check
    if (!VfsCore.getEnvInfo().ready) {
      throw Object.assign(new Error('VFS is not ready'), { code: -32001 });
    }

    if (documentState.uri === params.uri) {
      documentState.version += 1;
    } else {
      documentState.uri = params.uri;
      documentState.version = 1;
    }

    documentState.text = params.content;

    return { ok: true };
  },

  // --- lsp ---
  'lsp/initialize': async (params) => {
    const result = await LspCore.initialize(params);

    /*
      Phase 4 仕様:
      - initialize 時点で documentState を評価
      - version === 1 → didOpen
      - version > 1  → didChange
      NOTE:
      この挙動は Phase 5 で LSP 標準フローに置き換える
    */
    if (documentState.uri) {
      if (documentState.version === 1) {
        lastDidOpen = {
          uri: documentState.uri,
          version: 1,
          text: documentState.text,
        };
      } else if (documentState.version > 1) {
        lastDidChange = {
          uri: documentState.uri,
          version: documentState.version,
          text: documentState.text,
        };
      }
    }

    return result;
  },

  'textDocument/hover': async () => null,

  // --- lsp debug (Phase 4 test only) ---
  'lsp/_debug/getLastDidOpen': async () => {
    return lastDidOpen;
  },

  'lsp/_debug/getLastDidChange': async () => {
    return lastDidChange;
  },
};

self.onmessage = async (e) => {
  const msg = e.data;
  if (!msg || msg.jsonrpc !== '2.0') return;

  const { id, method, params } = msg;

  const handler = handlers[method];
  if (!handler) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: -32601, message: `Method not found: ${method}` },
      });
    }
    return;
  }

  try {
    const result = await handler(params);
    if (id != null) {
      self.postMessage({ jsonrpc: '2.0', id, result });
    }
  } catch (err) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: {
          code: err?.code ?? -32000,
          message: err?.message ?? String(err),
        },
      });
    }
  }
};

postLog('Worker loaded and ready.');
self.postMessage({ jsonrpc: '2.0', method: 'worker/ready' });

```

## v0.0.3.4

```js
// worker.js
// v0.0.3.4

import { VfsCore } from './core/vfs-core.js';
import { LspCore } from './core/lsp-core.js';
import { JsonRpcErrorCode } from './core/error-codes.js';
import { postLog, setDebug } from './util/logger.js';

// Enable debug by default for test runner visibility
setDebug(true);

let lastDidOpen = null;
let lastOpenedFile = null;
let lastDidChange = null;

let documentState = {
  uri: null,
  version: 0,
  text: null,
};

const handlers = {
  // --- lifecycle ---
  'worker/ready': async () => ({ ok: true }),

  // --- vfs ---
  'vfs/ensureReady': async () => {
    await VfsCore.ensureReady();
    return { ok: true };
  },

  'vfs/getEnvInfo': async () => {
    return VfsCore.getEnvInfo();
  },
  'vfs/resetForTest': async () => {
    VfsCore.resetForTest();
    return { ok: true };
  },

  'vfs/openFile': async (params) => {
    // 1 params validation(最優先)
    if (!params || typeof params.uri !== 'string' || params.uri.length === 0 || typeof params.content !== 'string') {
      throw Object.assign(new Error('Invalid params'), { code: -32602 });
    }
    // 2 VFS ready check
    if (!VfsCore.getEnvInfo().ready) {
      throw Object.assign(new Error('VFS is not ready'), { code: -32001 });
    }

    // Phase 4 前半: openFile 内容を保持
    lastOpenedFile = {
      uri: params.uri,
      content: params.content,
    };

    if (documentState.uri === params.uri) {
      documentState.version += 1;
    } else {
      documentState.uri = params.uri;
      documentState.version = 1;
    }

    documentState.text = params.content;

    return { ok: true };
  },

  // --- lsp ---
  'lsp/initialize': async (params) => {
    const result = await LspCore.initialize(params);

    // --- Phase 4 前半: didOpen 発行を「観測用に記録」 ---
    if (lastOpenedFile) {
      lastDidOpen = {
        uri: lastOpenedFile.uri,
        version: 1,
        text: lastOpenedFile.content,
      };
    }

    if (documentState.version === 1) {
      lastDidOpen = {
        uri: documentState.uri,
        version: 1,
        text: documentState.text,
      };
    } else if (documentState.version > 1) {
      lastDidChange = {
        uri: documentState.uri,
        version: documentState.version,
        text: documentState.text,
      };
    }

    return result;
  },
  'textDocument/hover': async () => {
    return null;
  },
  // --- lsp debug ---
  'lsp/_debug/getLastDidOpen': async () => {
    return lastDidOpen;
  },

  'lsp/_debug/getLastDidChange': async () => {
    return lastDidChange;
  },
};

self.onmessage = async (e) => {
  const msg = e.data;

  if (!msg || msg.jsonrpc !== '2.0') return;

  const { id, method, params } = msg;

  if (!handlers[method]) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: -32601, message: `Method not found: ${method}` },
      });
    }
    return;
  }

  try {
    const result = await handlers[method](params);

    if (id != null) {
      self.postMessage({ jsonrpc: '2.0', id, result });
    }
  } catch (err) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: {
          code: err?.code ?? -32000,
          message: err?.message ?? String(err),
        },
      });
    }
  }
};

// RPC 受付開始通知
postLog('Worker loaded and ready.');
self.postMessage({ jsonrpc: '2.0', method: 'worker/ready' });
```

## v0.0.3.3

```js
// worker.js
// v0.0.3.3

import { VfsCore } from './core/vfs-core.js';
import { LspCore } from './core/lsp-core.js';
import { JsonRpcErrorCode } from './core/error-codes.js';
import { postLog, setDebug } from './util/logger.js';

// Enable debug by default for test runner visibility
setDebug(true);

// handlers: "method" -> async function(params)
// - Requests (with id) return a result via JSON-RPC response
// - Notifications (no id) do not return a response
const handlers = {
  // VFS
  'vfs/ensureReady': async (params) => await VfsCore.ensureReady(),

  // テスト専用: VFS をリセットして単一インスタンス初期状態に戻す
  'vfs/resetForTest': async () => {
    return VfsCore.resetForTest();
  },
  // テスト専用: テスト専用内部情報の取得
  'vfs/_getEnvInfo': async () => {
    return VfsCore.getEnvInfo();
  },

  'vfs/openFile': async (params) => {
    const { path, content } = params;
    return VfsCore.openFile(path, content);
  },

  'vfs/createEnvironment': async (params) => {
    return VfsCore.createEnvironment(params.compilerOptions, params.rootFiles, params.initialFiles);
  },
  'vfs/_getFile': (params) => VfsCore._getFile(params.path),

  // LSP lifecycle / utility
  'lsp/ping': async () => 'pong',
  'lsp/shutdown': async () => {
    postLog('Worker shutting down...');
    setTimeout(() => self.close(), 100);
    return 'shutdown-complete';
  },
  'lsp/initialize': async (params) => await LspCore.initialize(params),

  // Document sync (VFS required)
  'textDocument/didOpen': async (params) => await LspCore.didOpen(params),
  'textDocument/didChange': async (params) => await LspCore.didChange(params),
  'textDocument/didClose': async (params) => await LspCore.didClose(params),
};

// ============================================================
// JSON-RPC Message Processing
// ============================================================

/**
 * Handle incoming JSON-RPC message object.
 * Validates JSON-RPC 2.0 structure, VFS precondition for LSP methods, and dispatches to handlers.
 *
 * @param {object} msg JSON-RPC message
 */
async function handleJsonRpcMessage(msg) {
  const { jsonrpc, id, method, params } = msg || {};

  if (jsonrpc !== '2.0' || typeof method !== 'string') {
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: {
          code: JsonRpcErrorCode.InvalidRequest,
          message: 'Invalid JSON-RPC 2.0 payload',
        },
      });
    }
    return;
  }

  postLog(`Received: ${method} (id:${id ?? '-'})`);

  // Methods that assume VFS / LSP presence:
  // - textDocument/* always requires VFS
  // - lsp/* except initialize/ping/shutdown require VFS
  const requiresVfs =
    method.startsWith('textDocument/') ||
    (method.startsWith('lsp/') && !['lsp/initialize', 'lsp/ping', 'lsp/shutdown'].includes(method));

  if (requiresVfs && !VfsCore.isReady()) {
    const message = 'VFS not ready. Call `vfs/ensureReady` first.';
    postLog(`Error: ${message}`);
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: JsonRpcErrorCode.ServerNotInitialized, message },
      });
    }
    return;
  }

  const handler = handlers[method];
  if (!handler) {
    const message = `Unknown method: ${method}`;
    postLog(`Error: ${message}`);
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: JsonRpcErrorCode.MethodNotFound, message },
      });
    }
    return;
  }

  try {
    const result = await handler(params);
    postLog(`Finished: ${method}`);
    if (id) {
      // JSON-RPC response for requests
      self.postMessage({
        jsonrpc: '2.0',
        id,
        result: result !== undefined ? result : null,
      });
    }
    // For notifications (no id) - no response sent
  } catch (err) {
    const message = `${method} failed: ${err?.message ?? String(err)}`;
    postLog(`Error: ${message}`);
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: JsonRpcErrorCode.ServerError, message },
      });
    }
  }
}

// Message event listener
self.addEventListener('message', async (event) => {
  const { data } = event;

  // Toggle debug mode via simple string messages 'debug:on' | 'debug:off'
  if (typeof data === 'string' && data.startsWith('debug:')) {
    const enabled = data === 'debug:on';
    setDebug(enabled);
    postLog(`Debug mode set ${enabled}`);
    return;
  }

  // JSON-RPC
  if (data?.jsonrpc === '2.0') {
    await handleJsonRpcMessage(data);
    return;
  }

  // Unknown non-jsonrpc message: keep for backwards compatibility
  postLog(`Received unknown message format: ${JSON.stringify(data)}`);
});

// Announce ready
postLog('Worker loaded and ready.');
self.postMessage({ jsonrpc: '2.0', method: 'worker/ready' });
```

## v0.0.3.2

```js
// worker.js
// v0.0.3.2

import { VfsCore } from './core/vfs-core.js';
import { LspCore } from './core/lsp-core.js';
import { JsonRpcErrorCode } from './core/error-codes.js';
import { postLog, setDebug } from './util/logger.js';

// Enable debug by default for test runner visibility
setDebug(true);

// handlers: "method" -> async function(params)
// - Requests (with id) return a result via JSON-RPC response
// - Notifications (no id) do not return a response
const handlers = {
  // VFS
  'vfs/ensureReady': async (params) => await VfsCore.ensureReady(),
  
  // テスト専用: VFS をリセットして単一インスタンス初期状態に戻す
  'vfs/resetForTest': async () => { return VfsCore.resetForTest(); },
  // テスト専用: テスト専用内部情報の取得
  'vfs/_getEnvInfo': async () => { return VfsCore.getEnvInfo(); },
  


  // LSP lifecycle / utility
  'lsp/ping': async () => 'pong',
  'lsp/shutdown': async () => {
    postLog('Worker shutting down...');
    setTimeout(() => self.close(), 100);
    return 'shutdown-complete';
  },
  'lsp/initialize': async (params) => await LspCore.initialize(params),

  // Document sync (VFS required)
  'textDocument/didOpen': async (params) => await LspCore.didOpen(params),
  'textDocument/didChange': async (params) => await LspCore.didChange(params),
  'textDocument/didClose': async (params) => await LspCore.didClose(params),
};

// ============================================================
// JSON-RPC Message Processing
// ============================================================

/**
 * Handle incoming JSON-RPC message object.
 * Validates JSON-RPC 2.0 structure, VFS precondition for LSP methods, and dispatches to handlers.
 *
 * @param {object} msg JSON-RPC message
 */
async function handleJsonRpcMessage(msg) {
  const { jsonrpc, id, method, params } = msg || {};

  if (jsonrpc !== '2.0' || typeof method !== 'string') {
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: {
          code: JsonRpcErrorCode.InvalidRequest,
          message: 'Invalid JSON-RPC 2.0 payload',
        },
      });
    }
    return;
  }

  postLog(`Received: ${method} (id:${id ?? '-'})`);

  // Methods that assume VFS / LSP presence:
  // - textDocument/* always requires VFS
  // - lsp/* except initialize/ping/shutdown require VFS
  const requiresVfs =
    method.startsWith('textDocument/') ||
    (method.startsWith('lsp/') && !['lsp/initialize', 'lsp/ping', 'lsp/shutdown'].includes(method));

  if (requiresVfs && !VfsCore.isReady()) {
    const message = 'VFS not ready. Call `vfs/ensureReady` first.';
    postLog(`Error: ${message}`);
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: JsonRpcErrorCode.ServerNotInitialized, message },
      });
    }
    return;
  }

  const handler = handlers[method];
  if (!handler) {
    const message = `Unknown method: ${method}`;
    postLog(`Error: ${message}`);
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: JsonRpcErrorCode.MethodNotFound, message },
      });
    }
    return;
  }

  try {
    const result = await handler(params);
    postLog(`Finished: ${method}`);
    if (id) {
      // JSON-RPC response for requests
      self.postMessage({
        jsonrpc: '2.0',
        id,
        result: result !== undefined ? result : null,
      });
    }
    // For notifications (no id) - no response sent
  } catch (err) {
    const message = `${method} failed: ${err?.message ?? String(err)}`;
    postLog(`Error: ${message}`);
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: JsonRpcErrorCode.ServerError, message },
      });
    }
  }
}

// Message event listener
self.addEventListener('message', async (event) => {
  const { data } = event;

  // Toggle debug mode via simple string messages 'debug:on' | 'debug:off'
  if (typeof data === 'string' && data.startsWith('debug:')) {
    const enabled = data === 'debug:on';
    setDebug(enabled);
    postLog(`Debug mode set ${enabled}`);
    return;
  }

  // JSON-RPC
  if (data?.jsonrpc === '2.0') {
    await handleJsonRpcMessage(data);
    return;
  }

  // Unknown non-jsonrpc message: keep for backwards compatibility
  postLog(`Received unknown message format: ${JSON.stringify(data)}`);
});

// Announce ready
postLog('Worker loaded and ready.');
self.postMessage({ jsonrpc: '2.0', method: 'worker/ready' });
```

## v0.0.3.1

```js
// worker.js
// v0.0.3.1

import { VfsCore } from './core/vfs-core.js';
import { LspCore } from './core/lsp-core.js';
import { JsonRpcErrorCode } from './core/error-codes.js';
import { postLog, setDebug } from './util/logger.js';

// Enable debug by default for test runner visibility
setDebug(true);

// handlers: "method" -> async function(params)
// - Requests (with id) return a result via JSON-RPC response
// - Notifications (no id) do not return a response
const handlers = {
  // VFS
  'vfs/ensureReady': async (params) => await VfsCore.ensureReady(),
  
  // テスト専用: VFS をリセットして単一インスタンス初期状態に戻す
  'vfs/resetForTest': async (params) => await VfsCore.resetForTest(params),
  // テスト専用: テスト専用内部情報の取得
  'vfs/_getEnvInfo': async () => {
    return VfsCore.getEnvInfo();
  },



  // LSP lifecycle / utility
  'lsp/ping': async () => 'pong',
  'lsp/shutdown': async () => {
    postLog('Worker shutting down...');
    setTimeout(() => self.close(), 100);
    return 'shutdown-complete';
  },
  'lsp/initialize': async (params) => await LspCore.initialize(params),

  // Document sync (VFS required)
  'textDocument/didOpen': async (params) => await LspCore.didOpen(params),
  'textDocument/didChange': async (params) => await LspCore.didChange(params),
  'textDocument/didClose': async (params) => await LspCore.didClose(params),
};

// ============================================================
// JSON-RPC Message Processing
// ============================================================

/**
 * Handle incoming JSON-RPC message object.
 * Validates JSON-RPC 2.0 structure, VFS precondition for LSP methods, and dispatches to handlers.
 *
 * @param {object} msg JSON-RPC message
 */
async function handleJsonRpcMessage(msg) {
  const { jsonrpc, id, method, params } = msg || {};

  if (jsonrpc !== '2.0' || typeof method !== 'string') {
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: {
          code: JsonRpcErrorCode.InvalidRequest,
          message: 'Invalid JSON-RPC 2.0 payload',
        },
      });
    }
    return;
  }

  postLog(`Received: ${method} (id:${id ?? '-'})`);

  // Methods that assume VFS / LSP presence:
  // - textDocument/* always requires VFS
  // - lsp/* except initialize/ping/shutdown require VFS
  const requiresVfs =
    method.startsWith('textDocument/') ||
    (method.startsWith('lsp/') && !['lsp/initialize', 'lsp/ping', 'lsp/shutdown'].includes(method));

  if (requiresVfs && !VfsCore.isReady()) {
    const message = 'VFS not ready. Call `vfs/ensureReady` first.';
    postLog(`Error: ${message}`);
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: JsonRpcErrorCode.ServerNotInitialized, message },
      });
    }
    return;
  }

  const handler = handlers[method];
  if (!handler) {
    const message = `Unknown method: ${method}`;
    postLog(`Error: ${message}`);
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: JsonRpcErrorCode.MethodNotFound, message },
      });
    }
    return;
  }

  try {
    const result = await handler(params);
    postLog(`Finished: ${method}`);
    if (id) {
      // JSON-RPC response for requests
      self.postMessage({
        jsonrpc: '2.0',
        id,
        result: result !== undefined ? result : null,
      });
    }
    // For notifications (no id) - no response sent
  } catch (err) {
    const message = `${method} failed: ${err?.message ?? String(err)}`;
    postLog(`Error: ${message}`);
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: JsonRpcErrorCode.ServerError, message },
      });
    }
  }
}

// Message event listener
self.addEventListener('message', async (event) => {
  const { data } = event;

  // Toggle debug mode via simple string messages 'debug:on' | 'debug:off'
  if (typeof data === 'string' && data.startsWith('debug:')) {
    const enabled = data === 'debug:on';
    setDebug(enabled);
    postLog(`Debug mode set ${enabled}`);
    return;
  }

  // JSON-RPC
  if (data?.jsonrpc === '2.0') {
    await handleJsonRpcMessage(data);
    return;
  }

  // Unknown non-jsonrpc message: keep for backwards compatibility
  postLog(`Received unknown message format: ${JSON.stringify(data)}`);
});

// Announce ready
postLog('Worker loaded and ready.');
self.postMessage({ jsonrpc: '2.0', method: 'worker/ready' });
```
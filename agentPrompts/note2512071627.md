```js
// core/vfs-core.js
// v0.0.2.14


import * as vfs from 'https://esm.sh/@typescript/vfs';
import ts from 'https://esm.sh/typescript';
import { postLog } from '../util/logger.js';
import { sleep } from '../util/async-utils.js';

let cachedDefaultMap = null;
let vfsReady = false;
let _ensurePromise = null;

function normalizeVfsPath(p) {
  if (!p) return '';
  let s = String(p).replace(/^file:\/\//, '');
  if (!s.startsWith('/')) s = `/${s}`;
  return s;
}

function mapClone(src) {
  return new Map(src);
}

async function createDefaultMapWithRetries(
  retryCount = 3,
  perAttemptTimeoutMs = 5000
) {
  let lastError = null;
  for (let attempt = 1; attempt <= retryCount; attempt++) {
    postLog(`VFS init attempt ${attempt}/${retryCount}`);
    try {
      const timeout = new Promise((_, reject) =>
        setTimeout(() => reject(new Error('timeout')), perAttemptTimeoutMs)
      );

      const defaultMap = await Promise.race([
        vfs.createDefaultMapFromCDN(
          {
            target: ts.ScriptTarget.ES2022,
            module: ts.ModuleKind.ESNext,
          },
          ts.version,
          false,
          ts
        ),
        timeout,
      ]);

      postLog(`defaultMap size: ${defaultMap.size}`);
      return defaultMap;
    } catch (error) {
      lastError = error;
      const msg = String(error?.message ?? error);
      if (msg.includes('fetch') || msg.includes('NetworkError')) {
        postLog(`Network error while fetching defaultMap: ${msg}`);
        throw error;
      }
      if (msg.includes('timeout')) {
        postLog(`Timeout on attempt ${attempt}, retrying after backoff`);
        await sleep(1000 * attempt);
        continue;
      }
      postLog(`createDefaultMapWithRetries unknown error: ${msg}`);
      throw error;
    }
  }

  throw lastError || new Error('VFS init failed after retries');
}

export async function ensureReady(retry = 3, timeoutMs = 5000) {
  if (vfsReady && cachedDefaultMap) {
    postLog('Using existing cachedDefaultMap (already ready)');
    return;
  }
  if (_ensurePromise) return _ensurePromise;

  _ensurePromise = (async () => {
    try {
      if (!cachedDefaultMap) {
        cachedDefaultMap = await createDefaultMapWithRetries(retry, timeoutMs);
      } else {
        postLog('Using existing cachedDefaultMap (populate)');
      }
      vfsReady = true;
      postLog('VFS ensureReady complete');
    } finally {
      _ensurePromise = null;
    }
  })();

  return _ensurePromise;
}

export function getDefaultMap() {
  return cachedDefaultMap;
}

export function getDefaultCompilerOptions() {
  // Balanced defaults for browser VFS but compatible with Node-like resolution where necessary.
  return {
    target: ts.ScriptTarget.ES2022,
    module: ts.ModuleKind.ESNext,
    moduleResolution: ts.ModuleResolutionKind.Bundler,
    strict: true,
    allowImportingTsExtensions: true,
    allowArbitraryExtensions: true,
    resolvePackageJsonExports: true,
    resolvePackageJsonImports: true,
    skipLibCheck: true,
    useDefineForClassFields: true,
    noEmit: true,
  };
}

export function createEnvironment(
  compilerOptions = {},
  rootFiles = [],
  initialFiles = {}
) {
  if (!cachedDefaultMap) {
    throw new Error('VFS not initialized. Call ensureReady() first.');
  }

  const mapForEnv = mapClone(cachedDefaultMap);

  const normalizedInitialFiles = {};
  for (const [rawKey, content] of Object.entries(initialFiles || {})) {
    try {
      const key = normalizeVfsPath(rawKey);
      const data = String(content ?? '');
      normalizedInitialFiles[key] = data;
      mapForEnv.set(key, data);
      postLog(`createEnvironment: injected initial file: ${key}`);
    } catch (e) {
      postLog(
        `createEnvironment: failed to inject initial file ${rawKey}: ${String(
          e?.message ?? e
        )}`
      );
    }
  }

  const system = vfs.createSystem(mapForEnv);

  const rootPaths = (rootFiles || []).map((r) => normalizeVfsPath(r));

  const defaultOptions = getDefaultCompilerOptions();
  const opts = Object.assign({}, defaultOptions, compilerOptions);

  postLog(
    `createEnvironment: about to create env; roots: [${rootPaths.join(
      ', '
    )}], initialFiles: [${Object.keys(normalizedInitialFiles).join(
      ', '
    )}], opts: ${JSON.stringify(opts)}`
  );

  const env = vfs.createVirtualTypeScriptEnvironment(
    system,
    rootPaths,
    ts,
    opts
  );

  postLog(`VFS environment created; roots: [${rootPaths.join(', ')}]`);

  // Defensive: ensure env has the content
  for (const [path, content] of Object.entries(normalizedInitialFiles)) {
    try {
      if (env.getSourceFile && env.getSourceFile(path)) {
        env.updateFile(path, content);
      } else {
        env.createFile(path, content);
      }
    } catch (e) {
      postLog(
        `createEnvironment sync apply failed for ${path}: ${String(
          e?.message ?? e
        )}`
      );
    }
  }

  try {
    env.languageService.getProgram();
  } catch (e) {
    postLog(
      `getProgram() failed after env creation: ${String(e?.message ?? e)}`
    );
  }

  return env;
}

export function resetForTest() {
  cachedDefaultMap = null;
  vfsReady = false;
  _ensurePromise = null;
  postLog('VfsCore resetForTest() called');
}

export const VfsCore = {
  ensureReady,
  isReady: () => vfsReady,
  getDefaultMap,
  createEnvironment,
  getDefaultCompilerOptions,
  resetForTest,
};
```


```js
// core/vfs-core.js
// v0.0.3.0
// - Class-based refactor of v0.0.2.14
// - Exposes the same public API as before (ensureReady, createEnvironment, getDefaultCompilerOptions, getDefaultMap, resetForTest, isReady)
// - Additionally exposes instance helpers: getEnv(), updateFile(path, content), deleteFile(path) for future incremental work
// - Keeps robust defaultMap fetch with retries and the same normalization behavior

import * as vfs from 'https://esm.sh/@typescript/vfs';
import ts from 'https://esm.sh/typescript';
import { postLog } from '../util/logger.js';
import { sleep } from '../util/async-utils.js';

function normalizeVfsPath(p) {
  if (!p) return '';
  let s = String(p).replace(/^file:\/\//, '');
  if (!s.startsWith('/')) s = `/${s}`;
  return s;
}

function mapClone(src) {
  return new Map(src);
}

class VfsCoreImpl {
  constructor() {
    this._cachedDefaultMap = null;
    this._vfsReady = false;
    this._ensurePromise = null;

    // last created environment (kept for inspection / incremental updates)
    // Note: createEnvironment still returns a fresh env (compatible), but we keep a reference
    // so callers can use updateFile/deleteFile/getEnv for future incremental optimizations.
    this._env = null;
  }

  async _createDefaultMapWithRetries(retryCount = 3, perAttemptTimeoutMs = 5000) {
    let lastError = null;
    for (let attempt = 1; attempt <= retryCount; attempt++) {
      postLog(`VFS init attempt ${attempt}/${retryCount}`);
      try {
        const timeout = new Promise((_, reject) =>
          setTimeout(() => reject(new Error('timeout')), perAttemptTimeoutMs)
        );

        const defaultMap = await Promise.race([
          vfs.createDefaultMapFromCDN(
            {
              target: ts.ScriptTarget.ES2022,
              module: ts.ModuleKind.ESNext,
            },
            ts.version,
            false,
            ts
          ),
          timeout,
        ]);

        postLog(`defaultMap size: ${defaultMap.size}`);
        return defaultMap;
      } catch (error) {
        lastError = error;
        const msg = String(error?.message ?? error);
        if (msg.includes('fetch') || msg.includes('NetworkError')) {
          postLog(`Network error while fetching defaultMap: ${msg}`);
          throw error;
        }
        if (msg.includes('timeout')) {
          postLog(`Timeout on attempt ${attempt}, retrying after backoff`);
          await sleep(1000 * attempt);
          continue;
        }
        postLog(`createDefaultMapWithRetries unknown error: ${msg}`);
        throw error;
      }
    }

    throw lastError || new Error('VFS init failed after retries');
  }

  /**
   * ensureReady(retry = 3, timeoutMs = 5000)
   * - idempotent
   * - caches the defaultMap at instance level
   */
  async ensureReady(retry = 3, timeoutMs = 5000) {
    if (this._vfsReady && this._cachedDefaultMap) {
      postLog('Using existing cachedDefaultMap (already ready)');
      return;
    }
    if (this._ensurePromise) return this._ensurePromise;

    this._ensurePromise = (async () => {
      try {
        if (!this._cachedDefaultMap) {
          this._cachedDefaultMap = await this._createDefaultMapWithRetries(
            retry,
            timeoutMs
          );
        } else {
          postLog('Using existing cachedDefaultMap (populate)');
        }
        this._vfsReady = true;
        postLog('VFS ensureReady complete');
      } finally {
        this._ensurePromise = null;
      }
    })();

    return this._ensurePromise;
  }

  isReady() {
    return this._vfsReady;
  }

  getDefaultMap() {
    return this._cachedDefaultMap;
  }

  getDefaultCompilerOptions() {
    // Balanced defaults for browser VFS but compatible with Node-like resolution where necessary.
    return {
      target: ts.ScriptTarget.ES2022,
      module: ts.ModuleKind.ESNext,
      moduleResolution: ts.ModuleResolutionKind.Bundler,
      strict: true,
      allowImportingTsExtensions: true,
      allowArbitraryExtensions: true,
      resolvePackageJsonExports: true,
      resolvePackageJsonImports: true,
      skipLibCheck: true,
      useDefineForClassFields: true,
      noEmit: true,
    };
  }

  /**
   * createEnvironment(compilerOptions = {}, rootFiles = [], initialFiles = {})
   *
   * - Creates a Virtual TS environment using a cloned default map
   * - Injects provided initialFiles into the system
   * - Stores the created env in this._env for later inspection/manipulation
   * - Returns the created env (compatible with previous API)
   */
  createEnvironment(compilerOptions = {}, rootFiles = [], initialFiles = {}) {
    if (!this._cachedDefaultMap) {
      throw new Error('VFS not initialized. Call ensureReady() first.');
    }

    const mapForEnv = mapClone(this._cachedDefaultMap);

    const normalizedInitialFiles = {};
    for (const [rawKey, content] of Object.entries(initialFiles || {})) {
      try {
        const key = normalizeVfsPath(rawKey);
        const data = String(content ?? '');
        normalizedInitialFiles[key] = data;
        mapForEnv.set(key, data);
        postLog(`createEnvironment: injected initial file: ${key}`);
      } catch (e) {
        postLog(
          `createEnvironment: failed to inject initial file ${rawKey}: ${String(
            e?.message ?? e
          )}`
        );
      }
    }

    const system = vfs.createSystem(mapForEnv);

    const rootPaths = (rootFiles || []).map((r) => normalizeVfsPath(r));

    const defaultOptions = this.getDefaultCompilerOptions();
    const opts = Object.assign({}, defaultOptions, compilerOptions);

    postLog(
      `createEnvironment: about to create env; roots: [${rootPaths.join(
        ', '
      )}], initialFiles: [${Object.keys(normalizedInitialFiles).join(
        ', '
      )}], opts: ${JSON.stringify(opts)}`
    );

    const env = vfs.createVirtualTypeScriptEnvironment(system, rootPaths, ts, opts);

    postLog(`VFS environment created; roots: [${rootPaths.join(', ')}]`);

    // Ensure env sees the injected content
    for (const [path, content] of Object.entries(normalizedInitialFiles)) {
      try {
        if (env.getSourceFile && env.getSourceFile(path)) {
          env.updateFile(path, content);
        } else {
          env.createFile(path, content);
        }
      } catch (e) {
        postLog(`createEnvironment sync apply failed for ${path}: ${String(e?.message ?? e)}`);
      }
    }

    try {
      env.languageService.getProgram();
    } catch (e) {
      postLog(`getProgram() failed after env creation: ${String(e?.message ?? e)}`);
    }

    // Keep reference for later incremental operations (updateFile/deleteFile)
    this._env = env;

    return env;
  }

  /**
   * getEnv()
   * - Return the last created environment, if any
   * - Useful for incremental operations and tests
   */
  getEnv() {
    return this._env;
  }

  /**
   * updateFile(path, content)
   * - Convenience wrapper around env.updateFile / createFile
   * - Accepts either a normalized VFS path or a file:// URI
   */
  updateFile(rawPath, content) {
    if (!this._env) {
      throw new Error('No env available. Call createEnvironment() first.');
    }
    const path = normalizeVfsPath(rawPath);
    try {
      if (this._env.getSourceFile && this._env.getSourceFile(path)) {
        this._env.updateFile(path, String(content ?? ''));
      } else {
        this._env.createFile(path, String(content ?? ''));
      }
    } catch (e) {
      postLog(`updateFile failed for ${path}: ${String(e?.message ?? e)}`);
      throw e;
    }
  }

  /**
   * deleteFile(path)
   * - Remove file from the underlying virtual system if supported
   */
  deleteFile(rawPath) {
    if (!this._env) {
      throw new Error('No env available. Call createEnvironment() first.');
    }
    const path = normalizeVfsPath(rawPath);
    try {
      // vfs.createSystem(map) returns a system with deleteFile if supported by @typescript/vfs
      if (this._env.deleteFile) {
        this._env.deleteFile(path);
      } else if (this._env.system && this._env.system.deleteFile) {
        this._env.system.deleteFile(path);
      } else {
        // best-effort: attempt to update to empty string
        this._env.updateFile(path, '');
      }
    } catch (e) {
      postLog(`deleteFile failed for ${path}: ${String(e?.message ?? e)}`);
      throw e;
    }
  }

  /**
   * resetForTest()
   * - Clear cached default map and env state for tests
   */
  resetForTest() {
    this._cachedDefaultMap = null;
    this._vfsReady = false;
    this._ensurePromise = null;
    this._env = null;
    postLog('VfsCore resetForTest() called');
  }
}

// Export a single instance to preserve prior module-level singleton behavior
export const VfsCore = new VfsCoreImpl();

// Also provide backwards-compatible named exports (optional helper functions)
// These keep previous import shape like: import { ensureReady, createEnvironment } from './core/vfs-core.js'
export const ensureReady = (...args) => VfsCore.ensureReady(...args);
export const isReady = () => VfsCore.isReady();
export const getDefaultMap = () => VfsCore.getDefaultMap();
export const getDefaultCompilerOptions = () => VfsCore.getDefaultCompilerOptions();
export const createEnvironment = (...args) => VfsCore.createEnvironment(...args);
export const resetForTest = () => VfsCore.resetForTest();
export const getEnv = () => VfsCore.getEnv();
export const updateFile = (p, c) => VfsCore.updateFile(p, c);
export const deleteFile = (p) => VfsCore.deleteFile(p);
```


```js
// core/vfs-core.js
// v0.0.2.xx (class 化版)

// 役割: VFS 初期化、defaultMap のキャッシュ、環境生成、テスト用リセット

import * as vfs from 'https://esm.sh/@typescript/vfs';
import ts from 'https://esm.sh/typescript';
import { postLog } from '../util/logger.js';
import { sleep } from '../util/async-utils.js';

// =============================================
// VfsCore 本体クラス
// =============================================

export class VfsCore {
  // -------------------------------------------
  // 静的フィールド: シングルトン的キャッシュ
  // -------------------------------------------
  static cachedDefaultMap = null;       // CDN から取得した lib ファイル群
  static vfsReady = false;              // defaultMap が使える状態か
  static _ensurePromise = null;         // ensureReady の排他制御

  // -------------------------------------------
  // パスを VFS 標準形式に合わせる
  // -------------------------------------------
  static normalizeVfsPath(p) {
    if (!p) return '';
    let s = String(p).replace(/^file:\/\//, '');
    if (!s.startsWith('/')) s = `/${s}`;
    return s;
  }

  // -------------------------------------------
  // Map の浅いクローン生成
  // -------------------------------------------
  static mapClone(src) {
    return new Map(src);
  }

  // -------------------------------------------
  // CDN の defaultMap をリトライ付きで取得
  // -------------------------------------------
  static async createDefaultMapWithRetries(
    retryCount = 3,
    perAttemptTimeoutMs = 5000
  ) {
    let lastError = null;

    for (let attempt = 1; attempt <= retryCount; attempt++) {
      postLog(`VFS init attempt ${attempt}/${retryCount}`);

      try {
        // タイムアウト監視
        const timeout = new Promise((_, reject) =>
          setTimeout(() => reject(new Error('timeout')), perAttemptTimeoutMs)
        );

        // CDN 取得 + タイムアウト競合
        const defaultMap = await Promise.race([
          vfs.createDefaultMapFromCDN(
            {
              target: ts.ScriptTarget.ES2022,
              module: ts.ModuleKind.ESNext,
            },
            ts.version,
            false,
            ts
          ),
          timeout
        ]);

        postLog(`defaultMap size: ${defaultMap.size}`);
        return defaultMap;

      } catch (error) {
        lastError = error;
        const msg = String(error?.message ?? error);

        // ネットワーク系は致命的扱い
        if (msg.includes('fetch') || msg.includes('NetworkError')) {
          postLog(`Network error while fetching defaultMap: ${msg}`);
          throw error;
        }

        // タイムアウトはリトライ
        if (msg.includes('timeout')) {
          postLog(`Timeout on attempt ${attempt}, retrying after backoff`);
          await sleep(1000 * attempt);
          continue;
        }

        // その他エラー
        postLog(`createDefaultMapWithRetries unknown error: ${msg}`);
        throw error;
      }
    }

    throw lastError || new Error('VFS init failed after retries');
  }

  // -------------------------------------------
  // defaultMap が準備完了するまで待つ
  // -------------------------------------------
  static async ensureReady(retry = 3, timeoutMs = 5000) {
    if (VfsCore.vfsReady && VfsCore.cachedDefaultMap) {
      postLog('Using existing cachedDefaultMap (already ready)');
      return;
    }

    // 同時実行を防ぎ、1つの Promise に集約
    if (VfsCore._ensurePromise) return VfsCore._ensurePromise;

    VfsCore._ensurePromise = (async () => {
      try {
        if (!VfsCore.cachedDefaultMap) {
          VfsCore.cachedDefaultMap =
            await VfsCore.createDefaultMapWithRetries(retry, timeoutMs);
        } else {
          postLog('Using existing cachedDefaultMap (populate)');
        }

        VfsCore.vfsReady = true;
        postLog('VFS ensureReady complete');

      } finally {
        // クリティカルセクション終了
        VfsCore._ensurePromise = null;
      }
    })();

    return VfsCore._ensurePromise;
  }

  // -------------------------------------------
  // defaultMap の参照提供
  // -------------------------------------------
  static getDefaultMap() {
    return VfsCore.cachedDefaultMap;
  }

  // -------------------------------------------
  // デフォルトの compilerOptions を返す
  // -------------------------------------------
  static getDefaultCompilerOptions() {
    return {
      target: ts.ScriptTarget.ES2022,
      module: ts.ModuleKind.ESNext,

      // ブラウザ環境での Node-like module resolution を両立する構成
      moduleResolution: ts.ModuleResolutionKind.Bundler,

      strict: true,
      allowImportingTsExtensions: true,
      allowArbitraryExtensions: true,
      resolvePackageJsonExports: true,
      resolvePackageJsonImports: true,
      skipLibCheck: true,
      useDefineForClassFields: true,
      noEmit: true
    };
  }

  // -------------------------------------------
  // VFS 環境の生成
  // -------------------------------------------
  static createEnvironment(
    compilerOptions = {},
    rootFiles = [],
    initialFiles = {}
  ) {
    if (!VfsCore.cachedDefaultMap) {
      throw new Error('VFS not initialized. Call ensureReady() first.');
    }

    // defaultMap を複製して環境専用 map を作成
    const mapForEnv = VfsCore.mapClone(VfsCore.cachedDefaultMap);

    // 初期ファイルを正規化して map に追加
    const normalizedInitialFiles = {};

    for (const [rawKey, content] of Object.entries(initialFiles || {})) {
      try {
        const key = VfsCore.normalizeVfsPath(rawKey);
        const data = String(content ?? '');
        normalizedInitialFiles[key] = data;

        mapForEnv.set(key, data);
        postLog(`createEnvironment: injected initial file: ${key}`);

      } catch (e) {
        postLog(
          `createEnvironment: failed to inject initial file ${rawKey}: ${
            String(e?.message ?? e)
          }`
        );
      }
    }

    // VFS の仮想 System を作成
    const system = vfs.createSystem(mapForEnv);

    // ルートファイルのパスを整形
    const rootPaths = (rootFiles || [])
      .map((r) => VfsCore.normalizeVfsPath(r));

    // compilerOptions をマージ
    const defaultOptions = VfsCore.getDefaultCompilerOptions();
    const opts = Object.assign({}, defaultOptions, compilerOptions);

    postLog(
      `createEnvironment: about to create env; roots: [${rootPaths.join(', ')}], `
      + `initialFiles: [${Object.keys(normalizedInitialFiles).join(', ')}], `
      + `opts: ${JSON.stringify(opts)}`
    );

    // 実際の Virtual TS Environment を生成
    const env = vfs.createVirtualTypeScriptEnvironment(
      system,
      rootPaths,
      ts,
      opts
    );

    postLog(`VFS environment created; roots: [${rootPaths.join(', ')}]`);

    // 追加の防御: 必ず sourceFile として適用されるよう同期反映
    for (const [path, content] of Object.entries(normalizedInitialFiles)) {
      try {
        if (env.getSourceFile && env.getSourceFile(path)) {
          env.updateFile(path, content);
        } else {
          env.createFile(path, content);
        }
      } catch (e) {
        postLog(
          `createEnvironment sync apply failed for ${path}: ${
            String(e?.message ?? e)
          }`
        );
      }
    }

    // getProgram を一度走らせて内部状態を確定
    try {
      env.languageService.getProgram();
    } catch (e) {
      postLog(
        `getProgram() failed after env creation: ${String(e?.message ?? e)}`
      );
    }

    return env;
  }

  // -------------------------------------------
  // テスト用リセット
  // -------------------------------------------
  static resetForTest() {
    VfsCore.cachedDefaultMap = null;
    VfsCore.vfsReady = false;
    VfsCore._ensurePromise = null;

    postLog('VfsCore resetForTest() called');
  }
}

// 旧 API 互換の名前付きエクスポート（削除してもよい）
export const VfsCoreAPI = VfsCore;
export const ensureReady = VfsCore.ensureReady;
export const createEnvironment = VfsCore.createEnvironment;
export const resetForTest = VfsCore.resetForTest;
export const getDefaultMap = VfsCore.getDefaultMap;
export const getDefaultCompilerOptions = VfsCore.getDefaultCompilerOptions;
```

```js
// core/vfs-core.js
// v0.0.3.0 (instance + private fields, 日本語コメント)

import * as vfs from 'https://esm.sh/@typescript/vfs';
import ts from 'https://esm.sh/typescript';
import { postLog } from '../util/logger.js';
import { sleep } from '../util/async-utils.js';

class VfsCoreClass {
  // private state（インスタンス内に隠蔽）
  #cachedDefaultMap = null;
  #vfsReady = false;
  #ensurePromise = null;

  // private: パス正規化
  #normalizeVfsPath(p) {
    if (!p) return '';
    let s = String(p).replace(/^file:\/\//, '');
    if (!s.startsWith('/')) s = `/${s}`;
    return s;
  }

  // private: map の浅いクローン
  #mapClone(src) {
    return new Map(src);
  }

  // private: CDN から defaultMap を取得（リトライ付き）
  async #createDefaultMapWithRetries(retryCount = 3, perAttemptTimeoutMs = 5000) {
    let lastError = null;
    for (let attempt = 1; attempt <= retryCount; attempt++) {
      postLog(`VFS init attempt ${attempt}/${retryCount}`);
      try {
        const timeout = new Promise((_, reject) =>
          setTimeout(() => reject(new Error('timeout')), perAttemptTimeoutMs)
        );

        const defaultMap = await Promise.race([
          vfs.createDefaultMapFromCDN(
            {
              target: ts.ScriptTarget.ES2022,
              module: ts.ModuleKind.ESNext,
            },
            ts.version,
            false,
            ts
          ),
          timeout,
        ]);

        postLog(`defaultMap size: ${defaultMap.size}`);
        return defaultMap;
      } catch (error) {
        lastError = error;
        const msg = String(error?.message ?? error);
        if (msg.includes('fetch') || msg.includes('NetworkError')) {
          postLog(`Network error while fetching defaultMap: ${msg}`);
          throw error;
        }
        if (msg.includes('timeout')) {
          postLog(`Timeout on attempt ${attempt}, retrying after backoff`);
          await sleep(1000 * attempt);
          continue;
        }
        postLog(`createDefaultMapWithRetries unknown error: ${msg}`);
        throw error;
      }
    }
    throw lastError || new Error('VFS init failed after retries');
  }

  // public: ensure defaultMap が準備されるまで待つ
  async ensureReady(retry = 3, timeoutMs = 5000) {
    if (this.#vfsReady && this.#cachedDefaultMap) {
      postLog('Using existing cachedDefaultMap (already ready)');
      return;
    }
    if (this.#ensurePromise) return this.#ensurePromise;

    this.#ensurePromise = (async () => {
      try {
        if (!this.#cachedDefaultMap) {
          this.#cachedDefaultMap = await this.#createDefaultMapWithRetries(
            retry,
            timeoutMs
          );
        } else {
          postLog('Using existing cachedDefaultMap (populate)');
        }
        this.#vfsReady = true;
        postLog('VFS ensureReady complete');
      } finally {
        this.#ensurePromise = null;
      }
    })();

    return this.#ensurePromise;
  }

  // public: defaultMap を返す（テストや外部参照用）
  getDefaultMap() {
    return this.#cachedDefaultMap;
  }

  // public: デフォルト compilerOptions
  getDefaultCompilerOptions() {
    return {
      target: ts.ScriptTarget.ES2022,
      module: ts.ModuleKind.ESNext,
      moduleResolution: ts.ModuleResolutionKind.Bundler,
      strict: true,
      allowImportingTsExtensions: true,
      allowArbitraryExtensions: true,
      resolvePackageJsonExports: true,
      resolvePackageJsonImports: true,
      skipLibCheck: true,
      useDefineForClassFields: true,
      noEmit: true,
    };
  }

  // public: VFS 環境を作成して返す
  createEnvironment(compilerOptions = {}, rootFiles = [], initialFiles = {}) {
    if (!this.#cachedDefaultMap) {
      throw new Error('VFS not initialized. Call ensureReady() first.');
    }

    const mapForEnv = this.#mapClone(this.#cachedDefaultMap);
    const normalizedInitialFiles = {};

    for (const [rawKey, content] of Object.entries(initialFiles || {})) {
      try {
        const key = this.#normalizeVfsPath(rawKey);
        const data = String(content ?? '');
        normalizedInitialFiles[key] = data;
        mapForEnv.set(key, data);
        postLog(`createEnvironment: injected initial file: ${key}`);
      } catch (e) {
        postLog(
          `createEnvironment: failed to inject initial file ${rawKey}: ${String(
            e?.message ?? e
          )}`
        );
      }
    }

    const system = vfs.createSystem(mapForEnv);
    const rootPaths = (rootFiles || []).map((r) => this.#normalizeVfsPath(r));
    const defaultOptions = this.getDefaultCompilerOptions();
    const opts = Object.assign({}, defaultOptions, compilerOptions);

    postLog(
      `createEnvironment: about to create env; roots: [${rootPaths.join(
        ', '
      )}], initialFiles: [${Object.keys(normalizedInitialFiles).join(
        ', '
      )}], opts: ${JSON.stringify(opts)}`
    );

    const env = vfs.createVirtualTypeScriptEnvironment(system, rootPaths, ts, opts);
    postLog(`VFS environment created; roots: [${rootPaths.join(', ')}]`);

    // 同期的に内容を反映
    for (const [path, content] of Object.entries(normalizedInitialFiles)) {
      try {
        if (env.getSourceFile && env.getSourceFile(path)) {
          env.updateFile(path, content);
        } else {
          env.createFile(path, content);
        }
      } catch (e) {
        postLog(
          `createEnvironment sync apply failed for ${path}: ${String(e?.message ?? e)}`
        );
      }
    }

    try {
      env.languageService.getProgram();
    } catch (e) {
      postLog(`getProgram() failed after env creation: ${String(e?.message ?? e)}`);
    }

    return env;
  }

  // public: テスト用に状態をリセット
  resetForTest() {
    this.#cachedDefaultMap = null;
    this.#vfsReady = false;
    this.#ensurePromise = null;
    postLog('VfsCore resetForTest() called');
  }

  // public: 現在準備済みか（外部参照用）
  isReady() {
    return !!(this.#vfsReady && this.#cachedDefaultMap);
  }
}

// シングルトンインスタンスをエクスポート（既存コード互換のために名前は VfsCore）
export const VfsCore = new VfsCoreClass();

// 旧 API 互換: 関数としても呼べるようにバインドしておく
export const ensureReady = VfsCore.ensureReady.bind(VfsCore);
export const createEnvironment = VfsCore.createEnvironment.bind(VfsCore);
export const resetForTest = VfsCore.resetForTest.bind(VfsCore);
export const getDefaultMap = VfsCore.getDefaultMap.bind(VfsCore);
export const getDefaultCompilerOptions = VfsCore.getDefaultCompilerOptions.bind(VfsCore);
export const isReady = VfsCore.isReady.bind(VfsCore);

```
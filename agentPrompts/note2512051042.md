
[ChatGPT - LSP/VFS プロジェクト支援](https://chatgpt.com/s/t_69323883e7908191b5477bfa1b456b4c)

了解した。VfsCore の class 化 → 単一 env 化 → incremental へ進めるために必要なテストセットを段階的に提示する。各テストについて
	•	目的（何を検証するか）
	•	依存（既存の Worker RPC で実行可か／追加のテスト専用 RPC が要るか）
	•	テストコード（あなたの既存フォーマットに合わせた実装案）

必要に応じて「最小限のテスト専用 RPC（安全で局所的）」も提案するが、まずは既存 RPC のみで可能なテストから提示する。

⸻

まとめ（先出し結論）
	1.	すぐ書ける（既存 RPC で実行可能）テスト — class 化前の最小セット。v0.0.3 に向けたベースラインとして必須。
	2.	class 化後に追加するテスト — class の振る舞い（singleton 挙動・reset 動作）を検証。いくつかは小さなテスト専用 RPC を Worker に追加する必要あり（提案付き）。
	3.	env を単一化した段階で追加するテスト — 単一 env が維持されること、ファイル追加/更新/削除が既存 env に反映されること、incremental 実装の前提が満たされていることを検証。

以下、各テスト案（コード含む）。

⸻

A. Class 化前の最小テストセット（既存 RPC のみで実行可）

目的：現行の public API（`vfs/ensureReady`, `lsp/initialize`, `textDocument/*`）が期待どおり動くことを確認し、refactor の前提（ベースライン）を固める。

1) `vfs-ensureReady.basic.test.js` — VFS 初期化が成功する

依存：既存 RPC のみ（`vfs/ensureReady`）

```
// test/v0.0.3/vfs-ensureReady.basic.test.js
// v0.0.3.0

import { expect } from 'chai';
import {
  createTestWorker,
  waitForWorkerReady,
  sendRequest,
  addResult,
} from './test-utils.js';

console.log('🧩 vfs-ensureReady.basic.test loaded');

(async () => {
  const testName = 'VFS: ensureReady should complete without error';
  let worker;
  try {
    worker = createTestWorker('./js/worker.js');

    await waitForWorkerReady(worker);
    await sendRequest(worker, 'vfs/ensureReady');

    // no exception -> success
    addResult(testName, true);
  } catch (err) {
    addResult(testName, false, err.message);
  } finally {
    worker?.terminate();
  }
})();

2) lsp-initialize-and-openFile.basic.test.js — LSP initialize → didOpen の基本フロー

依存：既存 RPC のみ（lsp/initialize, textDocument/didOpen + publishDiagnostics を待つ）

// test/v0.0.3/lsp-initialize-and-openFile.basic.test.js
// v0.0.3.0

import { expect } from 'chai';
import {
  createTestWorker,
  waitForWorkerReady,
  sendRequest,
  sendNotification,
  waitForNotification,
  addResult,
} from './test-utils.js';

console.log('🧩 lsp-initialize-and-openFile.basic.test loaded');

(async () => {
  const testName = 'LSP: initialize and didOpen basic flow';
  let worker;
  try {
    worker = createTestWorker('./js/worker.js');

    await waitForWorkerReady(worker);
    await sendRequest(worker, 'vfs/ensureReady');
    await sendRequest(worker, 'lsp/initialize', { capabilities: {} });

    const fileUri = 'file:///basic-open.ts';
    const content = `export const v = 1;`;

    sendNotification(worker, 'textDocument/didOpen', {
      textDocument: { uri: fileUri, languageId: 'typescript', version: 1, text: content },
    });

    const diag = await waitForNotification(worker, 'textDocument/publishDiagnostics', (p) => p.uri === fileUri);
    expect(diag.uri).to.equal(fileUri);
    expect(diag.diagnostics).to.be.an('array');

    addResult(testName, true);
  } catch (err) {
    addResult(testName, false, err.message);
  } finally {
    worker?.terminate();
  }
})();
```

⸻

B. Class 化後（ただし env 単一化はまだ）に追加すべきテスト

目的：VfsCore を class に変えた後、意図せぬ API 破壊や副作用がないことを検証する。ここでは最小限のテスト専用 RPC を Worker に追加することを提案（内部状態確認のため）。

提案する最小テスト専用 RPC（Worker 側に追加）
	•	`vfs/_getEnvInfo → { envId:string, defaultMapSize:number, fileList:string[] }` を返す（読み取り専用・テスト用）
	•	vfs/resetForTest → VfsCore.resetForTest() を呼ぶ（既にコアに存在）

これらはテスト専用で短命にする。削除しやすい命名で _ プレフィックスをつける。

3) vfs-class-singleton.test.js — class にしてもデフォルト map が共有される（singleton）

依存：追加 RPC vfs/_getEnvInfo, vfs/resetForTest

```
// test/v0.0.3/vfs-class-singleton.test.js
// v0.0.3.0

import { expect } from 'chai';
import {
  createTestWorker,
  waitForWorkerReady,
  sendRequest,
  addResult,
} from './test-utils.js';

console.log('🧩 vfs-class-singleton.test loaded');

(async () => {
  const testName = 'VfsCore class: ensure singleton-like defaultMap and env identity';
  let worker;
  try {
    worker = createTestWorker('./js/worker.js');

    await waitForWorkerReady(worker);
    // reset just in case
    await sendRequest(worker, 'vfs/resetForTest');
    await sendRequest(worker, 'vfs/ensureReady');

    const info1 = await sendRequest(worker, 'vfs/_getEnvInfo');
    // call ensureReady again -> should not recreate default map
    await sendRequest(worker, 'vfs/ensureReady');
    const info2 = await sendRequest(worker, 'vfs/_getEnvInfo');

    expect(info1.defaultMapSize).to.be.a('number').that.is.greaterThan(0);
    expect(info1.defaultMapSize).to.equal(info2.defaultMapSize);
    // envId stays the same (or if you prefer, at least fileList identity same)
    expect(info1.envId).to.equal(info2.envId);

    addResult(testName, true);
  } catch (err) {
    addResult(testName, false, err.message);
  } finally {
    worker?.terminate();
  }
})();
```

説明：envId は VfsCore 側で生成する短い識別子（UUID ではなく Date.now() など）で、再作成が発生したら変わるようにする。テストは class 化で副作用が出ていないかを検出する。

⸻

C. env を単一化（常駐）に変更した後に追加すべきテスト

目的：env が常駐し、didOpen/didChange/didClose が既存 env を更新することを保証する。incremental 実装の前提を担保する。

一部テストは追加 RPC vfs/_getEnvInfo を利用して env が変わっていないことを直接検査する。その他は公開 API の振る舞いで検証する。

4) vfs-single-env-persistence.test.js — open/change/close を通じて env が継続していること

依存：vfs/_getEnvInfo

// test/v0.0.3/vfs-single-env-persistence.test.js
// v0.0.3.0

import { expect } from 'chai';
import {
  createTestWorker,
  waitForWorkerReady,
  sendRequest,
  sendNotification,
  waitForNotification,
  addResult,
} from './test-utils.js';

console.log('🧩 vfs-single-env-persistence.test loaded');

(async () => {
  const testName = 'VFS single-env persists across didOpen/didChange/didClose';
  let worker;
  try {
    worker = createTestWorker('./js/worker.js');

    await waitForWorkerReady(worker);
    await sendRequest(worker, 'vfs/resetForTest');
    await sendRequest(worker, 'vfs/ensureReady');
    await sendRequest(worker, 'lsp/initialize', { capabilities: {} });

    const infoBefore = await sendRequest(worker, 'vfs/_getEnvInfo');

    const uri = 'file:///persist.ts';
    const initial = `export const a = 1;`;
    sendNotification(worker, 'textDocument/didOpen', {
      textDocument: { uri, languageId: 'typescript', version: 1, text: initial },
    });
    await waitForNotification(worker, 'textDocument/publishDiagnostics', (p) => p.uri === uri);

    // change content
    const changed = `export const a: string = 1;`; // error
    sendNotification(worker, 'textDocument/didChange', {
      textDocument: { uri, version: 2 },
      contentChanges: [{ text: changed }],
    });
    const diag = await waitForNotification(worker, 'textDocument/publishDiagnostics', (p) => p.uri === uri);
    expect(diag.diagnostics).to.be.an('array').that.is.not.empty;

    // env identity should be unchanged
    const infoAfter = await sendRequest(worker, 'vfs/_getEnvInfo');
    expect(infoBefore.envId).to.equal(infoAfter.envId);

    // close
    sendNotification(worker, 'textDocument/didClose', { textDocument: { uri } });
    await new Promise((r) => setTimeout(r, 50)); // short wait for clear diagnostics

    addResult(testName, true);
  } catch (err) {
    addResult(testName, false, err.message);
  } finally {
    worker?.terminate();
  }
})();

5) vfs-reset-for-test.test.js — resetForTest の動作確認

依存：vfs/resetForTest（exposed RPC should call VfsCore.resetForTest）

// test/v0.0.3/vfs-reset-for-test.test.js
// v0.0.3.0

import { expect } from 'chai';
import {
  createTestWorker,
  waitForWorkerReady,
  sendRequest,
  addResult,
} from './test-utils.js';

console.log('🧩 vfs-reset-for-test.test loaded');

(async () => {
  const testName = 'VFS: resetForTest should clear cached default map and allow re-init';
  let worker;
  try {
    worker = createTestWorker('./js/worker.js');

    await waitForWorkerReady(worker);
    await sendRequest(worker, 'vfs/ensureReady');
    const before = await sendRequest(worker, 'vfs/_getEnvInfo');

    // reset
    await sendRequest(worker, 'vfs/resetForTest');

    // ensureReady creates new defaultMap
    await sendRequest(worker, 'vfs/ensureReady');
    const after = await sendRequest(worker, 'vfs/_getEnvInfo');

    // defaultMap size stays positive, envId likely changed
    expect(after.defaultMapSize).to.be.a('number').that.is.greaterThan(0);
    // envId may change -> ensure value present
    expect(after.envId).to.be.a('string');

    addResult(testName, true);
  } catch (err) {
    addResult(testName, false, err.message);
  } finally {
    worker?.terminate();
  }
})();


⸻

D. incremental 実装前に追加検討するテスト（準備系）

目的：incremental 実装を入れた時に検出しやすい回帰を防ぐためのテスト。

6) didChange-full-vs-incremental.behavior.test.js — full replace と incremental の互換性（後で使用）

依存：将来の incremental 実装を確認するためのベンチマークテスト（この段階ではスケルトンのみ）
	•	使い方：incremental 実装を導入したら、同じ最終テキスト を full replace と incremental（range）で送って挙動が一致するか比較する。

（スケルトンのみ提示。実装は incremental API 確定後に埋める）

⸻

実行方針と補足（必読）
	1.	既存テスト群はそのまま残す。class 化と env 単一化の際に既存テスト群がレッドになれば、差分を直す。
	2.	小さなテスト用 RPC の追加を提案（vfs/_getEnvInfo, vfs/resetForTest）。これらは内部状態を安全に観察するためだけの読み取り API または既存関数を呼ぶ thin wrapper。追加は optionalだが、class 化の正当性検証が格段に楽になる。
	•	追加時は名前に _ を付け、テストフェーズが終わったら削除しやすい形にする。
	3.	テストコードフォーマットは既存ルール（createTestWorker / waitForWorkerReady / sendRequest / waitForNotification / addResult）を踏襲する。
	4.	優先順
	•	最初に A（既存 RPC で実行可能なテスト）を全部通す。
	•	次に VfsCore を class 化（実装変更そのもの）。
	•	class 化後に B のテストを追加・実行（vfs/_getEnvInfo 等を一時追加）。
	•	OK なら C の単一 env に移行・テスト。
	•	最後に incremental 実装と D テスト。

⸻

次アクション（私がすぐ出す内容）
	1.	あなたが望むなら、先に「Worker に追加する最小テスト専用 RPC の実装（worker.js 側 handler）」 を提示する。これがあれば B,C のテストコードをそのまま実行可能にする。
	2.	あるいは、まず A のテストファイル群（すでに動くもの）をすべて生成して CI で回す。

どちらでも対応する。どちらに進めるか宣言して下さい（yes/no は不要）。要望がなければ、まず A の完全なテストファイル群を出力する。
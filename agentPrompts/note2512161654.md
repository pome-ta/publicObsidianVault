```
1. âœ… LSP initialize fails before ensureReady: Passed
2. âœ… worker/ready does not imply VFS ready: Passed
3. âœ… VFS API throws before ensureReady: Passed
4. âŒ VFS ensureReady initializes env: expected undefined to be a number
5. âŒ VFS resetForTest resets all state: Method not found: vfs/resetForTest
6. âœ… LSP initialize succeeds after VFS ready: Passed
7. âŒ VFS ensureReady is idempotent: expected undefined to equal 1

```

```
ğŸš€ main.js loaded
ğŸ§© vfs-ensureReady.test loaded
ğŸ§© vfs-ensureReady-idempotent.test loaded
ğŸ§© vfs-before-ensureReady.test loaded
ğŸ§© vfs-resetForTest.test loaded
ğŸ§© worker-ready-semantics.test loaded
ğŸ§© lsp-initialize-before-vfs.test loaded
ğŸ§© lsp-initialize-success.test loaded
ğŸš€ test-runner.js loaded
[16:54:15.659 | WorkerLog] [Worker] Worker loaded and ready.
[16:54:15.652 | WorkerLog] [Worker] Worker loaded and ready.
[16:54:15.667 | WorkerLog] [Worker] Worker loaded and ready.
[16:54:15.674 | WorkerLog] [Worker] Worker loaded and ready.
[16:54:15.675 | WorkerLog] [Worker] VFS init attempt 1/3
[16:54:15.676 | WorkerLog] [Worker] VFS init attempt 1/3
[16:54:15.691 | WorkerLog] [Worker] Worker loaded and ready.
[16:54:15.694 | WorkerLog] [Worker] Worker loaded and ready.
[16:54:20.680 | WorkerLog] [Worker] Timeout on attempt 1, retrying after backoff
[16:54:20.682 | WorkerLog] [Worker] Timeout on attempt 1, retrying after backoff
[16:54:20.683 | WorkerLog] [Worker] Timeout on attempt 1, retrying after backoff
[16:54:21.684 | WorkerLog] [Worker] VFS init attempt 2/3
[16:54:21.685 | WorkerLog] [Worker] VFS init attempt 2/3
[16:54:21.688 | WorkerLog] [Worker] VFS init attempt 2/3
[16:54:25.065 | WorkerLog] [Worker] defaultMap size: 79
[16:54:25.070 | WorkerLog] [Worker] defaultMap size: 79
[16:54:25.074 | WorkerLog] [Worker] defaultMap size: 79
[16:54:25.092 | WorkerLog] [Worker] defaultMap size: 79

```


## ã‚³ãƒ¼ãƒ‰

### `worker.js`

eruda ã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãªã®ã§ã€`setDebug(true);` ã§ãƒ­ã‚°ã‚’å‡ºã™ã‚ˆã†ã«ã—ã¦ã‚‹ã€‚

```
// worker.js
// v0.0.3.4

import { VfsCore } from './core/vfs-core.js';
import { LspCore } from './core/lsp-core.js';
import { JsonRpcErrorCode } from './core/error-codes.js';
import { postLog, setDebug } from './util/logger.js';

// Enable debug by default for test runner visibility
setDebug(true);

const handlers = {
  // --- lifecycle ---
  'worker/ready': async () => ({ ok: true }),

  // --- vfs ---
  'vfs/ensureReady': async () => {
    await VfsCore.ensureReady();
    return { ok: true };
  },

  'vfs/getEnvInfo': async () => {
    return VfsCore.getEnvInfo();
  },

  // --- lsp ---
  'lsp/initialize': async (params) => {
    return LspCore.initialize(params);
  },
};

self.onmessage = async (e) => {
  const msg = e.data;

  if (!msg || msg.jsonrpc !== '2.0') return;

  const { id, method, params } = msg;

  if (!handlers[method]) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: -32601, message: `Method not found: ${method}` },
      });
    }
    return;
  }

  try {
    const result = await handlers[method](params);

    if (id != null) {
      self.postMessage({ jsonrpc: '2.0', id, result });
    }
  } catch (err) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: -32000, message: err?.message ?? String(err) },
      });
    }
  }
};

// RPC å—ä»˜é–‹å§‹é€šçŸ¥
postLog('Worker loaded and ready.');
self.postMessage({ jsonrpc: '2.0', method: 'worker/ready' });

```

### `core/vfs-core.js`

`createDefaultMapWithRetry` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚ªãƒ¼ãƒãƒ¼ã§ã¯ã‚ã‚‹ãŒã€æºå¸¯å®Ÿè¡Œã®é€šä¿¡çŠ¶æ³çš„ã«ã€ãƒªãƒˆãƒ©ã‚¤æ©Ÿæ§‹ã‚’æ½¤æ²¢ã«ã—ã¦ã„ã‚‹ã€‚

```vfs-core.js
// core/vfs-core.js
// v0.0.3.4

//import * as vfs from 'https://esm.sh/@typescript/vfs';
import {
  createDefaultMapFromCDN,
  createSystem,
  createVirtualTypeScriptEnvironment,
} from 'https://esm.sh/@typescript/vfs';
import ts from 'https://esm.sh/typescript';
import { postLog } from '../util/logger.js';
import { sleep } from '../util/async-utils.js';

class VfsCoreClass {
  #env = null;
  #ready = false;
  #initializing = null;

  // CDN ã‹ã‚‰ defaultMap ã‚’å–å¾—ã™ã‚‹å†…éƒ¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£(ãƒªãƒˆãƒ©ã‚¤ä»˜ã)
  async #createDefaultMapWithRetry(retryCount = 3, perAttemptTimeoutMs = 5000) {
    let lastError = null;
    for (let attempt = 1; attempt <= retryCount; attempt++) {
      postLog(`VFS init attempt ${attempt}/${retryCount}`);
      try {
        const timeout = new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), perAttemptTimeoutMs));

        const defaultMap = await Promise.race([
          createDefaultMapFromCDN(
            {
              target: ts.ScriptTarget.ES2022,
              module: ts.ModuleKind.ESNext,
            },
            ts.version,
            false,
            ts,
          ),
          timeout,
        ]);

        postLog(`defaultMap size: ${defaultMap.size}`);
        return defaultMap;
      } catch (error) {
        lastError = error;
        const msg = String(error?.message ?? error);
        if (msg.includes('fetch') || msg.includes('NetworkError')) {
          postLog(`Network error while fetching defaultMap: ${msg}`);
          throw error;
        }
        if (msg.includes('timeout')) {
          postLog(`Timeout on attempt ${attempt}, retrying after backoff`);
          await sleep(1000 * attempt);
          continue;
        }
        postLog(`createDefaultMapWithRetries unknown error: ${msg}`);
        throw error;
      }
    }
    throw lastError || new Error('VFS init failed after retries');
  }

  async ensureReady() {
    if (this.#ready) {
      return;
    }

    if (!this.#initializing) {
      this.#initializing = this.#init();
    }

    await this.#initializing;
  }

  async #init() {
    const fsMap = await this.#createDefaultMapWithRetry();

    const system = createSystem(fsMap);

    this.#env = createVirtualTypeScriptEnvironment(system, [], ts, { target: ts.ScriptTarget.ESNext });

    this.#ready = true;
  }

  getEnvInfo() {
    return {
      ready: this.#ready,
      hasEnv: this.#env !== null,
      tsVersion: ts.version,
    };
  }

  resetForTest() {
    this.#env = null;
    this.#ready = false;
    this.#initializing = null;
  }
}

export const VfsCore = new VfsCoreClass();

```

### `core/lsp-core.js`

```lsp-core.js
// core/lsp-core.js
// v0.0.3.4

import { VfsCore } from './vfs-core.js';
import { postLog } from '../util/logger.js';

class LspCoreClass {
  #initialized = false;

  constructor() {
    postLog('LspServer instance created');
  }

  async initialize(_params) {
    if (!VfsCore.getEnvInfo().ready) {
      throw new Error('VFS is not ready');
    }

    this.#initialized = true;

    return {
      capabilities: {},
    };
  }
}

export const LspCore = new LspCoreClass();

```

### `test/test-runner.js`


ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã¯ã€ã‚ãªãŸãŒå‡ºã—ã¦ãã‚Œã¦ã„ã‚‹ã‚³ãƒ¼ãƒ‰ã€‚å¿…è¦ã§ã‚ã‚Œã°ã“ã¡ã‚‰ã§å†æ²ã™ã‚‹ã€‚

```test-runner.js
// test/test-runner.js
// v0.0.3.ç³»

console.log('ğŸš€ test-runner.js loaded');


import './v0.0.3/vfs-ensureReady.test.js';
import './v0.0.3/vfs-ensureReady-idempotent.test.js';
import './v0.0.3/vfs-before-ensureReady.test.js';
import './v0.0.3/vfs-resetForTest.test.js';
import './v0.0.3/worker-ready-semantics.test.js';
import './v0.0.3/lsp-initialize-before-vfs.test.js';
import './v0.0.3/lsp-initialize-success.test.js';


```
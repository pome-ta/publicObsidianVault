> 1.	core/vfs-core.js „Çí class Âåñ„Åó„Å¶Âçò‰∏Ä„Ç§„É≥„Çπ„Çø„É≥„ÇπÂåñ
> 2.	env „Çí1„Å§„Å†„ÅëÊåÅ„Å°Á∂ö„Åë„ÇãÂΩ¢„Å´ÊîπÈÄ†

ÊâãÈ†ÜÂêåÊÑè„ÄÇ

TDD „ÅßÈÄ≤„ÇÅ„Å¶Ë°å„Åè„ÅÆ„Åß„ÅÇ„Çå„Å∞„ÄÅ„ÉÜ„Çπ„Éà„Ç≥„Éº„Éâ„ÅØ„ÄÅ
- class Âåñ„Å∏„ÅÆ„É™„Éï„Ç°„ÇØ„Çø„É™„É≥„Ç∞„ÅÆ„Éü„Çπ„Åå„Å™„ÅÑ„ÅãÁ¢∫Ë™ç
- env „Çí1„Å§„Å†„ÅëÊåÅ„Å£„Å¶„ÇãÁä∂ÊÖã„ÇíÁ¢∫Ë™ç

„Åø„Åü„ÅÑ„Å™„ÉÜ„Çπ„Éà„Ç≥„Éº„Éâ„ÇíÊõ∏„ÅÑ„Å¶„ÅèÔºü


„ÅÑ„Åæ„Åæ„Åß„ÅÆÂΩ¢Âºè„Åß„ÅÆ„ÄÅ„ÉÜ„Çπ„Éà„Ç≥„Éº„Éâ„ÅßÂïèÈ°å„Å™„ÅÑÔºüÔºà‰ª•‰∏ã„ÅÆ„Ç≥„Éº„Éâ„ÅÆË©≥Á¥∞„Å™ÂÜÖÂÆπ„Åß„ÅØ„Å™„Åè„ÄÅ„ÉÜ„Çπ„Éà„ÅÆ„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Å®„Åó„Å¶ÊèêÁ§∫„Åó„Å¶„ÅÑ„ÇãÔºâ

```.js
// test/v0.0.2/worker-didChange-basic.test.js
// v0.0.2.13

import { expect } from 'chai';
import {
  createTestWorker,
  waitForWorkerReady,
  sendRequest,
  sendNotification,
  waitForNotification,
  addResult,
} from './test-utils.js';

console.log('üß© worker-didChange-basic.test loaded');

(async () => {
  const testName = 'LSP: didChange basic full-replace should update diagnostics';
  let worker;

  try {
    worker = createTestWorker('./js/worker.js');

    // 1) Worker/TS/VFS Ê∫ñÂÇô
    await waitForWorkerReady(worker);
    await sendRequest(worker, 'vfs/ensureReady');
    await sendRequest(worker, 'lsp/initialize', { capabilities: {} });

    // 2) didOpen: ÂàùÊúüÂÜÖÂÆπ„ÅØ„Ç®„É©„ÉºÁÑ°„Åó
    const fileUri = 'file:///didchange-basic.ts';
    const initialContent = `export const a = 1;`;

    sendNotification(worker, 'textDocument/didOpen', {
      textDocument: {
        uri: fileUri,
        languageId: 'typescript',
        version: 1,
        text: initialContent,
      },
    });

    const initialDiag = await waitForNotification(
      worker,
      'textDocument/publishDiagnostics',
      (p) => p.uri === fileUri
    );

    expect(initialDiag.uri).to.equal(fileUri);
    expect(initialDiag.diagnostics).to.be.an('array').that.is.empty;

    // 3) didChange: full replace „Å¶„Çô„Ç®„É©„Éº„ÇíÁô∫Áîü„Åï„Åõ„ÇãÂÜÖÂÆπ„Å´Â§âÊõ¥
    const changedContent = `export const a: number = "bad";`;

    sendNotification(worker, 'textDocument/didChange', {
      textDocument: {
        uri: fileUri,
        version: 2,
      },
      contentChanges: [
        {
          text: changedContent, // full replace
        },
      ],
    });

    // 4) publishDiagnostics (Â§âÊõ¥Âæå„ÅÆÂÜÖÂÆπ„Å´Âü∫„Å§„Çô„Åè)
    const changedDiag = await waitForNotification(
      worker,
      'textDocument/publishDiagnostics',
      (p) => p.uri === fileUri
    );

    expect(changedDiag.uri).to.equal(fileUri);
    expect(changedDiag.diagnostics).to.be.an('array').with.lengthOf(1);
    expect(changedDiag.diagnostics[0].message).to.include(
      'Type \'string\' is not assignable to type \'number\''
    );

    addResult(testName, true);
  } catch (err) {
    addResult(testName, false, err.message);
  } finally {
    worker?.terminate();
  }
})();

```


ÁèæÁä∂„ÅÆ`core/vfs-core.js` „ÅØ„Åì„Çå„Åß„Åô„ÄÇ

```
// core/vfs-core.js
// v0.0.2.14


import * as vfs from 'https://esm.sh/@typescript/vfs';
import ts from 'https://esm.sh/typescript';
import { postLog } from '../util/logger.js';
import { sleep } from '../util/async-utils.js';

let cachedDefaultMap = null;
let vfsReady = false;
let _ensurePromise = null;

function normalizeVfsPath(p) {
  if (!p) return '';
  let s = String(p).replace(/^file:\/\//, '');
  if (!s.startsWith('/')) s = `/${s}`;
  return s;
}

function mapClone(src) {
  return new Map(src);
}

async function createDefaultMapWithRetries(
  retryCount = 3,
  perAttemptTimeoutMs = 5000
) {
  let lastError = null;
  for (let attempt = 1; attempt <= retryCount; attempt++) {
    postLog(`VFS init attempt ${attempt}/${retryCount}`);
    try {
      const timeout = new Promise((_, reject) =>
        setTimeout(() => reject(new Error('timeout')), perAttemptTimeoutMs)
      );

      const defaultMap = await Promise.race([
        vfs.createDefaultMapFromCDN(
          {
            target: ts.ScriptTarget.ES2022,
            module: ts.ModuleKind.ESNext,
          },
          ts.version,
          false,
          ts
        ),
        timeout,
      ]);

      postLog(`defaultMap size: ${defaultMap.size}`);
      return defaultMap;
    } catch (error) {
      lastError = error;
      const msg = String(error?.message ?? error);
      if (msg.includes('fetch') || msg.includes('NetworkError')) {
        postLog(`Network error while fetching defaultMap: ${msg}`);
        throw error;
      }
      if (msg.includes('timeout')) {
        postLog(`Timeout on attempt ${attempt}, retrying after backoff`);
        await sleep(1000 * attempt);
        continue;
      }
      postLog(`createDefaultMapWithRetries unknown error: ${msg}`);
      throw error;
    }
  }

  throw lastError || new Error('VFS init failed after retries');
}

export async function ensureReady(retry = 3, timeoutMs = 5000) {
  if (vfsReady && cachedDefaultMap) {
    postLog('Using existing cachedDefaultMap (already ready)');
    return;
  }
  if (_ensurePromise) return _ensurePromise;

  _ensurePromise = (async () => {
    try {
      if (!cachedDefaultMap) {
        cachedDefaultMap = await createDefaultMapWithRetries(retry, timeoutMs);
      } else {
        postLog('Using existing cachedDefaultMap (populate)');
      }
      vfsReady = true;
      postLog('VFS ensureReady complete');
    } finally {
      _ensurePromise = null;
    }
  })();

  return _ensurePromise;
}

export function getDefaultMap() {
  return cachedDefaultMap;
}

export function getDefaultCompilerOptions() {
  // Balanced defaults for browser VFS but compatible with Node-like resolution where necessary.
  return {
    target: ts.ScriptTarget.ES2022,
    module: ts.ModuleKind.ESNext,
    moduleResolution: ts.ModuleResolutionKind.Bundler,
    strict: true,
    allowImportingTsExtensions: true,
    allowArbitraryExtensions: true,
    resolvePackageJsonExports: true,
    resolvePackageJsonImports: true,
    skipLibCheck: true,
    useDefineForClassFields: true,
    noEmit: true,
  };
}

export function createEnvironment(
  compilerOptions = {},
  rootFiles = [],
  initialFiles = {}
) {
  if (!cachedDefaultMap) {
    throw new Error('VFS not initialized. Call ensureReady() first.');
  }

  const mapForEnv = mapClone(cachedDefaultMap);

  const normalizedInitialFiles = {};
  for (const [rawKey, content] of Object.entries(initialFiles || {})) {
    try {
      const key = normalizeVfsPath(rawKey);
      const data = String(content ?? '');
      normalizedInitialFiles[key] = data;
      mapForEnv.set(key, data);
      postLog(`createEnvironment: injected initial file: ${key}`);
    } catch (e) {
      postLog(
        `createEnvironment: failed to inject initial file ${rawKey}: ${String(
          e?.message ?? e
        )}`
      );
    }
  }

  const system = vfs.createSystem(mapForEnv);

  const rootPaths = (rootFiles || []).map((r) => normalizeVfsPath(r));

  const defaultOptions = getDefaultCompilerOptions();
  const opts = Object.assign({}, defaultOptions, compilerOptions);

  postLog(
    `createEnvironment: about to create env; roots: [${rootPaths.join(
      ', '
    )}], initialFiles: [${Object.keys(normalizedInitialFiles).join(
      ', '
    )}], opts: ${JSON.stringify(opts)}`
  );

  const env = vfs.createVirtualTypeScriptEnvironment(
    system,
    rootPaths,
    ts,
    opts
  );

  postLog(`VFS environment created; roots: [${rootPaths.join(', ')}]`);

  // Defensive: ensure env has the content
  for (const [path, content] of Object.entries(normalizedInitialFiles)) {
    try {
      if (env.getSourceFile && env.getSourceFile(path)) {
        env.updateFile(path, content);
      } else {
        env.createFile(path, content);
      }
    } catch (e) {
      postLog(
        `createEnvironment sync apply failed for ${path}: ${String(
          e?.message ?? e
        )}`
      );
    }
  }

  try {
    env.languageService.getProgram();
  } catch (e) {
    postLog(
      `getProgram() failed after env creation: ${String(e?.message ?? e)}`
    );
  }

  return env;
}

export function resetForTest() {
  cachedDefaultMap = null;
  vfsReady = false;
  _ensurePromise = null;
  postLog('VfsCore resetForTest() called');
}

export const VfsCore = {
  ensureReady,
  isReady: () => vfsReady,
  getDefaultMap,
  createEnvironment,
  getDefaultCompilerOptions,
  resetForTest,
};

```
```
1. ‚úÖ LSP initialize fails before ensureReady: Passed
2. ‚úÖ worker/ready does not imply VFS ready: Passed
3. ‚úÖ VFS API throws before ensureReady: Passed
4. ‚úÖ VFS ensureReady is idempotent: Passed
5. ‚úÖ VFS ensureReady initializes env: Passed
6. ‚úÖ LSP initialize succeeds after VFS ready: Passed
7. ‚úÖ VFS resetForTest resets all state: Passed
```

```
üöÄ main.js loaded
üß© vfs-ensureReady.test loaded
üß© vfs-ensureReady-idempotent.test loaded
üß© vfs-before-ensureReady.test loaded
üß© vfs-resetForTest.test loaded
üß© worker-ready-semantics.test loaded
üß© lsp-initialize-before-vfs.test loaded
üß© lsp-initialize-success.test loaded
üöÄ test-runner.js loaded
[22:29:45.995 | WorkerLog] [Worker] Worker loaded and ready.
[22:29:46.005 | WorkerLog] [Worker] Worker loaded and ready.
[22:29:46.008 | WorkerLog] [Worker] Worker loaded and ready.
[22:29:46.009 | WorkerLog] [Worker] VFS init attempt 1/3
[22:29:46.011 | WorkerLog] [Worker] Worker loaded and ready.
[22:29:46.012 | WorkerLog] [Worker] VFS init attempt 1/3
[22:29:46.015 | WorkerLog] [Worker] Worker loaded and ready.
[22:29:46.017 | WorkerLog] [Worker] VFS init attempt 1/3
[22:29:46.027 | WorkerLog] [Worker] Worker loaded and ready.
[22:29:46.656 | WorkerLog] [Worker] defaultMap size: 79
[22:29:47.205 | WorkerLog] [Worker] defaultMap size: 79
[22:29:47.781 | WorkerLog] [Worker] defaultMap size: 79
[22:29:47.809 | WorkerLog] [Worker] VFS init attempt 1/3
[22:29:48.365 | WorkerLog] [Worker] defaultMap size: 79
[22:29:48.922 | WorkerLog] [Worker] defaultMap size: 79
```

`vfs-ensureReady.test.js`  „ÅØ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´ÊîπÂ§âËøΩÂä†„Åó„Åü„ÄÇ

```
// test/v0.0.3/vfs-ensureReady.test.js
// v0.0.3.4

import { expect } from 'chai';
import {
  createTestWorker,
  waitForWorkerReady,
  sendRequest,
  addResult,
} from './test-utils.js';

console.log('üß© vfs-ensureReady.test loaded');

(async () => {
  const testName = 'VFS ensureReady initializes env';
  let worker;

  try {
    worker = createTestWorker('./js/worker.js');
    await waitForWorkerReady(worker);

    const result = await sendRequest(worker, 'vfs/ensureReady');

    expect(result.ok).to.equal(true);

    const info = await sendRequest(worker, 'vfs/getEnvInfo');
    expect(info.envId).to.be.a('number');
    expect(info.ready).to.equal(true);
    expect(info.hasEnv).to.equal(true);

    addResult(testName, true);
  } catch (err) {
    addResult(testName, false, err.message);
  } finally {
    worker?.terminate();
  }
})();

```


## „Éá„Ç£„É¨„ÇØ„Éà„É™ÊßãÊàê

```
.
‚îú‚îÄ‚îÄ core
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ error-codes.js
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ lsp-core.js
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ vfs-core.js
‚îú‚îÄ‚îÄ main.js
‚îú‚îÄ‚îÄ test
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test-runner.js
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ v0.0.3
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ lsp-initialize-before-vfs.test.js
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ lsp-initialize-success.test.js
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ test-utils.js
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ vfs-before-ensureReady.test.js
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ vfs-ensureReady-idempotent.test.js
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ vfs-ensureReady.test.js
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ vfs-resetForTest.test.js
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ worker-ready-semantics.test.js
‚îú‚îÄ‚îÄ util
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ async-utils.js
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ logger.js
‚îî‚îÄ‚îÄ worker.js

```

## „Ç≥„Éº„Éâ

```
// worker.js
// v0.0.3.4

import { VfsCore } from './core/vfs-core.js';
import { LspCore } from './core/lsp-core.js';
import { JsonRpcErrorCode } from './core/error-codes.js';
import { postLog, setDebug } from './util/logger.js';

// Enable debug by default for test runner visibility
setDebug(true);

const handlers = {
  // --- lifecycle ---
  'worker/ready': async () => ({ ok: true }),

  // --- vfs ---
  'vfs/ensureReady': async () => {
    await VfsCore.ensureReady();
    return { ok: true };
  },

  'vfs/getEnvInfo': async () => {
    return VfsCore.getEnvInfo();
  },
  'vfs/resetForTest': async () => {
    VfsCore.resetForTest();
    return { ok: true };
  },

  // --- lsp ---
  'lsp/initialize': async (params) => {
    return LspCore.initialize(params);
  },
};

self.onmessage = async (e) => {
  const msg = e.data;

  if (!msg || msg.jsonrpc !== '2.0') return;

  const { id, method, params } = msg;

  if (!handlers[method]) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: -32601, message: `Method not found: ${method}` },
      });
    }
    return;
  }

  try {
    const result = await handlers[method](params);

    if (id != null) {
      self.postMessage({ jsonrpc: '2.0', id, result });
    }
  } catch (err) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: -32000, message: err?.message ?? String(err) },
      });
    }
  }
};

// RPC Âèó‰ªòÈñãÂßãÈÄöÁü•
postLog('Worker loaded and ready.');
self.postMessage({ jsonrpc: '2.0', method: 'worker/ready' });

```

```
// core/vfs-core.js
// v0.0.3.4

//import * as vfs from 'https://esm.sh/@typescript/vfs';
import {
  createDefaultMapFromCDN,
  createSystem,
  createVirtualTypeScriptEnvironment,
} from 'https://esm.sh/@typescript/vfs';
import ts from 'https://esm.sh/typescript';
import { postLog } from '../util/logger.js';
import { sleep } from '../util/async-utils.js';

class VfsCoreClass {
  #env = null;
  #ready = false;
  #initializing = null;
  #envId = 0;

  // CDN „Åã„Çâ defaultMap „ÇíÂèñÂæó„Åô„ÇãÂÜÖÈÉ®„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£(„É™„Éà„É©„Ç§‰ªò„Åç)
  async #createDefaultMapWithRetry(retryCount = 3, perAttemptTimeoutMs = 5000) {
    let lastError = null;
    for (let attempt = 1; attempt <= retryCount; attempt++) {
      postLog(`VFS init attempt ${attempt}/${retryCount}`);
      try {
        const timeout = new Promise((_, reject) =>
          setTimeout(() => reject(new Error('timeout')), perAttemptTimeoutMs)
        );

        const defaultMap = await Promise.race([
          createDefaultMapFromCDN(
            {
              target: ts.ScriptTarget.ES2022,
              module: ts.ModuleKind.ESNext,
            },
            ts.version,
            false,
            ts
          ),
          timeout,
        ]);

        postLog(`defaultMap size: ${defaultMap.size}`);
        return defaultMap;
      } catch (error) {
        lastError = error;
        const msg = String(error?.message ?? error);
        if (msg.includes('fetch') || msg.includes('NetworkError')) {
          postLog(`Network error while fetching defaultMap: ${msg}`);
          throw error;
        }
        if (msg.includes('timeout')) {
          postLog(`Timeout on attempt ${attempt}, retrying after backoff`);
          await sleep(1000 * attempt);
          continue;
        }
        postLog(`createDefaultMapWithRetries unknown error: ${msg}`);
        throw error;
      }
    }
    throw lastError || new Error('VFS init failed after retries');
  }

  async ensureReady() {
    if (this.#ready) {
      return;
    }

    if (!this.#initializing) {
      this.#initializing = this.#init();
    }

    await this.#initializing;
  }

  async #init() {
    this.#envId++;

    const fsMap = await this.#createDefaultMapWithRetry();
    const system = createSystem(fsMap);
    this.#env = createVirtualTypeScriptEnvironment(system, [], ts, {
      target: ts.ScriptTarget.ESNext,
    });

    this.#ready = true;
  }

  getEnvInfo() {
    return {
      ready: this.#ready,
      hasEnv: this.#env !== null,
      tsVersion: ts.version,
      envId: this.#envId,
    };
  }

  resetForTest() {
    this.#env = null;
    this.#ready = false;
    this.#initializing = null;
    this.#envId = 0;
  }
}

export const VfsCore = new VfsCoreClass();

```

```
// core/lsp-core.js
// v0.0.3.4

import { VfsCore } from './vfs-core.js';
import { postLog } from '../util/logger.js';

class LspCoreClass {
  #initialized = false;

  constructor() {
    postLog('LspServer instance created');
  }

  async initialize(_params) {
    if (!VfsCore.getEnvInfo().ready) {
      throw new Error('VFS is not ready');
    }

    this.#initialized = true;

    return {
      capabilities: {},
    };
  }
}

export const LspCore = new LspCoreClass();

```
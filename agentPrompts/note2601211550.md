```
root/
  - moduleA
  - moduleB
  - dirA
    - main.py
```

```python
top_dir_name = 'root'

if not __loader__.path[:__loader__.path.rfind('/')].endswith(top_dir_name):
  import pathlib
  import sys

  __cwd = pathlib.Path.cwd()
  __depth_count = str(__cwd).count('/')
  __range = range(__depth_count)
  __top_path = next(
    (__dir
     for n in __range if (__dir := __cwd.parents[n]).name == top_dir_name),
    None)
  sys.path.append(str(__top_path))


import moduleA
```

`main.py` を実行して、`moduleA` をimport できるようにしてる。この方法が悪手なのは、理解してる。しかしこの方法（`sys.path.append` ）しかないので、採用している。

また、`for` と`if` の処理は、`main.py` がどんなに深い階層であっても取得できるようにしてる。



あなたに聞きたいことは、`moduleA` と`moduleB` のmodule と並列して`dirA`  （実行するためのコードがあるディレクトリ）を置くのは妥当か？
もしくは、`moduleA` と`moduleB` を`modules` みたいな名前のディレクトリに格納して、呼び出すようなディレクトリ構成にした方がいいのか？


意見を聞きたい。


for文の仕様は理解。module の件に戻る

- `sub.py` で実行もありうる
- 不必要なimport をしたくない
- Pythonista3 という特殊な実行環境だから、実行経路依存は気にしなくていい

と、考えて

```python
TOP_DIR_NAME = 'rubites'

if __name__ == '__main__' and not __file__[:__file__.rfind('/')].endswith(
    TOP_DIR_NAME):

  import pathlib
  import sys

  __current = pathlib.Path(__file__).resolve()
  __parents = __current.parents
  for n in range(len(__parents)):
    __parent = __parents[n]
    if __parent.name == TOP_DIR_NAME:
      sys.path.append(str(__parent))
      break
  else:
    raise RuntimeError(f'{TOP_DIR_NAME} not found in parent directories')


```

こうしたのだけど、どうかしら？



```python
if __name__ == '__main__':
    import sys
    from pathlib import Path

    TOP_DIR_NAME = 'rubites'

    current = Path(__file__).resolve()
    for parent in current.parents:
        if parent.name == TOP_DIR_NAME:
            sys.path.insert(0, str(parent))
            break
    else:
        raise RuntimeError(f'{TOP_DIR_NAME} not found in parent directories')
```

これだと、取得したいmodule が普通にimport できる時、無駄にpathlib とかimport することになるよな？



`import moduleA` ではなくて`from moduleA import hoge` で実際のコードを実装したい場合に対応できなくて困ってるのよ。


`import moduleA`  と、全部取得してしまう無駄が発生する。
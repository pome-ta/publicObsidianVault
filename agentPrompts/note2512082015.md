`âŒ VfsCore openFile: basic create test: vfs/openFile failed: VFS env not created
`

```
ğŸš€ main.js loaded
ğŸ§© vfs-openFile.test loaded
ğŸš€ test-runner.js loaded
[20:18:02.637 | WorkerLog] [Worker] Worker loaded and ready.
[20:18:02.650 | WorkerLog] [Worker] Debug mode set true
[20:18:02.652 | WorkerLog] [Worker] Received: vfs/resetForTest (id:1)
[20:18:02.652 | WorkerLog] [Worker] VfsCore resetForTest() called
[20:18:02.652 | WorkerLog] [Worker] Finished: vfs/resetForTest
[20:18:02.652 | WorkerLog] [Worker] Received: vfs/ensureReady (id:2)
[20:18:02.653 | WorkerLog] [Worker] VFS init attempt 1/3
[20:18:04.487 | WorkerLog] [Worker] defaultMap size: 79
[20:18:04.488 | WorkerLog] [Worker] VFS ensureReady complete
[20:18:04.488 | WorkerLog] [Worker] Finished: vfs/ensureReady
[20:18:04.489 | WorkerLog] [Worker] Received: vfs/openFile (id:3)
[20:18:04.490 | WorkerLog] [Worker] Error: vfs/openFile failed: VFS env not created

```


```vfs-core.js
// core/vfs-core.js
// v0.0.3.3

import * as vfs from 'https://esm.sh/@typescript/vfs';
import ts from 'https://esm.sh/typescript';
import { postLog } from '../util/logger.js';
import { sleep } from '../util/async-utils.js';

class VfsCoreClass {
  // private state
  #env = null;
  #cachedDefaultMap = null; // Map<string,string>
  #vfsReady = false;
  #ensurePromise = null;
  #nextEnvId = 0; // createEnvironment ã¦ã‚™ä»˜ä¸ã™ã‚‹ä¸€æ„ ID ã®ã‚«ã‚¦ãƒ³ã‚¿
  #lastEnv = null; // æœ€å¾Œã«ä½œæˆ(è¿”å´)ã—ãŸ env ã‚’ä¿æŒ(ãƒ†ã‚¹ãƒˆç”¨ã«å‚ç…§å¯èƒ½ã«ã™ã‚‹)
  #lastRootPaths = []; // lastEnv ã® rootPaths ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥(ãƒ†ã‚™ãƒã‚™ãƒƒã‚¯ã‚™/ãƒ†ã‚¹ãƒˆç”¨)

  // ãƒã‚šã‚¹æ­£è¦åŒ–(file:// ã‚’æ’é™¤ã—å…ˆé ­ / ã‚’ä»˜ä¸)
  #normalizeVfsPath(p) {
    if (!p) return '';
    let s = String(p).replace(/^file:\/\//, '');
    if (!s.startsWith('/')) s = `/${s}`;
    return s;
  }

  // Map ã®æµ…ã„ã‚¯ãƒ­ãƒ¼ãƒ³
  #mapClone(src) {
    return new Map(src);
  }

  // CDN ã‹ã‚‰ defaultMap ã‚’å–å¾—ã™ã‚‹å†…éƒ¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£(ãƒªãƒˆãƒ©ã‚¤ä»˜ã)
  async #createDefaultMapWithRetries(retryCount = 3, perAttemptTimeoutMs = 5000) {
    let lastError = null;
    for (let attempt = 1; attempt <= retryCount; attempt++) {
      postLog(`VFS init attempt ${attempt}/${retryCount}`);
      try {
        const timeout = new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), perAttemptTimeoutMs));

        const defaultMap = await Promise.race([
          vfs.createDefaultMapFromCDN(
            {
              target: ts.ScriptTarget.ES2022,
              module: ts.ModuleKind.ESNext,
            },
            ts.version,
            false,
            ts,
          ),
          timeout,
        ]);

        postLog(`defaultMap size: ${defaultMap.size}`);
        return defaultMap;
      } catch (error) {
        lastError = error;
        const msg = String(error?.message ?? error);
        if (msg.includes('fetch') || msg.includes('NetworkError')) {
          postLog(`Network error while fetching defaultMap: ${msg}`);
          throw error;
        }
        if (msg.includes('timeout')) {
          postLog(`Timeout on attempt ${attempt}, retrying after backoff`);
          await sleep(1000 * attempt);
          continue;
        }
        postLog(`createDefaultMapWithRetries unknown error: ${msg}`);
        throw error;
      }
    }
    throw lastError || new Error('VFS init failed after retries');
  }

  // public: defaultMap ã‹ã‚™æº–å‚™ã•ã‚Œã‚‹ã¾ã¦ã‚™å¾…ã¤(æ—¢å­˜ ensureReady ã¨äº’æ›)
  async ensureReady(retry = 3, timeoutMs = 5000) {
    if (this.#vfsReady && this.#cachedDefaultMap) {
      postLog('Using existing cachedDefaultMap (already ready)');
      return;
    }
    if (this.#ensurePromise) return this.#ensurePromise;

    this.#ensurePromise = (async () => {
      try {
        if (!this.#cachedDefaultMap) {
          this.#cachedDefaultMap = await this.#createDefaultMapWithRetries(retry, timeoutMs);
        } else {
          postLog('Using existing cachedDefaultMap (populate)');
        }
        this.#vfsReady = true;
        postLog('VFS ensureReady complete');
      } finally {
        this.#ensurePromise = null;
      }
    })();

    return this.#ensurePromise;
  }

  // public: ç¾åœ¨ã® defaultMap ã‚’è¿”ã™(ãƒ†ã‚¹ãƒˆã‚„å¤–éƒ¨å‚ç…§å‘ã‘)
  getDefaultMap() {
    return this.#cachedDefaultMap;
  }

  // public: ãƒ†ã‚™ãƒ•ã‚©ãƒ«ãƒˆã® compilerOptions
  getDefaultCompilerOptions() {
    return {
      target: ts.ScriptTarget.ES2022,
      module: ts.ModuleKind.ESNext,
      moduleResolution: ts.ModuleResolutionKind.Bundler,
      strict: true,
      allowImportingTsExtensions: true,
      allowArbitraryExtensions: true,
      resolvePackageJsonExports: true,
      resolvePackageJsonImports: true,
      skipLibCheck: true,
      useDefineForClassFields: true,
      noEmit: true,
    };
  }

  /**
   * public: VFS ç’°å¢ƒã‚’ä½œæˆã—ã¦è¿”ã™
   * - æ—¢å­˜ createEnvironment ã¨äº’æ›ã«ãªã‚‹ã‚ˆã†ã«è¨­è¨ˆ
   * - è¿”å´ã™ã‚‹ env ã«ä¸€æ„ã® __vfsId ã‚’ä»˜ä¸ã—ã¦ä¿æŒ(ãƒ†ã‚¹ãƒˆã¦ã‚™ env ã®åŒä¸€æ€§ã‚’æ¯”è¼ƒã¦ã‚™ãã‚‹ã‚ˆã†ã«ã™ã‚‹)
   */
  createEnvironment(compilerOptions = {}, rootFiles = [], initialFiles = {}) {
    if (!this.#cachedDefaultMap) {
      throw new Error('VFS not initialized. Call ensureReady() first.');
    }

    const mapForEnv = this.#mapClone(this.#cachedDefaultMap);

    const normalizedInitialFiles = {};
    for (const [rawKey, content] of Object.entries(initialFiles || {})) {
      try {
        const key = this.#normalizeVfsPath(rawKey);
        const data = String(content ?? '');
        normalizedInitialFiles[key] = data;
        mapForEnv.set(key, data);
        postLog(`createEnvironment: injected initial file: ${key}`);
      } catch (e) {
        postLog(`createEnvironment: failed to inject initial file ${rawKey}: ${String(e?.message ?? e)}`);
      }
    }

    const system = vfs.createSystem(mapForEnv);
    const rootPaths = (rootFiles || []).map((r) => this.#normalizeVfsPath(r));

    const defaultOptions = this.getDefaultCompilerOptions();
    const opts = Object.assign({}, defaultOptions, compilerOptions);

    postLog(
      `createEnvironment: about to create env; roots: [${rootPaths.join(', ')}], initialFiles: [${Object.keys(
        normalizedInitialFiles,
      ).join(', ')}], opts: ${JSON.stringify(opts)}`,
    );

    const env = vfs.createVirtualTypeScriptEnvironment(system, rootPaths, ts, opts);

    // env ã«ä¸€æ„ ID ã‚’ä»˜ä¸ã—ã¦ä¿æŒ(@typescript/vfs ã® env ã«ãƒ•ã‚£ãƒ¼ãƒ«ãƒˆã‚™ã‚’ä»˜ä¸)
    if (!env.__vfsId) {
      env.__vfsId = ++this.#nextEnvId;
    }
    this.#lastEnv = env;
    this.#lastRootPaths = rootPaths.slice();
    this.#env = env; // æ­£å¼ã«ä¿æŒ

    postLog(`VFS environment created; roots: [${rootPaths.join(', ')}] (envId=${env.__vfsId})`);

    // åŒæœŸçš„ã«åˆæœŸãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’åæ˜ (createFile/updateFile)
    for (const [path, content] of Object.entries(normalizedInitialFiles)) {
      try {
        if (env.getSourceFile && env.getSourceFile(path)) {
          env.updateFile(path, content);
        } else {
          env.createFile(path, content);
        }
      } catch (e) {
        postLog(`createEnvironment sync apply failed for ${path}: ${String(e?.message ?? e)}`);
      }
    }

    try {
      env.languageService.getProgram();
    } catch (e) {
      postLog(`getProgram() failed after env creation: ${String(e?.message ?? e)}`);
    }

    return env;
  }

  getEnv() {
    return this.#env;
  }

  openFile(path, content) {
    if (!this.#env) throw new Error('VFS env not created');
    const normalized = this.#normalizeVfsPath(path);
    if (this.#env.getSourceFile(normalized)) {
      this.#env.updateFile(normalized, content);
    } else {
      this.#env.createFile(normalized, content);
    }
    return { ok: true };
  }

  // public: ãƒ†ã‚¹ãƒˆç”¨ã«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
  resetForTest() {
    this.#cachedDefaultMap = null;
    this.#vfsReady = false;
    this.#ensurePromise = null;
    this.#nextEnvId = 0;
    this.#lastEnv = null;
    this.#lastRootPaths = [];
    postLog('VfsCore resetForTest() called');
  }

  // public: æº–å‚™æ¸ˆã¿ã‹ã¨ã‚™ã†ã‹
  isReady() {
    return !!(this.#vfsReady && this.#cachedDefaultMap);
  }

  // public: ãƒ†ã‚¹ãƒˆç”¨ã® env æƒ…å ±ã‚’è¿”ã™
  getEnvInfo() {
    return {
      envId: this.#lastEnv?.__vfsId ?? null,
      defaultMapSize: this.#cachedDefaultMap?.size ?? 0,
      lastRootPaths: this.#lastRootPaths.slice(),
    };
  }
}

// ã‚·ãƒ³ã‚¯ã‚™ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ã‚¨ã‚¯ã‚¹ãƒ›ã‚šãƒ¼ãƒˆ(æ—¢å­˜ã‚³ãƒ¼ãƒˆã‚™ã‹ã‚‰ã®äº’æ›ã®ãŸã‚)
export const VfsCore = new VfsCoreClass();

// æ—§ API äº’æ›: é–¢æ•°ã¨ã—ã¦ã‚‚å‘¼ã¸ã‚™ã‚‹ã‚ˆã†ã«ãƒã‚™ã‚¤ãƒ³ãƒˆã‚™ã—ã¦ãŠã
export const ensureReady = VfsCore.ensureReady.bind(VfsCore);
export const createEnvironment = VfsCore.createEnvironment.bind(VfsCore);
export const resetForTest = VfsCore.resetForTest.bind(VfsCore);
export const getDefaultMap = VfsCore.getDefaultMap.bind(VfsCore);
export const getDefaultCompilerOptions = VfsCore.getDefaultCompilerOptions.bind(VfsCore);
export const isReady = VfsCore.isReady.bind(VfsCore);
export const getEnvInfo = VfsCore.getEnvInfo.bind(VfsCore);
export const openFile = VfsCore.openFile.bind(VfsCore);

```


```worker.js
// worker.js
// v0.0.3.3

import { VfsCore } from './core/vfs-core.js';
import { LspCore } from './core/lsp-core.js';
import { JsonRpcErrorCode } from './core/error-codes.js';
import { postLog, setDebug } from './util/logger.js';

// Enable debug by default for test runner visibility
setDebug(true);

// handlers: "method" -> async function(params)
// - Requests (with id) return a result via JSON-RPC response
// - Notifications (no id) do not return a response
const handlers = {
  // VFS
  'vfs/ensureReady': async (params) => await VfsCore.ensureReady(),

  // ãƒ†ã‚¹ãƒˆå°‚ç”¨: VFS ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦å˜ä¸€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åˆæœŸçŠ¶æ…‹ã«æˆ»ã™
  'vfs/resetForTest': async () => {
    return VfsCore.resetForTest();
  },
  // ãƒ†ã‚¹ãƒˆå°‚ç”¨: ãƒ†ã‚¹ãƒˆå°‚ç”¨å†…éƒ¨æƒ…å ±ã®å–å¾—
  'vfs/_getEnvInfo': async () => {
    return VfsCore.getEnvInfo();
  },

  'vfs/openFile': async (params) => {
    const { path, content } = params;
    return VfsCore.openFile(path, content);
  },

  // LSP lifecycle / utility
  'lsp/ping': async () => 'pong',
  'lsp/shutdown': async () => {
    postLog('Worker shutting down...');
    setTimeout(() => self.close(), 100);
    return 'shutdown-complete';
  },
  'lsp/initialize': async (params) => await LspCore.initialize(params),

  // Document sync (VFS required)
  'textDocument/didOpen': async (params) => await LspCore.didOpen(params),
  'textDocument/didChange': async (params) => await LspCore.didChange(params),
  'textDocument/didClose': async (params) => await LspCore.didClose(params),
};

// ============================================================
// JSON-RPC Message Processing
// ============================================================

/**
 * Handle incoming JSON-RPC message object.
 * Validates JSON-RPC 2.0 structure, VFS precondition for LSP methods, and dispatches to handlers.
 *
 * @param {object} msg JSON-RPC message
 */
async function handleJsonRpcMessage(msg) {
  const { jsonrpc, id, method, params } = msg || {};

  if (jsonrpc !== '2.0' || typeof method !== 'string') {
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: {
          code: JsonRpcErrorCode.InvalidRequest,
          message: 'Invalid JSON-RPC 2.0 payload',
        },
      });
    }
    return;
  }

  postLog(`Received: ${method} (id:${id ?? '-'})`);

  // Methods that assume VFS / LSP presence:
  // - textDocument/* always requires VFS
  // - lsp/* except initialize/ping/shutdown require VFS
  const requiresVfs =
    method.startsWith('textDocument/') ||
    (method.startsWith('lsp/') && !['lsp/initialize', 'lsp/ping', 'lsp/shutdown'].includes(method));

  if (requiresVfs && !VfsCore.isReady()) {
    const message = 'VFS not ready. Call `vfs/ensureReady` first.';
    postLog(`Error: ${message}`);
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: JsonRpcErrorCode.ServerNotInitialized, message },
      });
    }
    return;
  }

  const handler = handlers[method];
  if (!handler) {
    const message = `Unknown method: ${method}`;
    postLog(`Error: ${message}`);
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: JsonRpcErrorCode.MethodNotFound, message },
      });
    }
    return;
  }

  try {
    const result = await handler(params);
    postLog(`Finished: ${method}`);
    if (id) {
      // JSON-RPC response for requests
      self.postMessage({
        jsonrpc: '2.0',
        id,
        result: result !== undefined ? result : null,
      });
    }
    // For notifications (no id) - no response sent
  } catch (err) {
    const message = `${method} failed: ${err?.message ?? String(err)}`;
    postLog(`Error: ${message}`);
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: JsonRpcErrorCode.ServerError, message },
      });
    }
  }
}

// Message event listener
self.addEventListener('message', async (event) => {
  const { data } = event;

  // Toggle debug mode via simple string messages 'debug:on' | 'debug:off'
  if (typeof data === 'string' && data.startsWith('debug:')) {
    const enabled = data === 'debug:on';
    setDebug(enabled);
    postLog(`Debug mode set ${enabled}`);
    return;
  }

  // JSON-RPC
  if (data?.jsonrpc === '2.0') {
    await handleJsonRpcMessage(data);
    return;
  }

  // Unknown non-jsonrpc message: keep for backwards compatibility
  postLog(`Received unknown message format: ${JSON.stringify(data)}`);
});

// Announce ready
postLog('Worker loaded and ready.');
self.postMessage({ jsonrpc: '2.0', method: 'worker/ready' });

```
# 共有

現在のv0.0.2.14 をv0.0.2.x 系の最後として、
次からv0.0.3.x へ移行し、v0.0.3.0 とします。

つまり、v0.0.2.系 進行中のincremental 実装は一時中断です。

今後の進め方については、後述する「`# v0.0.3.0`」にて、説明します。

v0.0.2.14 の状態は以下

## v0.0.2.14

### ディレクトリツリー

```
.
├── core
│   ├── error-codes.js
│   ├── lsp-core.js
│   └── vfs-core.js
├── test
│   ├── test-runner.js
│   └── v0.0.2
│       ├── test-utils.js
│       ├── worker-diagnostics-flatten.test.js
│       ├── worker-didChange-basic.test.js
│       ├── worker-didChange-incremental-min.test.js
│       ├── worker-lsp-diagnostics.test.js
│       ├── worker-lsp-initialize.test.js
│       ├── worker-lsp-multi-file.test.js
│       ├── worker-ready.test.js
│       ├── worker-vfs-cached-init.test.js
│       ├── worker-vfs-file.test.js
│       └── worker-vfs-init.test.js
├── util
│   ├── async-utils.js
│   └── logger.js
└── worker.js
```

### コード

#### `core/`


#### `core/error-codes.js`

```error-codes.js
// core/error-codes.js

/**
 * JSON-RPC 2.0 and LSP standard error codes.
 * @see https://www.jsonrpc.org/specification#error_object
 * @see https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#errorCodes
 */
export const JsonRpcErrorCode = {
  // JSON-RPC 2.0 Pre-defined errors
  ParseError: -32700,
  InvalidRequest: -32600,
  MethodNotFound: -32601,
  InvalidParams: -32602,
  InternalError: -32603,

  // A generic server error for implementation-defined server-errors (-32000 to -32099)
  ServerError: -32000,
  // LSP specific error codes
  // @see https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#errorCodes
  ServerNotInitialized: -32002,
  UnknownErrorCode: -32001,
};

```

#### `core/lsp-core.js`

incremental 実装前に戻しています。

```lsp-core.js
// core/lsp-core.js
// v0.0.2.14

import ts from 'https://esm.sh/typescript';
import { VfsCore } from './vfs-core.js';
import { postLog } from '../util/logger.js';

class LspServer {
  #env = null;
  #openFiles = new Map();
  #compilerOptions = {};

  constructor() {
    postLog('LspServer instance created');
  }

  /**
   * Minimal compiler options merge: take defaults and shallow-merge incoming.
   * Avoid heavy sanitization here; keep small and predictable.
   */
  #mergeCompilerOptions(incoming = {}) {
    const defaults = VfsCore.getDefaultCompilerOptions
      ? VfsCore.getDefaultCompilerOptions()
      : {
          target: ts.ScriptTarget.ES2022,
          module: ts.ModuleKind.ESNext,
          moduleResolution: ts.ModuleResolutionKind.Bundler,
          strict: true,
        };
    return Object.assign({}, defaults, incoming || {});
  }

  async initialize(params = {}) {
    const incoming = params.initializationOptions?.compilerOptions || {};
    this.#compilerOptions = this.#mergeCompilerOptions(incoming);

    postLog(`LSP initialize (opts): ${JSON.stringify(this.#compilerOptions)}`);

    await VfsCore.ensureReady();

    // Create empty environment (no root files yet)
    this.#env = VfsCore.createEnvironment(this.#compilerOptions, [], {});
    postLog('LspServer initialized, env created.');
  }

  getInitializeResult() {
    return {
      capabilities: {
        textDocumentSync: 1,
      },
      serverInfo: {
        name: 'WebWorker-LSP-Server',
        version: '0.0.2',
      },
    };
  }

  async didOpen(params) {
    const { uri, text, version } = params.textDocument;
    const path = this.#uriToPath(uri);
    postLog(`didOpen ${path} (version:${version})`);

    this.#openFiles.set(uri, { text, version });
    await this.#recreateEnv();
    // publish immediately (no debounce)
    await this.publishDiagnostics(uri);
  }

  async didChange(params) {
    const { uri, version } = params.textDocument;
    const changes = params.contentChanges || [];
    const text = changes.length ? changes[changes.length - 1].text : undefined;
    if (typeof text !== 'string') {
      postLog(`didChange received but no text for ${uri}`);
      return;
    }
    const path = this.#uriToPath(uri);
    postLog(`didChange ${path} (version:${version})`);

    this.#openFiles.set(uri, { text, version });
    await this.#recreateEnv();
    await this.publishDiagnostics(uri);
  }

  async didClose(params) {
    const { uri } = params.textDocument;
    const path = this.#uriToPath(uri);
    postLog(`didClose ${path}`);

    this.#openFiles.delete(uri);
    await this.#recreateEnv();
    // clear diagnostics immediately
    this.#clearDiagnostics(uri);
  }

  /**
   * Recreate the VFS environment from currently open files.
   * Simplified: no retry loop, assume VfsCore.createEnvironment is robust.
   */
  async #recreateEnv() {
    const rootFiles = [];
    const initialFiles = {};
    for (const [uri, { text }] of this.#openFiles.entries()) {
      let path = this.#uriToPath(uri);
      if (!path.startsWith('/')) path = `/${path}`;
      rootFiles.push(path);
      initialFiles[path] = text;
    }

    try {
      this.#env = VfsCore.createEnvironment(
        this.#compilerOptions,
        rootFiles,
        initialFiles
      );

      // Ensure content applied
      for (const [path, content] of Object.entries(initialFiles)) {
        try {
          if (this.#env.getSourceFile && this.#env.getSourceFile(path)) {
            this.#env.updateFile(path, content);
          } else {
            this.#env.createFile(path, content);
          }
        } catch (e) {
          postLog(
            `recreateEnv sync failed for ${path}: ${e?.message ?? String(e)}`
          );
        }
      }

      // Try to prime the program; if it fails, we still continue (logs)
      try {
        this.#env.languageService.getProgram();
      } catch (e) {
        postLog(
          `getProgram() during recreateEnv failed: ${e?.message ?? String(e)}`
        );
      }

      postLog(`recreateEnv done; roots: [${rootFiles.join(', ')}]`);
    } catch (e) {
      postLog(`recreateEnv failed: ${e?.message ?? String(e)}`);
      throw e;
    }
  }

  /**
   * Map TS Diagnostic -> LSP Diagnostic (standards-aligned).
   * - message uses ts.flattenDiagnosticMessageText
   * - relatedInformation mapped only when file+start available
   */
  #mapTsDiagnosticToLsp(diag, path, program) {
    const start = typeof diag.start === 'number' ? diag.start : 0;
    const length = typeof diag.length === 'number' ? diag.length : 0;

    let sourceFile = null;
    try {
      sourceFile = program?.getSourceFile(path) ?? null;
    } catch (e) {
      sourceFile = null;
    }

    const startPos =
      sourceFile && typeof start === 'number'
        ? ts.getLineAndCharacterOfPosition(sourceFile, start)
        : { line: 0, character: 0 };

    const endPos =
      sourceFile && typeof start === 'number' && typeof length === 'number'
        ? ts.getLineAndCharacterOfPosition(sourceFile, start + length)
        : { line: startPos.line, character: startPos.character };

    const message = ts.flattenDiagnosticMessageText(diag.messageText, '\n');

    // Severity mapping: TS -> LSP
    let severity = 1; // default Error
    if (typeof diag.category === 'number') {
      switch (diag.category) {
        case ts.DiagnosticCategory.Error:
          severity = 1;
          break;
        case ts.DiagnosticCategory.Warning:
          severity = 2;
          break;
        case ts.DiagnosticCategory.Suggestion:
          severity = 3;
          break;
        case ts.DiagnosticCategory.Message:
        default:
          severity = 3;
          break;
      }
    }

    const lsp = {
      range: { start: startPos, end: endPos },
      message,
      severity,
      source: 'ts',
      code: diag.code,
    };

    // Map relatedInformation -> LSP relatedInformation when location available
    try {
      if (
        Array.isArray(diag.relatedInformation) &&
        diag.relatedInformation.length > 0
      ) {
        const riList = [];
        for (const ri of diag.relatedInformation) {
          try {
            let riUri = null;
            let riRange = {
              start: { line: 0, character: 0 },
              end: { line: 0, character: 0 },
            };

            if (
              ri?.file &&
              typeof ri.file === 'object' &&
              typeof ri.file.fileName === 'string'
            ) {
              riUri = `file://${
                ri.file.fileName.startsWith('/')
                  ? ri.file.fileName
                  : ri.file.fileName
              }`;
              if (typeof ri.start === 'number') {
                const pos = ts.getLineAndCharacterOfPosition(ri.file, ri.start);
                riRange = {
                  start: {
                    line: pos.line,
                    character: pos.character,
                  },
                  end: {
                    line: pos.line,
                    character: pos.character,
                  },
                };
              }
            } else if (ri?.file && typeof ri.file === 'string') {
              riUri = `file://${ri.file.startsWith('/') ? ri.file : ri.file}`;
              // cannot compute line/char without SourceFile
            }

            const riMsg = ts.flattenDiagnosticMessageText(ri.messageText, '\n');

            if (riUri) {
              riList.push({
                location: { uri: riUri, range: riRange },
                message: riMsg,
              });
            }
          } catch (e) {
            postLog(`map relatedInformation error: ${String(e?.message ?? e)}`);
            // continue with other relatedInformation
          }
        }

        if (riList.length > 0) {
          lsp.relatedInformation = riList;
        }
      }
    } catch (e) {
      postLog(`relatedInformation mapping failed: ${String(e?.message ?? e)}`);
    }

    return lsp;
  }

  /**
   * Publish diagnostics for a given uri (immediate, no debounce).
   */
  async publishDiagnostics(uri) {
    if (!this.#env) {
      postLog('publishDiagnostics called but env is not initialized');
      return;
    }
    const path = this.#uriToPath(uri);

    let program;
    try {
      program = this.#env.languageService.getProgram();
    } catch (e) {
      postLog(
        `getProgram() failed before diagnostics: ${e?.message ?? String(e)}`
      );
    }

    const syntactic =
      this.#env.languageService.getSyntacticDiagnostics(path) || [];
    const semantic =
      this.#env.languageService.getSemanticDiagnostics(path) || [];
    const all = [...syntactic, ...semantic];

    if (all.length > 0) {
      postLog(`Diagnostics detail for ${path}:`);
      for (const d of all) {
        try {
          const msg = ts.flattenDiagnosticMessageText(d.messageText, '\n');
          postLog(
            `  - code:${d.code} start:${d.start ?? '-'} len:${
              d.length ?? '-'
            } msg:${msg}`
          );
        } catch (e) {
          postLog(`  - (failed to stringify diag) ${String(e?.message ?? e)}`);
        }
      }
    }

    const diagnostics = all.map((d) =>
      this.#mapTsDiagnosticToLsp(d, path, program)
    );

    postLog(`Publishing ${diagnostics.length} diagnostics for ${path}`);
    self.postMessage({
      jsonrpc: '2.0',
      method: 'textDocument/publishDiagnostics',
      params: { uri, diagnostics },
    });
  }

  #clearDiagnostics(uri) {
    self.postMessage({
      jsonrpc: '2.0',
      method: 'textDocument/publishDiagnostics',
      params: { uri, diagnostics: [] },
    });
  }

  #uriToPath(uri) {
    if (!uri) {
      return '';
    }
    let path = String(uri).replace(/^file:\/\//, '');
    if (!path.startsWith('/')) {
      path = `/${path}`;
    }
    return path;
  }
}

let server = null;
async function getServer() {
  if (!server) {
    server = new LspServer();
  }

  return server;
}

export const LspCore = {
  initialize: async (params = {}) => {
    postLog(`LSP initialize params: ${JSON.stringify(params)}`);
    const s = await getServer();
    await s.initialize(params);
    return s.getInitializeResult();
  },

  didOpen: async (params) => {
    const s = await getServer();
    await s.didOpen(params);
  },

  didChange: async (params) => {
    const s = await getServer();
    await s.didChange(params);
  },

  didClose: async (params) => {
    const s = await getServer();
    await s.didClose(params);
  },

  publishDiagnostics: async (uri) => {
    const s = await getServer();
    await s.publishDiagnostics(uri);
  },
};

```

#### `core/vfs-core.js`

```vfs-core.js
// core/vfs-core.js
// v0.0.2.14
// - Based on v0.0.2.7 with small robustifying touches
// - Exports getDefaultCompilerOptions, createEnvironment, ensureReady, resetForTest
// - Normalizes paths to leading '/' form, injects initialFiles into cloned default map

import * as vfs from 'https://esm.sh/@typescript/vfs';
import ts from 'https://esm.sh/typescript';
import { postLog } from '../util/logger.js';
import { sleep } from '../util/async-utils.js';

let cachedDefaultMap = null;
let vfsReady = false;
let _ensurePromise = null;

function normalizeVfsPath(p) {
  if (!p) return '';
  let s = String(p).replace(/^file:\/\//, '');
  if (!s.startsWith('/')) s = `/${s}`;
  return s;
}

function mapClone(src) {
  return new Map(src);
}

async function createDefaultMapWithRetries(
  retryCount = 3,
  perAttemptTimeoutMs = 5000
) {
  let lastError = null;
  for (let attempt = 1; attempt <= retryCount; attempt++) {
    postLog(`VFS init attempt ${attempt}/${retryCount}`);
    try {
      const timeout = new Promise((_, reject) =>
        setTimeout(() => reject(new Error('timeout')), perAttemptTimeoutMs)
      );

      const defaultMap = await Promise.race([
        vfs.createDefaultMapFromCDN(
          {
            target: ts.ScriptTarget.ES2022,
            module: ts.ModuleKind.ESNext,
          },
          ts.version,
          false,
          ts
        ),
        timeout,
      ]);

      postLog(`defaultMap size: ${defaultMap.size}`);
      return defaultMap;
    } catch (error) {
      lastError = error;
      const msg = String(error?.message ?? error);
      if (msg.includes('fetch') || msg.includes('NetworkError')) {
        postLog(`Network error while fetching defaultMap: ${msg}`);
        throw error;
      }
      if (msg.includes('timeout')) {
        postLog(`Timeout on attempt ${attempt}, retrying after backoff`);
        await sleep(1000 * attempt);
        continue;
      }
      postLog(`createDefaultMapWithRetries unknown error: ${msg}`);
      throw error;
    }
  }

  throw lastError || new Error('VFS init failed after retries');
}

export async function ensureReady(retry = 3, timeoutMs = 5000) {
  if (vfsReady && cachedDefaultMap) {
    postLog('Using existing cachedDefaultMap (already ready)');
    return;
  }
  if (_ensurePromise) return _ensurePromise;

  _ensurePromise = (async () => {
    try {
      if (!cachedDefaultMap) {
        cachedDefaultMap = await createDefaultMapWithRetries(retry, timeoutMs);
      } else {
        postLog('Using existing cachedDefaultMap (populate)');
      }
      vfsReady = true;
      postLog('VFS ensureReady complete');
    } finally {
      _ensurePromise = null;
    }
  })();

  return _ensurePromise;
}

export function getDefaultMap() {
  return cachedDefaultMap;
}

export function getDefaultCompilerOptions() {
  // Balanced defaults for browser VFS but compatible with Node-like resolution where necessary.
  return {
    target: ts.ScriptTarget.ES2022,
    module: ts.ModuleKind.ESNext,
    moduleResolution: ts.ModuleResolutionKind.Bundler,
    strict: true,
    allowImportingTsExtensions: true,
    allowArbitraryExtensions: true,
    resolvePackageJsonExports: true,
    resolvePackageJsonImports: true,
    skipLibCheck: true,
    useDefineForClassFields: true,
    noEmit: true,
  };
}

export function createEnvironment(
  compilerOptions = {},
  rootFiles = [],
  initialFiles = {}
) {
  if (!cachedDefaultMap) {
    throw new Error('VFS not initialized. Call ensureReady() first.');
  }

  const mapForEnv = mapClone(cachedDefaultMap);

  const normalizedInitialFiles = {};
  for (const [rawKey, content] of Object.entries(initialFiles || {})) {
    try {
      const key = normalizeVfsPath(rawKey);
      const data = String(content ?? '');
      normalizedInitialFiles[key] = data;
      mapForEnv.set(key, data);
      postLog(`createEnvironment: injected initial file: ${key}`);
    } catch (e) {
      postLog(
        `createEnvironment: failed to inject initial file ${rawKey}: ${String(
          e?.message ?? e
        )}`
      );
    }
  }

  const system = vfs.createSystem(mapForEnv);

  const rootPaths = (rootFiles || []).map((r) => normalizeVfsPath(r));

  const defaultOptions = getDefaultCompilerOptions();
  const opts = Object.assign({}, defaultOptions, compilerOptions);

  postLog(
    `createEnvironment: about to create env; roots: [${rootPaths.join(
      ', '
    )}], initialFiles: [${Object.keys(normalizedInitialFiles).join(
      ', '
    )}], opts: ${JSON.stringify(opts)}`
  );

  const env = vfs.createVirtualTypeScriptEnvironment(
    system,
    rootPaths,
    ts,
    opts
  );

  postLog(`VFS environment created; roots: [${rootPaths.join(', ')}]`);

  // Defensive: ensure env has the content
  for (const [path, content] of Object.entries(normalizedInitialFiles)) {
    try {
      if (env.getSourceFile && env.getSourceFile(path)) {
        env.updateFile(path, content);
      } else {
        env.createFile(path, content);
      }
    } catch (e) {
      postLog(
        `createEnvironment sync apply failed for ${path}: ${String(
          e?.message ?? e
        )}`
      );
    }
  }

  try {
    env.languageService.getProgram();
  } catch (e) {
    postLog(
      `getProgram() failed after env creation: ${String(e?.message ?? e)}`
    );
  }

  return env;
}

export function resetForTest() {
  cachedDefaultMap = null;
  vfsReady = false;
  _ensurePromise = null;
  postLog('VfsCore resetForTest() called');
}

export const VfsCore = {
  ensureReady,
  isReady: () => vfsReady,
  getDefaultMap,
  createEnvironment,
  getDefaultCompilerOptions,
  resetForTest,
};

```

### `test/`

#### `test/v0.0.2/test-utils.js`

```test-utils.js
// test/v0.0.2/test-utils.js
// v0.0.2

let requestId = 0;

/**
 * Workerを生成し、ログメッセージをコンソールに出力するリスナーをセットアップします。
 * @param {string} path - Workerスクリプトのパス
 * @returns {Worker}
 */
export const createTestWorker = (path, onLog) => {
  const worker = new Worker(path, { type: 'module' });

  worker.addEventListener('message', (event) => {
    const data = event.data || {};
    if (data?.method === 'worker/log' && data.params?.message) {
      const formatted = `[${
        data.params.timestamp ?? new Date().toISOString()
      } | WorkerLog] ${data.params.message}`;
      console.log(formatted);
      onLog?.(formatted);
    }
  });

  // テスト環境では、デフォルトでデバッグログを有効にする
  worker.postMessage('debug:on');

  return worker;
};

/**
 * Workerが 'worker/ready' 通知を送信するまで待機します。
 * @param {Worker} worker
 * @param {number} timeout
 * @returns {Promise<void>}
 */
export const waitForWorkerReady = (worker, timeout = 5000) => {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(
      () => reject(new Error(`Worker ready timeout (${timeout}ms)`)),
      timeout
    );

    const handler = (event) => {
      if (event.data?.method === 'worker/ready') {
        clearTimeout(timer);
        worker.removeEventListener('message', handler);
        resolve();
      }
    };

    worker.addEventListener('message', handler);
  });
};

/**
 * WorkerにJSON-RPCリクエストを送信し、対応するレスポンスを待ちます。
 * @param {Worker} worker
 * @param {string} method
 * @param {object} params
 * @param {number} timeout
 * @returns {Promise<any>}
 */
export const sendRequest = (worker, method, params = {}, timeout = 30000) => {
  const id = ++requestId;
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      worker.removeEventListener('message', handler);
      reject(new Error(`Request timeout for method: ${method} (${timeout}ms)`));
    }, timeout);

    const handler = (event) => {
      const response = event.data;
      if (response?.id === id) {
        clearTimeout(timer);
        worker.removeEventListener('message', handler);
        if (response.error) {
          reject(
            new Error(response.error.message || JSON.stringify(response.error))
          );
        } else {
          resolve(response.result);
        }
      }
    };

    worker.addEventListener('message', handler);
    worker.postMessage({ jsonrpc: '2.0', id, method, params });
  });
};

/**
 * WorkerにJSON-RPC通知を送信します。レスポンスは待ちません。
 * @param {Worker} worker
 * @param {string} method
 * @param {object} params
 */
export const sendNotification = (worker, method, params = {}) => {
  worker.postMessage({ jsonrpc: '2.0', method, params });
};

/**
 * Workerから特定のメソッドの通知が送信されるのを待ちます。
 * @param {Worker} worker
 * @param {string} expectedMethod - 待機する通知のメソッド名
 * @param {(params: any) => boolean} [paramsMatcher] - 通知のparamsが期待通りか判定する関数
 * @param {number} timeout
 * @returns {Promise<any>} 通知の `params` オブジェクト
 */
export const waitForNotification = (
  worker,
  expectedMethod,
  paramsMatcher = () => true, // デフォルトでは常にtrueを返す
  timeout = 5000
) => {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(
      () =>
        reject(
          new Error(
            `Timeout waiting for notification: ${expectedMethod} (${timeout}ms)`
          )
        ),
      timeout
    );

    const handler = (event) => {
      const notification = event.data;
      if (
        notification?.method === expectedMethod &&
        paramsMatcher(notification.params)
      ) {
        clearTimeout(timer);
        worker.removeEventListener('message', handler);
        resolve(notification.params);
      }
    };

    worker.addEventListener('message', handler);
  });
};

/**
 * テスト結果をHTMLリストに表示します。
 * @param {string} name - テスト名
 * @param {boolean} passed - 合否
 * @param {string} [details=''] - 詳細メッセージ
 */
export const addResult = (name, passed, details = '') => {
  const resultsList = document.getElementById('testOrdered');
  if (!resultsList) return;

  const li = document.createElement('li');
  const status = passed ? '✅' : '❌';
  const message = passed ? details || 'Passed' : details;
  li.textContent = `${status} ${name}: ${message}`;
  li.style.color = passed ? 'green' : 'red';
  resultsList.appendChild(li);
};

```

### `worker.js`


```worker.js
// worker.js
// v0.0.2.14

import { VfsCore } from './core/vfs-core.js';
import { LspCore } from './core/lsp-core.js';
import { JsonRpcErrorCode } from './core/error-codes.js';
import { postLog, setDebug } from './util/logger.js';

// Enable debug by default for test runner visibility
setDebug(true);

// handlers: "method" -> async function(params)
// - Requests (with id) return a result via JSON-RPC response
// - Notifications (no id) do not return a response
const handlers = {
  // VFS
  'vfs/ensureReady': async (params) => await VfsCore.ensureReady(),

  // LSP lifecycle / utility
  'lsp/ping': async () => 'pong',
  'lsp/shutdown': async () => {
    postLog('Worker shutting down...');
    setTimeout(() => self.close(), 100);
    return 'shutdown-complete';
  },
  'lsp/initialize': async (params) => await LspCore.initialize(params),

  // Document sync (VFS required)
  'textDocument/didOpen': async (params) => await LspCore.didOpen(params),
  'textDocument/didChange': async (params) => await LspCore.didChange(params),
  'textDocument/didClose': async (params) => await LspCore.didClose(params),
};

// ============================================================
// JSON-RPC Message Processing
// ============================================================

/**
 * Handle incoming JSON-RPC message object.
 * Validates JSON-RPC 2.0 structure, VFS precondition for LSP methods, and dispatches to handlers.
 *
 * @param {object} msg JSON-RPC message
 */
async function handleJsonRpcMessage(msg) {
  const { jsonrpc, id, method, params } = msg || {};

  if (jsonrpc !== '2.0' || typeof method !== 'string') {
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: {
          code: JsonRpcErrorCode.InvalidRequest,
          message: 'Invalid JSON-RPC 2.0 payload',
        },
      });
    }
    return;
  }

  postLog(`Received: ${method} (id:${id ?? '-'})`);

  // Methods that assume VFS / LSP presence:
  // - textDocument/* always requires VFS
  // - lsp/* except initialize/ping/shutdown require VFS
  const requiresVfs =
    method.startsWith('textDocument/') ||
    (method.startsWith('lsp/') && !['lsp/initialize', 'lsp/ping', 'lsp/shutdown'].includes(method));

  if (requiresVfs && !VfsCore.isReady()) {
    const message = 'VFS not ready. Call `vfs/ensureReady` first.';
    postLog(`Error: ${message}`);
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: JsonRpcErrorCode.ServerNotInitialized, message },
      });
    }
    return;
  }

  const handler = handlers[method];
  if (!handler) {
    const message = `Unknown method: ${method}`;
    postLog(`Error: ${message}`);
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: JsonRpcErrorCode.MethodNotFound, message },
      });
    }
    return;
  }

  try {
    const result = await handler(params);
    postLog(`Finished: ${method}`);
    if (id) {
      // JSON-RPC response for requests
      self.postMessage({
        jsonrpc: '2.0',
        id,
        result: result !== undefined ? result : null,
      });
    }
    // For notifications (no id) - no response sent
  } catch (err) {
    const message = `${method} failed: ${err?.message ?? String(err)}`;
    postLog(`Error: ${message}`);
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: JsonRpcErrorCode.ServerError, message },
      });
    }
  }
}

// Message event listener
self.addEventListener('message', async (event) => {
  const { data } = event;

  // Toggle debug mode via simple string messages 'debug:on' | 'debug:off'
  if (typeof data === 'string' && data.startsWith('debug:')) {
    const enabled = data === 'debug:on';
    setDebug(enabled);
    postLog(`Debug mode set ${enabled}`);
    return;
  }

  // JSON-RPC
  if (data?.jsonrpc === '2.0') {
    await handleJsonRpcMessage(data);
    return;
  }

  // Unknown non-jsonrpc message: keep for backwards compatibility
  postLog(`Received unknown message format: ${JSON.stringify(data)}`);
});

// Announce ready
postLog('Worker loaded and ready.');
self.postMessage({ jsonrpc: '2.0', method: 'worker/ready' });

```



# v0.0.3.0 へ

まず、v0.0.2.14 をそのままの状態で、v0.0.3.0 とする。
そして、ロードマップは今回のv0.0.3.x を差し込む形で全体をインクリメントする感じ。

コードを覚えておいてね。以前は実装コードのモジュールを考慮してなかったからね。

## 方針

- `core/vfs-core.js` を複数 env から、常駐構造
- （`core/vfs-core.js` のclass 化？）
- incremental 対応
- 以前あなたが、提示した順序

```以前あなたが、提示した順序
v0.0.2.13  didChange-basic（full replace） ← 終わった

→ v0.0.2.14  didChange incremental（差分仕様の最小ケース）
→ v0.0.2.15  didChange incremental（複数変更）
→ v0.0.2.16  didChange incremental（行ごとの差分）
```


をやっていく。

その先で、

> 1〜5 はすべて CodeMirror 連携前に完全に実施できる／すべき領域。
> 一方で 6〜8（completion / hover / definition）は、CodeMirror 連携前に実装は可能だが、統合テストは連携後の方が合理的。

としていた、

```
2. didClose の追加
	•	シンプルな LSP 基本動作
	•	CodeMirror 連携とは独立（CodeMirror は didClose を送ってくるだけ）
	•	VFS からファイル削除するだけの処理

→ 完全に前倒し可能

⸻

3. import 解決の複雑化テストの追加
	•	worker 単体で test 可能
	•	CodeMirror は関与しない
	•	VFS の基礎能力テストなので CodeMirror 導入前に固めるべき

→ 完全に前倒し可能

⸻

4. openedFiles の管理（ファイル一覧の一元管理）
	•	LSP サーバー側の内部状態管理
	•	CodeMirror と完全に独立
	•	LSP コアとして必須の仕組み
	•	CodeMirror 連携後に修正すると破壊的になる可能性があるため、前にやるべき

→ 必ず連携前に実施すべき

⸻

5. 依存ファイル更新 → 別ファイル診断の伝搬テスト

例：
	•	types.ts 変更で main.ts のエラーが変化するか

これは CodeMirror と無関係で、
TS LanguageService と VFS の整合性が正しく動いているかの本質的テスト。

→ 完全に前倒し可能

⸻

CodeMirror 連携前に実装はできるが、最終テストは連携後

6. completion
	•	技術的には worker 単体で実装可能
	•	ただし final integration test（CodeMirror の UI 表示動作確認）は連携後に必要

結論：
	•	実装は可能（連携前）
	•	最終ユーザー確認は連携後

⸻

7. hover
	•	同上
	•	LSP API の textDocument/hover を worker 単体で実装できる
	•	UI 動作（ポップアップ）の確認は連携後

⸻

8. go-to-definition / references
	•	同上
	•	実装は CodeMirror 不要
	•	UI 連携のテスト（ジャンプ動作）は CodeMirror 導入後が合理的

```


この流れでいく。


# 確認

私が考えた方針はどうだろうか？

マクロからミクロの流れで、意見が欲しい。
確認したいことも併せて出して。

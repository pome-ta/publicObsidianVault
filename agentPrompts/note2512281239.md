# æ•´ç†

ã‚ãªãŸãŒã€ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’é€šã™ãŸã‚ã®ã‚³ãƒ¼ãƒ‰ä¿®æ­£ã«ãªã£ã¦ã„ã‚‹ã®ã§ã€æ”¹ã‚ã¦æ•´ç†ãŒã—ãŸã„ã€‚


## å„ªå…ˆé †ä½

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’é”æˆã™ã‚‹ãŸã‚ã®å„ªå…ˆé †ä½ã‚’æ”¹ã‚ã¦æ•´ç†ã™ã‚‹

1. è¨­è¨ˆæ–¹é‡ã«æº–æ‹ ã—ãŸå …å®Ÿå …ç‰¢ã§ã€å®Ÿé‹ç”¨ã«è€ãˆã‚‹ä¸€èˆ¬çš„ãªè§£æ±ºç­–ã®å®Ÿè£…
2. ç‹¬è‡ªã‚³ãƒ¼ãƒ‰ãƒ»ç‹¬è‡ªåŸºæº–ã§ã¯ãªãã€å¤–éƒ¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®API ã‚’æœ€å¤§é™æ´»ç”¨ã—ãŸå®Ÿè£…
3. å®Ÿè£…ã‚’é€²ã‚ã‚‹ã«ã‚ãŸã‚Šå¿…è¦ãªãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰
4. å®Ÿè£…ã«æº–æ‹ ã—ãŸã€ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®ä¿®æ­£
5. å®Ÿè¡Œæ™‚ã®ã‚¨ãƒ©ãƒ¼ã‚’å¯¾å¿œã™ã‚‹ãŸã‚ã®ã‚³ãƒ¼ãƒ‰ä¿®æ­£


## ç¾åœ¨ã®Phase

Phase ã¯ã€Phase10ã¨ãªã£ã¦ã„ã‚‹ã€‚

```
åŸºç›¤å±¤ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 Phase 1â€“3  : RPC / VFS / initialize
 Phase 4â€“6  : document lifecycle
 Phase 7    : incremental sync / diagnostics

æ©Ÿèƒ½å±¤ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 Phase 8    : completion / hoverï¼ˆçµŒè·¯ï¼‰
 Phase 9    : completion / hoverï¼ˆå®Ÿä½“ï¼‰
 ```

ã“ã®ã‚ˆã†ãªé€²æ—ã®ã¯ãšã€‚é–“é•ã„ãŒã‚ã‚Œã°ã€æç¤ºã—ã¦ã»ã—ã„ã€‚

## ç¾åœ¨ã®ã‚³ãƒ¼ãƒ‰

å®Ÿè¡Œã‚¨ãƒ©ãƒ¼ã¨ãªã£ã¦ã„ã‚‹ãŒã€ç¾çŠ¶ã®ã‚³ãƒ¼ãƒ‰ã‚’å…±æœ‰ã™ã‚‹ã€‚

### ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª

```
.
â”œâ”€â”€ core
â”‚Â Â  â”œâ”€â”€ error-codes.js
â”‚Â Â  â”œâ”€â”€ lsp-core.js
â”‚Â Â  â”œâ”€â”€ text-document-manager.js
â”‚Â Â  â””â”€â”€ vfs-core.js
â”œâ”€â”€ main.js
â”œâ”€â”€ test
â”‚Â Â  â”œâ”€â”€ test-runner.js
â”‚Â Â  â”œâ”€â”€ v0.0.3
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ test-utils.js
â”‚Â Â  â”‚Â Â  â””â”€â”€ phase9-completion-hover.test.js
â”‚Â Â  â””â”€â”€ v0.0.4
â”‚Â Â      â”œâ”€â”€ phase10-completion-hover-tscompiler.test.js
â”‚Â Â      â”œâ”€â”€ phase10-completion-hover-tsls.test.js
â”‚Â Â      â””â”€â”€ test-utils.js
â”œâ”€â”€ util
â”‚Â Â  â”œâ”€â”€ async-utils.js
â”‚Â Â  â””â”€â”€ logger.js
â””â”€â”€ worker.js


```

### ã‚³ãƒ¼ãƒ‰

#### `worker.js`

```worker.js
// worker.js
// v0.0.4.2 Phase 10: VfsCore + TextDocumentManager + TS Language Service

import * as ts from 'https://esm.sh/typescript';
import { VfsCore } from './core/vfs-core.js';
import { TextDocumentManager } from './core/text-document-manager.js';
import { postLog } from './util/logger.js';

/* --------------------------------------------------
 * core instances
 * -------------------------------------------------- */

const vfsCore = VfsCore; // æ—¢å­˜è¨­è¨ˆ: ã‚·ãƒ³ã‚¯ã‚™ãƒ«ãƒˆãƒ³
const textDocuments = new TextDocumentManager(vfsCore);

let initialized = false;
let languageService = null;

/* --------------------------------------------------
 * Language Service bootstrap
 * -------------------------------------------------- */

function ensureLanguageService() {
  if (languageService) return languageService;

  // VfsCore ã®ãƒ©ãƒƒãƒã‚šãƒ¼ API ã«å§”è­²
  const env = vfsCore.getLanguageService();
  languageService = env;

  return languageService;
}

/* --------------------------------------------------
 * handlers
 * -------------------------------------------------- */

const handlers = {
  /* ---------- lifecycle ---------- */

  'worker/ready': async () => ({ ok: true }),
  /* ---------- VFS ---------- */

  'vfs/ensureReady': async () => {
    await vfsCore.ensureReady();
    return { ok: true };
  },

  'lsp/initialize': async (params) => {
    await vfsCore.ensureReady();
    ensureLanguageService();
    initialized = true;

    return {
      capabilities: {},
    };
  },

  /* ---------- TextDocument lifecycle (LSP â†’ å†…éƒ¨APIã¸ãƒãƒƒãƒ’ã‚šãƒ³ã‚¯ã‚™) ---------- */

  'textDocument/didOpen': async (params) => {
    const { textDocument } = params;

    await textDocuments.open({
      uri: textDocument.uri,
      text: textDocument.text,
      languageId: textDocument.languageId,
      version: textDocument.version,
    });

    ensureLanguageService();
    return { ok: true };
  },

  'textDocument/didChange': async (params) => {
    const { textDocument, contentChanges } = params;

    if (!contentChanges?.length) {
      throw new Error('didChange with no contentChanges');
    }

    // Phase10: full text æ›´æ–°ã®ã¿å¯¾å¿œ
    const newText = contentChanges[0].text;

    await textDocuments.change({
      uri: textDocument.uri,
      text: newText,
      version: textDocument.version,
    });

    return { ok: true };
  },

  'textDocument/didClose': async (params) => {
    const { textDocument } = params;

    await textDocuments.close({
      uri: textDocument.uri,
    });

    return { ok: true };
  },

  /* ---------- completion ---------- */

  'textDocument/completion': async ({ textDocument, position }) => {
    if (!initialized) return { isIncomplete: false, items: [] };

    const uri = textDocument?.uri;
    const doc = textDocuments.get(uri);
    if (!doc) return { isIncomplete: false, items: [] };

    const fileName = uri.replace(/^file:\/\//, '');

    // ä»®: UTF-16 å¤‰æ›çœç•¥ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—
    const offset =
      doc.text.split('\n').slice(0, position.line).join('\n').length +
      position.character;

    const ls = ensureLanguageService();

    const entries =
      ls.getCompletionsAtPosition(fileName, offset, {})?.entries ?? [];

    return {
      isIncomplete: false,
      items: entries.slice(0, 40).map((e) => ({
        label: e.name,
        kind: 6,
        detail: e.kind,
      })),
    };
  },

  /* ---------- hover ---------- */

  'textDocument/hover': async ({ textDocument, position }) => {
    if (!initialized) return null;

    const uri = textDocument?.uri;
    const doc = textDocuments.get(uri);
    if (!doc) return null;

    const fileName = uri.replace(/^file:\/\//, '');

    const offset =
      doc.text.split('\n').slice(0, position.line).join('\n').length +
      position.character;

    const ls = ensureLanguageService();

    const info = ls.getQuickInfoAtPosition(fileName, offset);
    if (!info) {
      return {
        contents: {
          kind: 'plaintext',
          value: 'unknown',
        },
      };
    }

    const display = ts.displayPartsToString(info.displayParts ?? []);
    const documentation = ts.displayPartsToString(info.documentation ?? []);

    return {
      contents: {
        kind: 'plaintext',
        value:
          documentation && documentation.trim().length > 0
            ? `${display}\n\n${documentation}`
            : display,
      },
    };
  },
};

/* --------------------------------------------------
 * JSON-RPC loop
 * -------------------------------------------------- */

self.onmessage = async (e) => {
  const msg = e.data;
  if (!msg || msg.jsonrpc !== '2.0') return;

  const { id, method, params } = msg;
  const handler = handlers[method];

  if (!handler) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: -32601, message: `Method not found: ${method}` },
      });
    }
    return;
  }

  try {
    const result = await handler(params);
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        result,
      });
    }
  } catch (err) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: {
          code: -32000,
          message: err?.message ?? String(err),
        },
      });
    }
  }
};

/* --------------------------------------------------
 * ready notify
 * -------------------------------------------------- */

postLog('Worker loaded and ready.');
self.postMessage({ jsonrpc: '2.0', method: 'worker/ready' });

```


#### `core/`


##### `core/vfs-core.js`

```vfs-core.js
// core/vfs-core.js
// v0.0.4.2 Phase 10 æ±ºå®šç‰ˆ: å¼·ã„ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ç®¡ç† + é–‰ä¸–ç•ŒVFS + TS Language Service

import {
  createDefaultMapFromCDN,
  createSystem,
  createVirtualTypeScriptEnvironment,
} from 'https://esm.sh/@typescript/vfs';

import ts from 'https://esm.sh/typescript';
import { sleep } from '../util/async-utils.js';
import { postLog } from '../util/logger.js';

class VfsCoreClass {
  //
  // ---------- private state ----------
  //
  #env = null; // VirtualTypeScriptEnvironment
  #system = null; // VFS System
  #fsMap = null; // Map<string,string>
  #initializing = null; // Promise | null
  #ready = false; // boolean
  #disposed = false; // boolean
  #envId = 0; // monotonic counter

  //
  // ---------- public lifecycle ----------
  //

  /**
   * å†å…¥å¯èƒ½ãƒ»å¤šé‡ await å®‰å…¨
   * ãŸãŸã‚™ã—å†…éƒ¨åˆæœŸåŒ–ã¯ 1 å›ã®ã¿
   */
  async ensureReady() {
    this.#assertNotDisposed();

    if (this.#ready) return;

    if (!this.#initializing) {
      this.#initializing = this.#init();
    }

    await this.#initializing;
  }

  /**
   * å®Œå…¨å»ƒæ£„
   * ä»¥é™ã®åˆ©ç”¨ã¯ç¦æ­¢
   */
  dispose() {
    if (this.#disposed) return;

    try {
      // ãƒ†ã‚¹ãƒˆç”¨ reset æ‰‹ç¶šãã‚‚å†åˆ©ç”¨
      this.resetForTest();
    } finally {
      this.#env = null;
      this.#system = null;
      this.#fsMap = null;
      this.#disposed = true;
    }

    postLog('VfsCore disposed');
  }

  /**
   * ãƒ†ã‚¹ãƒˆç”¨ãƒªã‚»ãƒƒãƒˆ
   * dispose ã¨ç•°ãªã‚Šå†åˆ©ç”¨å‰æ
   */
  resetForTest() {
    this.#assertNotDisposed();

    this.#env = null;
    this.#system = null;
    this.#fsMap = null;
    this.#initializing = null;
    this.#ready = false;
    this.#envId = 0;

    postLog('VfsCore resetForTest executed');
  }

  /**
   * ãƒ†ã‚™ãƒã‚™ãƒƒã‚¯ã‚™/ç›£è¦–ç”¨
   */
  getEnvInfo() {
    return {
      ready: this.#ready,
      disposed: this.#disposed,
      hasEnv: this.#env !== null,
      envId: this.#envId,
      tsVersion: ts.version,
      fsSize: this.#fsMap?.size ?? 0,
    };
  }

  //
  // ---------- public VFS / Doc API ----------
  //

  readFile(uri) {
    this.#assertReady();
    return this.#fsMap.get(uri) ?? null;
  }

  writeFile(uri, text) {
    this.#assertReady();

    this.#fsMap.set(uri, text);
    this.#system.writeFile(uri, text);

    // TS language service ã¸åæ˜ (å¿…é ˆ)
    this.#env.updateFile(uri, text);
  }

  /**
   * Language Service ã®æä¾›
   * Phase 10 ã®ä¸­æ ¸
   */
  getLanguageService() {
    this.#assertReady();
    return this.#env.languageService;
  }

  //
  // ---------- internal init ----------
  //

  async #init() {
    this.#envId++;
    postLog(`VfsCore init start (env #${this.#envId})`);

    // 1. lib files from CDN (retry + timeout)
    this.#fsMap = await this.#createDefaultMapWithRetry();

    // 2. virtual system
    this.#system = createSystem(this.#fsMap);

    // 3. environment + language service
    this.#env = createVirtualTypeScriptEnvironment(this.#system, [], ts, {
      target: ts.ScriptTarget.ES2022,
      module: ts.ModuleKind.ESNext,
      strict: true,
      skipLibCheck: true,
      noEmit: true,
      allowImportingTsExtensions: true,
      allowArbitraryExtensions: true,
      resolvePackageJsonExports: false,
      resolvePackageJsonImports: false,
    });

    this.#ready = true;
    postLog(`VfsCore init complete (env #${this.#envId})`);
  }

  //
  // ---------- CDN lib fetch with retry ----------
  //

  async #createDefaultMapWithRetry(retryCount = 3, perAttemptTimeoutMs = 8000) {
    let lastError = null;

    for (let attempt = 1; attempt <= retryCount; attempt++) {
      postLog(`VFS lib fetch attempt ${attempt}/${retryCount}`);

      try {
        const result = await Promise.race([
          createDefaultMapFromCDN(
            {
              target: ts.ScriptTarget.ES2022,
              module: ts.ModuleKind.ESNext,
            },
            ts.version,
            false,
            ts
          ),
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error('timeout')), perAttemptTimeoutMs)
          ),
        ]);

        postLog(`VFS lib fetch success size=${result.size}`);
        return result;
      } catch (err) {
        lastError = err;
        const msg = String(err?.message ?? err);

        // hard-fail on network-level errors
        if (msg.includes('NetworkError')) {
          postLog('VFS lib fetch network error â†’ abort');
          throw err;
        }

        // timed out â†’ retry with backoff
        if (msg.includes('timeout')) {
          postLog('VFS lib fetch timeout â†’ retry with backoff');
          await sleep(1000 * attempt);
          continue;
        }

        // unexpected error
        postLog('VFS lib fetch unexpected error â†’ abort');
        throw err;
      }
    }

    throw lastError || new Error('VFS default map initialization failed');
  }

  //
  // ---------- guards ----------
  //

  #assertNotDisposed() {
    if (this.#disposed) {
      throw new Error('VfsCore is already disposed');
    }
  }

  #assertReady() {
    this.#assertNotDisposed();

    if (!this.#ready || !this.#env) {
      throw new Error('VfsCore is not initialized. Call ensureReady() first.');
    }
  }
}

export const VfsCore = new VfsCoreClass();

```


##### `core/text-document-manager.js`

```text-document-manager.js
// core/text-document-manager.js
// v0.0.4.2

export class TextDocumentManager {
  constructor(vfsCore) {
    if (!vfsCore) {
      throw new Error("TextDocumentManager requires VfsCore instance");
    }
    this.vfs = vfsCore;
    this.opened = new Map(); // uri -> version(optional)
  }

  async open(uri, content) {
    await this.vfs.writeFile(uri, content);
    this.opened.set(uri, { version: 1 });
  }

  async change(uri, newContent) {
    if (!this.opened.has(uri)) {
      throw new Error(`Document not opened: ${uri}`);
    }

    await this.vfs.writeFile(uri, newContent);

    const entry = this.opened.get(uri);
    entry.version += 1;
  }

  async close(uri) {
    this.opened.delete(uri);

    // VFS ã‹ã‚‰ã‚‚å‰Šé™¤ã™ã‚‹ã‹ã¯ãƒ›ã‚šãƒªã‚·ãƒ¼æ¬¡ç¬¬
    // ã“ã“ã¦ã‚™ã¯å®‰å…¨å´ã«å€’ã—ã€Œå‰Šé™¤ã¯ã—ãªã„ã€
    // LSP ã¦ã‚™ã‚‚ close = untrack ã‹ã‚™åŸå‰‡ã¦ã‚™ delete ã¦ã‚™ã¯ãªã„
  }

  async getContent(uri) {
    return await this.vfs.readFile(uri);
  }

  has(uri) {
    return this.opened.has(uri);
  }
}

```

##### `core/lsp-core.js`

```lsp-core.js
// core/lsp-core.js
// v0.0.3.4

import { VfsCore } from './vfs-core.js';
import { postLog } from '../util/logger.js';

class LspCoreClass {
  #initialized = false;

  constructor() {
    postLog('LspServer instance created');
  }

  async initialize(_params) {
    if (!VfsCore.getEnvInfo().ready) {
      throw new Error('VFS is not ready');
    }

    this.#initialized = true;

    return {
      capabilities: {},
    };
  }
}

export const LspCore = new LspCoreClass();

```


#### `test/`

##### `test-runner.js`


```test-runner.js
// test/test-runner.js
// v0.0.4.ç³»

console.log('ğŸš€ test-runner.js loaded');


// v0.0.3.10
import './v0.0.3/phase9-completion-hover.test.js';

// v0.0.4.1
//import './v0.0.4/phase10-completion-hover-tsls.test.js';
import './v0.0.4/phase10-completion-hover-tscompiler.test.js';


```

##### `test-utils.js`

v0.0.3.ç³» ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨v0.0.4.ç³»ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ãã‚Œãã‚Œå…¥ã£ã¦ã„ã‚‹

```
// test/v0.0.4/test-utils.js
// v0.0.4

let requestId = 0;

/**
 * Workerã‚’ç”Ÿæˆã—ã€ãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›ã™ã‚‹ãƒªã‚¹ãƒŠãƒ¼ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã—ã¾ã™ã€‚
 * @param {string} path - Workerã‚¹ã‚¯ãƒªãƒ—ãƒˆã®ãƒ‘ã‚¹
 * @returns {Worker}
 */
export const createTestWorker = (path, onLog) => {
  const worker = new Worker(path, { type: 'module' });

  worker.addEventListener('message', (event) => {
    const data = event.data || {};
    if (data?.method === 'worker/log' && data.params?.message) {
      const formatted = `[${data.params.timestamp ?? new Date().toISOString()} | WorkerLog] ${data.params.message}`;
      console.log(formatted);
      onLog?.(formatted);
    }
  });

  // ãƒ†ã‚¹ãƒˆç’°å¢ƒã§ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã‚’æœ‰åŠ¹ã«ã™ã‚‹
  worker.postMessage('debug:on');

  return worker;
};

/**
 * WorkerãŒ 'worker/ready' é€šçŸ¥ã‚’é€ä¿¡ã™ã‚‹ã¾ã§å¾…æ©Ÿã—ã¾ã™ã€‚
 * @param {Worker} worker
 * @param {number} timeout
 * @returns {Promise<void>}
 */
export const waitForWorkerReady = (worker, timeout = 5000) => {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => reject(new Error(`Worker ready timeout (${timeout}ms)`)), timeout);

    const handler = (event) => {
      if (event.data?.method === 'worker/ready') {
        clearTimeout(timer);
        worker.removeEventListener('message', handler);
        resolve();
      }
    };

    worker.addEventListener('message', handler);
  });
};

/**
 * Workerã«JSON-RPCãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã—ã€å¯¾å¿œã™ã‚‹ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å¾…ã¡ã¾ã™ã€‚
 * @param {Worker} worker
 * @param {string} method
 * @param {object} params
 * @param {number} timeout
 * @returns {Promise<any>}
 */
export const sendRequest = (worker, method, params = {}, timeout = 30000) => {
  const id = ++requestId;
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      worker.removeEventListener('message', handler);
      reject(new Error(`Request timeout for method: ${method} (${timeout}ms)`));
    }, timeout);

    const handler = (event) => {
      const response = event.data;
      if (response?.id === id) {
        clearTimeout(timer);
        worker.removeEventListener('message', handler);
        if (response.error) {
          const err = new Error(response.error.message || JSON.stringify(response.error));
          err.code = response.error.code;
          reject(err);
        } else {
          resolve(response.result);
        }
      }
    };

    worker.addEventListener('message', handler);
    worker.postMessage({ jsonrpc: '2.0', id, method, params });
  });
};

/**
 * Workerã«JSON-RPCé€šçŸ¥ã‚’é€ä¿¡ã—ã¾ã™ã€‚ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã¯å¾…ã¡ã¾ã›ã‚“ã€‚
 * @param {Worker} worker
 * @param {string} method
 * @param {object} params
 */
export const sendNotification = (worker, method, params = {}) => {
  worker.postMessage({ jsonrpc: '2.0', method, params });
};

/**
 * Workerã‹ã‚‰ç‰¹å®šã®ãƒ¡ã‚½ãƒƒãƒ‰ã®é€šçŸ¥ãŒé€ä¿¡ã•ã‚Œã‚‹ã®ã‚’å¾…ã¡ã¾ã™ã€‚
 * @param {Worker} worker
 * @param {string} expectedMethod - å¾…æ©Ÿã™ã‚‹é€šçŸ¥ã®ãƒ¡ã‚½ãƒƒãƒ‰å
 * @param {(params: any) => boolean} [paramsMatcher] - é€šçŸ¥ã®paramsãŒæœŸå¾…é€šã‚Šã‹åˆ¤å®šã™ã‚‹é–¢æ•°
 * @param {number} timeout
 * @returns {Promise<any>} é€šçŸ¥ã® `params` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 */
export const waitForNotification = (
  worker,
  expectedMethod,
  paramsMatcher = () => true, // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯å¸¸ã«trueã‚’è¿”ã™
  timeout = 5000,
) => {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(
      () => reject(new Error(`Timeout waiting for notification: ${expectedMethod} (${timeout}ms)`)),
      timeout,
    );

    const handler = (event) => {
      const notification = event.data;
      if (notification?.method === expectedMethod && paramsMatcher(notification.params)) {
        clearTimeout(timer);
        worker.removeEventListener('message', handler);
        resolve(notification.params);
      }
    };

    worker.addEventListener('message', handler);
  });
};

/**
 * ãƒ†ã‚¹ãƒˆçµæœã‚’HTMLãƒªã‚¹ãƒˆã«è¡¨ç¤ºã—ã¾ã™ã€‚
 * @param {string} name - ãƒ†ã‚¹ãƒˆå
 * @param {boolean} passed - åˆå¦
 * @param {string} [details=''] - è©³ç´°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
 */
export const addResult = (name, passed, details = '') => {
  const resultsList = document.getElementById('testOrdered');
  if (!resultsList) return;

  const li = document.createElement('li');
  const status = passed ? 'âœ…' : 'âŒ';
  const message = passed ? details || 'Passed' : details;
  li.textContent = `${status} ${name}: ${message}`;
  li.style.color = passed ? 'green' : 'red';
  resultsList.appendChild(li);
};

```


##### `phase9-completion-hover.test.js`

```phase9-completion-hover.test.js
// test/v0.0.3/phase9-completion-hover.test.js
// v0.0.3.10 (fixed)

import {
  createTestWorker,
  waitForWorkerReady,
  sendRequest,
  sendNotification,
  addResult,
} from './test-utils.js';

console.log('ğŸ§© phase9-completion-hover.test loaded');

(async () => {
  const testName = 'phase9: completion / hover returns concrete content';
  let worker;

  try {
    /* ---------- worker boot ---------- */

    worker = createTestWorker('./js/worker.js');
    await waitForWorkerReady(worker);

    /* ---------- VFS ready (å¿…é ˆ) ---------- */

    const ready = await sendRequest(worker, 'vfs/ensureReady');
    if (!ready?.ok) {
      throw new Error('vfs/ensureReady failed');
    }

    /* ---------- initialize ---------- */

    await sendRequest(worker, 'lsp/initialize', {
      processId: null,
      rootUri: null,
      capabilities: {},
    });

    sendNotification(worker, 'lsp/initialized');

    /* ---------- open document ---------- */

    const uri = 'file:///phase9.ts';
    const content = 'const answer = 42;\nanswer';

    await sendRequest(worker, 'vfs/openFile', {
      uri,
      content,
    });

    /* ---------- completion ---------- */

    const completion = await sendRequest(worker, 'textDocument/completion', {
      textDocument: { uri },
      position: { line: 1, character: 3 },
    });

    if (
      !completion ||
      !Array.isArray(completion.items) ||
      completion.items.length === 0
    ) {
      throw new Error('completion.items is empty');
    }

    if (typeof completion.items[0].label !== 'string') {
      throw new Error('completion item has no label');
    }

    /* ---------- hover ---------- */

    const hover = await sendRequest(worker, 'textDocument/hover', {
      textDocument: { uri },
      position: { line: 0, character: 6 },
    });

    if (!hover || !hover.contents || typeof hover.contents.value !== 'string') {
      throw new Error('hover.contents invalid');
    }

    addResult(testName, true);
  } catch (err) {
    addResult(testName, false, err.message);
  } finally {
    worker?.terminate();
  }
})();

```

##### `phase10-completion-hover-tscompiler.test.js`

```phase10-completion-hover-tscompiler.test.js
// test/v0.0.3/phase10-completion-hover-tscompiler.test.js
// v0.0.4.1

import {
  createTestWorker,
  waitForWorkerReady,
  sendRequest,
  sendNotification,
  addResult,
} from './test-utils.js';

console.log('ğŸ§© phase10-completion-hover-tscompiler.test loaded');

(async () => {
  const testName =
    'phase10: completion / hover returns TS Compiler API based result';
  let worker;

  try {
    /* ---------- worker boot ---------- */

    worker = createTestWorker('./js/worker.js');
    await waitForWorkerReady(worker);

    /* ---------- VFS ready ---------- */

    const ready = await sendRequest(worker, 'vfs/ensureReady');
    if (!ready?.ok) {
      throw new Error('vfs/ensureReady failed');
    }

    /* ---------- initialize ---------- */

    await sendRequest(worker, 'lsp/initialize', {
      processId: null,
      rootUri: null,
      capabilities: {},
    });

    sendNotification(worker, 'lsp/initialized');

    /* ---------- open document ---------- */

    const uri = 'file:///phase10.ts';
    const content = `
const num = 123;
num.
`;

    await sendRequest(worker, 'vfs/openFile', {
      uri,
      content,
    });

    /* ---------- completion ---------- */

    const completion = await sendRequest(worker, 'textDocument/completion', {
      textDocument: { uri },
      position: { line: 2, character: 4 },
    });

    if (
      !completion ||
      !Array.isArray(completion.items) ||
      completion.items.length === 0
    ) {
      throw new Error('completion.items empty');
    }

    if (typeof completion.items[0].label !== 'string') {
      throw new Error('completion label invalid');
    }

    /* ---------- hover ---------- */

    const hover = await sendRequest(worker, 'textDocument/hover', {
      textDocument: { uri },
      position: { line: 1, character: 6 },
    });

    if (
      !hover ||
      !hover.contents ||
      typeof hover.contents.value !== 'string'
    ) {
      throw new Error('hover.contents invalid');
    }

    // Compiler API ãƒ™ãƒ¼ã‚¹ã§ã‚ã‚‹ã“ã¨ã®æœ€ä½ä¿è¨¼
    if (!hover.contents.value.includes('number')) {
      throw new Error('hover does not include type info');
    }

    addResult(testName, true);
  } catch (err) {
    addResult(testName, false, err.message);
  } finally {
    worker?.terminate();
  }
})();
```


# ä»Šå¾Œã®å®Ÿè£…ã®é€²ã‚æ–¹

- ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ä»¥å¤–ã®ã‚³ãƒ¼ãƒ‰ã‚’ä»Šå›ã®æ–¹é‡ã®é€šã‚Šã«æ•´å‚™
- ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®å†…å®¹ãŒé–“é•ãˆã§ã‚ã‚Œã°ã€ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’ä¿®æ­£

ï¼ˆä¾‹ã§ã™ãŒï¼‰ä»¥å‰ã®`worker.js` ã‚³ãƒ¼ãƒ‰ã¯ã“ã‚“ãªæ„Ÿã˜ã§ã—ãŸã€‚ã”å‚è€ƒã¾ã§ã«

```worker.js
// worker.js
// v0.0.3.8 Phase 7 clean
//
// å¯¾å¿œç¯„å›²:
// - didOpen / didChange / didClose lifecycle
// - incremental sync (range + text / full text fallback)
// - diagnostics æœ€å°é€šçŸ¥
// - ãƒ†ã‚¹ãƒˆå°‚ç”¨ debug API
//
// éå¯¾å¿œï¼ˆæ„å›³çš„ï¼‰:
// - completion / hover å®Ÿä½“
// - semantic tokens
// - diagnostics å†…å®¹ç”Ÿæˆ

import { VfsCore } from './core/vfs-core.js';
import { LspCore } from './core/lsp-core.js';
import { postLog, setDebug } from './util/logger.js';

setDebug(true);

/* =========================
 * å†…éƒ¨ document state
 * ========================= */

const documents = new Map();
/*
documents.get(uri) = {
  uri,
  version,
  text,
  opened: boolean
}
*/

let initialized = false;

/* =========================
 * debug observation
 * ========================= */

let lastDidOpen = null;
let lastDidChange = null;
let lastDidClose = null;
let lastDiagnostics = null;

/* =========================
 * utility
 * ========================= */

function applyIncrementalChange(text, change) {
  if (!change.range) {
    return change.text;
  }

  const lines = text.split('\n');

  const { start, end } = change.range;

  const before = lines[start.line].slice(0, start.character);

  const after = lines[end.line].slice(end.character);

  lines.splice(
    start.line,
    end.line - start.line + 1,
    `${before}${change.text}${after}`
  );

  return lines.join('\n');
}

function emitDiagnostics(uri) {
  lastDiagnostics = {
    uri,
    diagnostics: [],
  };
}

/* =========================
 * handlers
 * ========================= */

const handlers = {
  // --- lifecycle ---
  'worker/ready': async () => ({ ok: true }),

  // --- vfs ---
  'vfs/ensureReady': async () => {
    await VfsCore.ensureReady();
    return { ok: true };
  },

  'vfs/getEnvInfo': async () => {
    return VfsCore.getEnvInfo();
  },

  'vfs/resetForTest': async () => {
    VfsCore.resetForTest();
    documents.clear();
    initialized = false;
    lastDidOpen = null;
    lastDidChange = null;
    lastDidClose = null;
    lastDiagnostics = null;
    return { ok: true };
  },

  'vfs/openFile': async (params) => {
    if (
      !params ||
      typeof params.uri !== 'string' ||
      typeof params.content !== 'string'
    ) {
      throw Object.assign(new Error('Invalid params'), {
        code: -32602,
      });
    }

    if (!VfsCore.getEnvInfo().ready) {
      throw Object.assign(new Error('VFS not ready'), {
        code: -32001,
      });
    }

    let doc = documents.get(params.uri);

    if (!doc) {
      doc = {
        uri: params.uri,
        version: 0,
        text: '',
        opened: false,
      };
      documents.set(params.uri, doc);
    }

    doc.text = params.content;
    doc.version += 1;
    doc.opened = true;

    return { ok: true };
  },

  // --- lsp ---
  'lsp/initialize': async (params) => {
    const result = await LspCore.initialize(params);
    initialized = true;

    for (const doc of documents.values()) {
      if (!doc.opened) continue;

      lastDidOpen = {
        uri: doc.uri,
        version: doc.version,
        text: doc.text,
      };

      emitDiagnostics(doc.uri);
    }

    return result;
  },

  'textDocument/didChange': async (params) => {
    if (!initialized) {
      return null;
    }

    const { textDocument, contentChanges } = params;
    const doc = documents.get(textDocument.uri);

    if (!doc || !doc.opened) {
      return null;
    }

    let text = doc.text;

    for (const change of contentChanges) {
      text = applyIncrementalChange(text, change);
    }

    doc.text = text;
    doc.version += 1;

    lastDidChange = {
      uri: doc.uri,
      version: doc.version,
      text: doc.text,
    };

    emitDiagnostics(doc.uri);

    return null;
  },

  'textDocument/didClose': async (params) => {
    if (!initialized) return null;

    const uri = params.textDocument.uri;
    const doc = documents.get(uri);

    if (!doc) return null;

    doc.opened = false;

    lastDidClose = { uri };

    return null;
  },

  // --- hover stub ---
  'textDocument/hover': async () => {
    return null;
  },

  // --- debug ---
  'lsp/_debug/getLastDidOpen': async () => lastDidOpen,
  'lsp/_debug/getLastDidChange': async () => lastDidChange,
  'lsp/_debug/getLastDidClose': async () => lastDidClose,
  'lsp/_debug/getLastDiagnostics': async () => lastDiagnostics,
};

/* =========================
 * message loop
 * ========================= */

self.onmessage = async (e) => {
  const msg = e.data;
  if (!msg || msg.jsonrpc !== '2.0') return;

  const { id, method, params } = msg;
  const handler = handlers[method];

  if (!handler) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: {
          code: -32601,
          message: `Method not found: ${method}`,
        },
      });
    }
    return;
  }

  try {
    const result = await handler(params);
    if (id != null) {
      self.postMessage({ jsonrpc: '2.0', id, result });
    }
  } catch (err) {
    if (id != null) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: {
          code: err?.code ?? -32000,
          message: err?.message ?? String(err),
        },
      });
    }
  }
};

// ready
postLog('Worker loaded and ready.');
self.postMessage({ jsonrpc: '2.0', method: 'worker/ready' });
```


æä¾›ã—ãŸå†…å®¹ã‚’ç²¾æŸ»ã—ã€ã‚ãªãŸã¨ã®ä»¥å‰ã®å–ã‚Šæ±ºã‚ã‚‚è€ƒæ…®ã—ãªãŒã‚‰ã€ã‚³ãƒ¼ãƒ‰ã‚’ã©ã®ã‚ˆã†ã«æ‰‹ã‚’ã¤ã‘ã¦ã„ãã‹ã‚’æ±ºã‚ã¦ã„ããŸã„ã€‚


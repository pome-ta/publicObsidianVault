```js
// core/vfs-core.js
// v0.0.3.x - minimal single-file VFS

import * as vfs from 'https://esm.sh/@typescript/vfs';
import ts from 'https://esm.sh/typescript';
import { postLog } from '../util/logger.js';
import { sleep } from '../util/async-utils.js';

class VfsCoreClass {
  #defaultMap = null;          // ★ 縮小: defaultMap のみ保持
  #env = null;                 // ★ 現在扱う env は常に 1 つ（単一ファイル）
  #ready = false;
  #ensurePromise = null;

  // ★ path 正規化だけは残す（LSP では必須）
  #normalize(path) {
    let p = String(path).replace(/^file:\/\//, '');
    if (!p.startsWith('/')) p = `/${p}`;
    return p;
  }

  // ★ 薄い retry ロジックのみ維持（将来 v0.0.4・ATA でも使える）
  async #loadDefaultMap(retry = 3, timeoutMs = 5000) {
    let lastErr = null;
    for (let i = 1; i <= retry; i++) {
      postLog(`VFS: load defaultMap attempt ${i}/${retry}`);
      try {
        const timeout = new Promise((_, reject) =>
          setTimeout(() => reject(new Error('timeout')), timeoutMs)
        );

        const map = await Promise.race([
          vfs.createDefaultMapFromCDN(
            {
              target: ts.ScriptTarget.ES2022,
              module: ts.ModuleKind.ESNext
            },
            ts.version,
            false,
            ts
          ),
          timeout
        ]);

        return map;
      } catch (e) {
        lastErr = e;
        if (String(e.message).includes('fetch')) throw e;
        if (String(e.message).includes('NetworkError')) throw e;
        if (String(e.message).includes('timeout')) {
          await sleep(300 * i);
          continue;
        }
        throw e;
      }
    }
    throw lastErr || new Error('VFS defaultMap load failed');
  }

  // ★ 縮小版 ensureReady: createEnvironment 削除
  async ensureReady() {
    if (this.#ready && this.#env) return;

    if (this.#ensurePromise) return this.#ensurePromise;

    this.#ensurePromise = (async () => {
      if (!this.#defaultMap) {
        this.#defaultMap = await this.#loadDefaultMap();
      }

      // ★ createEnvironment を単純化: defaultMap の浅コピー → env
      const map = new Map(this.#defaultMap);
      const system = vfs.createSystem(map);

      // ★ 単一ファイル前提: rootFiles は空のまま
      const env = vfs.createVirtualTypeScriptEnvironment(
        system,
        [],
        ts,
        {
          target: ts.ScriptTarget.ES2022,
          module: ts.ModuleKind.ESNext,
          strict: true,
          noEmit: true
        }
      );

      this.#env = env;
      this.#ready = true;
      postLog('VFS: ready');
    })();

    return this.#ensurePromise;
  }

  isReady() {
    return !!(this.#ready && this.#env);
  }

  // ★ v0.0.3 で唯一のファイル操作 API（updateFile）
  updateFile(path, content) {
    if (!this.#env) throw new Error('VFS not ready');
    const p = this.#normalize(path);

    if (this.#env.getSourceFile(p)) {
      this.#env.updateFile(p, content);
    } else {
      // ★ createFile は内部利用のみ。外部 API としては updateFile に統一
      this.#env.createFile(p, content);
    }
    return { path: p };
  }

  // ★ ScriptSnapshot API（最小 LSP 対応に必須）
  getScriptSnapshot(path) {
    if (!this.#env) throw new Error('VFS not ready');
    const p = this.#normalize(path);
    const sf = this.#env.getSourceFile(p);
    if (!sf) return null;
    return ts.ScriptSnapshot.fromString(sf.text);
  }

  // ★ debug/test 用（単一ファイル情報だけ返す）
  _getFile(path) {
    if (!this.#env) throw new Error('VFS not ready');
    const p = this.#normalize(path);
    const sf = this.#env.getSourceFile(p);
    return {
      path: p,
      content: sf?.text ?? null
    };
  }

  // ★ test isolation のために必要
  resetForTest() {
    this.#defaultMap = null;
    this.#env = null;
    this.#ready = false;
    this.#ensurePromise = null;
    postLog('VFS: reset');
  }
}

export const VfsCore = new VfsCoreClass();
export const ensureReady = VfsCore.ensureReady.bind(VfsCore);
export const updateFile = VfsCore.updateFile.bind(VfsCore);
export const getScriptSnapshot = VfsCore.getScriptSnapshot.bind(VfsCore);
export const isReady = VfsCore.isReady.bind(VfsCore);
export const _getFile = VfsCore._getFile.bind(VfsCore);
export const resetForTest = VfsCore.resetForTest.bind(VfsCore);
```
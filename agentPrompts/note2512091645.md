# v0.0.3.3 

ä»¥ä¸‹ã®çŠ¶æ…‹ã‚’æœ€æ–°ç‰ˆv0.0.3.3 ã¨ã—ã¦ã€è¨˜éŒ²ã—ã¦ã€‚
å‚ç…§ã™ã¹ãã‚³ãƒ¼ãƒ‰ã¯ã€æœ€æ–°ç‰ˆæ§‹æˆã‚’å›ºå®šã€‚

v0.0.3.3 ã¯ã€ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã§ç¤ºã™ã¨ã€`vfs-openFile.test.js` ã§ã‚ã‚Šã€ãƒ†ã‚¹ãƒˆã¯é€šéï¼ˆã‚°ãƒªãƒ¼ãƒ³ï¼‰ã—ã¦ã„ã‚‹ã€‚


## å®Ÿè£…ã®é€²ã‚æ–¹

### ãƒãƒ¼ã‚¸ãƒ§ãƒ³

`v{a}.{b}.{c}.{d}` ï¼ˆãã‚Œãã‚Œã®ä½ã‚’ `a`, `b`, `c`, `d` ï¼‰ã¨ã™ã‚‹ã¨

`d` : ä¸€ã¤ã®ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰
`c` : æ§‹é€ ã®å¤‰æ›´
`b` : ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¦ç´ ã®è¿½åŠ 
`a` : å®Œæˆï¼ˆæœ¬ç•ªç’°å¢ƒï¼‰

ã¨ã€ã‚¹ãƒ¢ãƒ¼ãƒ«ã‚¹ãƒ†ãƒƒãƒ—ã§æ•°å€¤ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¦ã„ãã€‚

`d` ã§ã€ï¼ˆç¾çŠ¶ã®ï¼‰`lsp-core.js` ã‚„`worker.js` ãªã©ã€ãƒ†ã‚¹ãƒˆã§ã¯ãªã„æ©Ÿèƒ½çš„ãªã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãæ›ãˆã‚‹ã“ã¨ã‚‚ã‚ã‚‹ãŒã€æ©Ÿèƒ½çš„ãªã‚³ãƒ¼ãƒ‰ã¯æ¥µåŠ›ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆ†å‰²ã¯è¡Œã‚ãªã„æ–¹é‡ã€‚
ç†æƒ³ã¯ã€`c`  ãŒå¤‰ã‚ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã€åˆ†å‰²ã‚’æ¤œè¨ã€‚

TDDçš„ï¼ˆã€Œãƒ†ã‚¹ãƒˆã€ã«ã¤ã„ã¦ã¯å¾Œè¿°ï¼‰ãªæµã‚Œã§ã€
æ©Ÿèƒ½çš„ãªã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãæ›ãˆã‚‹ã“ã¨ã¯ã€å¤§ã„ã«å¯èƒ½æ€§ã¯ã‚ã‚‹ã€‚


### ãƒ†ã‚¹ãƒˆ

TDD ã‚’æ¡ç”¨ã€‚
1. ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰å®Ÿè£…ï¼ˆæ–°è¦è¿½åŠ ï¼‰
2. æ©Ÿèƒ½çš„ãªã‚³ãƒ¼ãƒ‰æ›¸ãæ›ãˆ

ã®é †ç•ªã§ã€ãƒ¬ãƒƒãƒ‰ã‚·ã‚°ãƒŠãƒ«ã‹ã‚‰ã‚°ãƒªãƒ¼ãƒ³ã‚·ã‚°ãƒŠãƒ«ã‚’ç›®æŒ‡ã™ã€‚

å®Ÿè¡Œçµæœã®log ã‚’ç§ãŒã‚ãªãŸã«æç¤ºã—ã€æŒ™å‹•ã®ç¢ºèªã‚’è¡Œã†ã€‚

#### ãƒ†ã‚¹ãƒˆã®ãŸã‚ã®`test-utils.js`

`test-utils.js` ã‚‚ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã”ã¨ã«æº–å‚™ã€‚
ç§ã®ãƒ–ãƒ©ã‚¦ã‚¶å®Ÿè¡Œã®çµæœã®log ã‚’å‡ºã™æ©Ÿèƒ½ãªã©ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã€‚

â€» webWorker ã®log ãŒã€ç§ã®å®Ÿè¡Œç’°å¢ƒã§ã¯ç°¡å˜ã«å‡ºãªã„ãŸã‚ã€DOM ã«ã¦å‡ºã›ã‚‹ã‚ˆã†ã«ã—ã¦ã„ã‚‹


### å®Ÿè¡Œç’°å¢ƒ

åŸºæœ¬çš„ã«iOS safari ã§å®Ÿè¡Œã€‚log ã¯ã€eruda ã‚’çµŒç”±ã€‚








## ç¾åœ¨ã®å®Ÿè£…çŠ¶æ³

v0.0.3.3 æ™‚ç‚¹ã®çŠ¶æ³ã‚’ä»¥ä¸‹ã«ç¤ºã™

### ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ„ãƒªãƒ¼

```
.
â”œâ”€â”€ core
â”‚   â”œâ”€â”€ error-codes.js
â”‚   â”œâ”€â”€ lsp-core.js
â”‚   â””â”€â”€ vfs-core.js
â”œâ”€â”€ test
â”‚   â”œâ”€â”€ test-runner.js
â”‚   â””â”€â”€ v0.0.3
â”‚       â”œâ”€â”€ test-utils.js
â”‚       â”œâ”€â”€ vfs-ensureReady.basic.test.js
â”‚       â”œâ”€â”€ worker-vfs-cached-init.test.js
â”‚       â”œâ”€â”€ lsp-initialize-and-openFile.basic.test.js
â”‚       â”œâ”€â”€ vfs-class-singleton.test.js
â”‚       â””â”€â”€ vfs-openFile.test.js
â”œâ”€â”€ util
â”‚   â”œâ”€â”€ async-utils.js
â”‚   â””â”€â”€ logger.js
â””â”€â”€ worker.js
```


### ã‚³ãƒ¼ãƒ‰

#### `core/`


#### `core/error-codes.js`

```error-codes.js
// core/error-codes.js

/**
 * JSON-RPC 2.0 and LSP standard error codes.
 * @see https://www.jsonrpc.org/specification#error_object
 * @see https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#errorCodes
 */
export const JsonRpcErrorCode = {
  // JSON-RPC 2.0 Pre-defined errors
  ParseError: -32700,
  InvalidRequest: -32600,
  MethodNotFound: -32601,
  InvalidParams: -32602,
  InternalError: -32603,

  // A generic server error for implementation-defined server-errors (-32000 to -32099)
  ServerError: -32000,
  // LSP specific error codes
  // @see https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#errorCodes
  ServerNotInitialized: -32002,
  UnknownErrorCode: -32001,
};

```


#### `core/lsp-core.js`

v0.0.3ç³» ã§ã¯ã€ç·¨é›†ã‚’ã—ã¦ã„ãªã„ãŸã‚ã€v0.0.2.14 ã¨ãªã£ã¦ã„ã‚‹

```lsp-core.js
// core/lsp-core.js
// v0.0.2.14

import ts from 'https://esm.sh/typescript';
import { VfsCore } from './vfs-core.js';
import { postLog } from '../util/logger.js';

class LspServer {
  #env = null;
  #openFiles = new Map();
  #compilerOptions = {};

  constructor() {
    postLog('LspServer instance created');
  }

  /**
   * Minimal compiler options merge: take defaults and shallow-merge incoming.
   * Avoid heavy sanitization here; keep small and predictable.
   */
  #mergeCompilerOptions(incoming = {}) {
    const defaults = VfsCore.getDefaultCompilerOptions
      ? VfsCore.getDefaultCompilerOptions()
      : {
          target: ts.ScriptTarget.ES2022,
          module: ts.ModuleKind.ESNext,
          moduleResolution: ts.ModuleResolutionKind.Bundler,
          strict: true,
        };
    return Object.assign({}, defaults, incoming || {});
  }

  async initialize(params = {}) {
    const incoming = params.initializationOptions?.compilerOptions || {};
    this.#compilerOptions = this.#mergeCompilerOptions(incoming);

    postLog(`LSP initialize (opts): ${JSON.stringify(this.#compilerOptions)}`);

    await VfsCore.ensureReady();

    // Create empty environment (no root files yet)
    this.#env = VfsCore.createEnvironment(this.#compilerOptions, [], {});
    postLog('LspServer initialized, env created.');
  }

  getInitializeResult() {
    return {
      capabilities: {
        textDocumentSync: 1,
      },
      serverInfo: {
        name: 'WebWorker-LSP-Server',
        version: '0.0.2',
      },
    };
  }

  async didOpen(params) {
    const { uri, text, version } = params.textDocument;
    const path = this.#uriToPath(uri);
    postLog(`didOpen ${path} (version:${version})`);

    this.#openFiles.set(uri, { text, version });
    await this.#recreateEnv();
    // publish immediately (no debounce)
    await this.publishDiagnostics(uri);
  }

  async didChange(params) {
    const { uri, version } = params.textDocument;
    const changes = params.contentChanges || [];
    const text = changes.length ? changes[changes.length - 1].text : undefined;
    if (typeof text !== 'string') {
      postLog(`didChange received but no text for ${uri}`);
      return;
    }
    const path = this.#uriToPath(uri);
    postLog(`didChange ${path} (version:${version})`);

    this.#openFiles.set(uri, { text, version });
    await this.#recreateEnv();
    await this.publishDiagnostics(uri);
  }

  async didClose(params) {
    const { uri } = params.textDocument;
    const path = this.#uriToPath(uri);
    postLog(`didClose ${path}`);

    this.#openFiles.delete(uri);
    await this.#recreateEnv();
    // clear diagnostics immediately
    this.#clearDiagnostics(uri);
  }

  /**
   * Recreate the VFS environment from currently open files.
   * Simplified: no retry loop, assume VfsCore.createEnvironment is robust.
   */
  async #recreateEnv() {
    const rootFiles = [];
    const initialFiles = {};
    for (const [uri, { text }] of this.#openFiles.entries()) {
      let path = this.#uriToPath(uri);
      if (!path.startsWith('/')) {
        path = `/${path}`;
      }
      rootFiles.push(path);
      initialFiles[path] = text;
    }

    try {
      this.#env = VfsCore.createEnvironment(
        this.#compilerOptions,
        rootFiles,
        initialFiles
      );

      // Ensure content applied
      for (const [path, content] of Object.entries(initialFiles)) {
        try {
          if (this.#env.getSourceFile && this.#env.getSourceFile(path)) {
            this.#env.updateFile(path, content);
          } else {
            this.#env.createFile(path, content);
          }
        } catch (e) {
          postLog(
            `recreateEnv sync failed for ${path}: ${e?.message ?? String(e)}`
          );
        }
      }

      // Try to prime the program; if it fails, we still continue (logs)
      try {
        this.#env.languageService.getProgram();
      } catch (e) {
        postLog(
          `getProgram() during recreateEnv failed: ${e?.message ?? String(e)}`
        );
      }

      postLog(`recreateEnv done; roots: [${rootFiles.join(', ')}]`);
    } catch (e) {
      postLog(`recreateEnv failed: ${e?.message ?? String(e)}`);
      throw e;
    }
  }

  /**
   * Map TS Diagnostic -> LSP Diagnostic (standards-aligned).
   * - message uses ts.flattenDiagnosticMessageText
   * - relatedInformation mapped only when file+start available
   */
  #mapTsDiagnosticToLsp(diag, path, program) {
    const start = typeof diag.start === 'number' ? diag.start : 0;
    const length = typeof diag.length === 'number' ? diag.length : 0;

    let sourceFile = null;
    try {
      sourceFile = program?.getSourceFile(path) ?? null;
    } catch (e) {
      sourceFile = null;
    }

    const startPos =
      sourceFile && typeof start === 'number'
        ? ts.getLineAndCharacterOfPosition(sourceFile, start)
        : { line: 0, character: 0 };

    const endPos =
      sourceFile && typeof start === 'number' && typeof length === 'number'
        ? ts.getLineAndCharacterOfPosition(sourceFile, start + length)
        : { line: startPos.line, character: startPos.character };

    const message = ts.flattenDiagnosticMessageText(diag.messageText, '\n');

    // Severity mapping: TS -> LSP
    let severity = 1; // default Error
    if (typeof diag.category === 'number') {
      switch (diag.category) {
        case ts.DiagnosticCategory.Error:
          severity = 1;
          break;
        case ts.DiagnosticCategory.Warning:
          severity = 2;
          break;
        case ts.DiagnosticCategory.Suggestion:
          severity = 3;
          break;
        case ts.DiagnosticCategory.Message:
        default:
          severity = 3;
          break;
      }
    }

    const lsp = {
      range: { start: startPos, end: endPos },
      message,
      severity,
      source: 'ts',
      code: diag.code,
    };

    // Map relatedInformation -> LSP relatedInformation when location available
    try {
      if (
        Array.isArray(diag.relatedInformation) &&
        diag.relatedInformation.length > 0
      ) {
        const riList = [];
        for (const ri of diag.relatedInformation) {
          try {
            let riUri = null;
            let riRange = {
              start: { line: 0, character: 0 },
              end: { line: 0, character: 0 },
            };

            if (
              ri?.file &&
              typeof ri.file === 'object' &&
              typeof ri.file.fileName === 'string'
            ) {
              riUri = `file://${
                ri.file.fileName.startsWith('/')
                  ? ri.file.fileName
                  : ri.file.fileName
              }`;
              if (typeof ri.start === 'number') {
                const pos = ts.getLineAndCharacterOfPosition(ri.file, ri.start);
                riRange = {
                  start: {
                    line: pos.line,
                    character: pos.character,
                  },
                  end: {
                    line: pos.line,
                    character: pos.character,
                  },
                };
              }
            } else if (ri?.file && typeof ri.file === 'string') {
              riUri = `file://${ri.file.startsWith('/') ? ri.file : ri.file}`;
              // cannot compute line/char without SourceFile
            }

            const riMsg = ts.flattenDiagnosticMessageText(ri.messageText, '\n');

            if (riUri) {
              riList.push({
                location: { uri: riUri, range: riRange },
                message: riMsg,
              });
            }
          } catch (e) {
            postLog(`map relatedInformation error: ${String(e?.message ?? e)}`);
            // continue with other relatedInformation
          }
        }

        if (riList.length > 0) {
          lsp.relatedInformation = riList;
        }
      }
    } catch (e) {
      postLog(`relatedInformation mapping failed: ${String(e?.message ?? e)}`);
    }

    return lsp;
  }

  /**
   * Publish diagnostics for a given uri (immediate, no debounce).
   */
  async publishDiagnostics(uri) {
    if (!this.#env) {
      postLog('publishDiagnostics called but env is not initialized');
      return;
    }
    const path = this.#uriToPath(uri);

    let program;
    try {
      program = this.#env.languageService.getProgram();
    } catch (e) {
      postLog(
        `getProgram() failed before diagnostics: ${e?.message ?? String(e)}`
      );
    }

    const syntactic =
      this.#env.languageService.getSyntacticDiagnostics(path) || [];
    const semantic =
      this.#env.languageService.getSemanticDiagnostics(path) || [];
    const all = [...syntactic, ...semantic];

    if (all.length > 0) {
      postLog(`Diagnostics detail for ${path}:`);
      for (const d of all) {
        try {
          const msg = ts.flattenDiagnosticMessageText(d.messageText, '\n');
          postLog(
            `  - code:${d.code} start:${d.start ?? '-'} len:${
              d.length ?? '-'
            } msg:${msg}`
          );
        } catch (e) {
          postLog(`  - (failed to stringify diag) ${String(e?.message ?? e)}`);
        }
      }
    }

    const diagnostics = all.map((d) =>
      this.#mapTsDiagnosticToLsp(d, path, program)
    );

    postLog(`Publishing ${diagnostics.length} diagnostics for ${path}`);
    self.postMessage({
      jsonrpc: '2.0',
      method: 'textDocument/publishDiagnostics',
      params: { uri, diagnostics },
    });
  }

  #clearDiagnostics(uri) {
    self.postMessage({
      jsonrpc: '2.0',
      method: 'textDocument/publishDiagnostics',
      params: { uri, diagnostics: [] },
    });
  }

  #uriToPath(uri) {
    if (!uri) {
      return '';
    }
    let path = String(uri).replace(/^file:\/\//, '');
    if (!path.startsWith('/')) {
      path = `/${path}`;
    }
    return path;
  }
}

let server = null;
async function getServer() {
  if (!server) {
    server = new LspServer();
  }

  return server;
}

export const LspCore = {
  initialize: async (params = {}) => {
    postLog(`LSP initialize params: ${JSON.stringify(params)}`);
    const s = await getServer();
    await s.initialize(params);
    return s.getInitializeResult();
  },

  didOpen: async (params) => {
    const s = await getServer();
    await s.didOpen(params);
  },

  didChange: async (params) => {
    const s = await getServer();
    await s.didChange(params);
  },

  didClose: async (params) => {
    const s = await getServer();
    await s.didClose(params);
  },

  publishDiagnostics: async (uri) => {
    const s = await getServer();
    await s.publishDiagnostics(uri);
  },
};

```

#### `core/vfs-core.js`


```vfs-core.js
// core/vfs-core.js
// v0.0.3.3

import * as vfs from 'https://esm.sh/@typescript/vfs';
import ts from 'https://esm.sh/typescript';
import { postLog } from '../util/logger.js';
import { sleep } from '../util/async-utils.js';

class VfsCoreClass {
  // private state
  #env = null;
  #cachedDefaultMap = null; // Map<string,string>
  #vfsReady = false;
  #ensurePromise = null;
  #nextEnvId = 0; // createEnvironment ã¦ã‚™ä»˜ä¸ã™ã‚‹ä¸€æ„ ID ã®ã‚«ã‚¦ãƒ³ã‚¿
  #lastEnv = null; // æœ€å¾Œã«ä½œæˆ(è¿”å´)ã—ãŸ env ã‚’ä¿æŒ(ãƒ†ã‚¹ãƒˆç”¨ã«å‚ç…§å¯èƒ½ã«ã™ã‚‹)
  #lastRootPaths = []; // lastEnv ã® rootPaths ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥(ãƒ†ã‚™ãƒã‚™ãƒƒã‚¯ã‚™/ãƒ†ã‚¹ãƒˆç”¨)

  // ãƒã‚šã‚¹æ­£è¦åŒ–(file:// ã‚’æ’é™¤ã—å…ˆé ­ / ã‚’ä»˜ä¸)
  #normalizeVfsPath(p) {
    if (!p) {
      return '';
    }
    let s = String(p).replace(/^file:\/\//, '');
    if (!s.startsWith('/')) {
      s = `/${s}`;
    }
    return s;
  }

  // Map ã®æµ…ã„ã‚¯ãƒ­ãƒ¼ãƒ³
  #mapClone(src) {
    return new Map(src);
  }

  // CDN ã‹ã‚‰ defaultMap ã‚’å–å¾—ã™ã‚‹å†…éƒ¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£(ãƒªãƒˆãƒ©ã‚¤ä»˜ã)
  async #createDefaultMapWithRetries(
    retryCount = 3,
    perAttemptTimeoutMs = 5000
  ) {
    let lastError = null;
    for (let attempt = 1; attempt <= retryCount; attempt++) {
      postLog(`VFS init attempt ${attempt}/${retryCount}`);
      try {
        const timeout = new Promise((_, reject) =>
          setTimeout(() => reject(new Error('timeout')), perAttemptTimeoutMs)
        );

        const defaultMap = await Promise.race([
          vfs.createDefaultMapFromCDN(
            {
              target: ts.ScriptTarget.ES2022,
              module: ts.ModuleKind.ESNext,
            },
            ts.version,
            false,
            ts
          ),
          timeout,
        ]);

        postLog(`defaultMap size: ${defaultMap.size}`);
        return defaultMap;
      } catch (error) {
        lastError = error;
        const msg = String(error?.message ?? error);
        if (msg.includes('fetch') || msg.includes('NetworkError')) {
          postLog(`Network error while fetching defaultMap: ${msg}`);
          throw error;
        }
        if (msg.includes('timeout')) {
          postLog(`Timeout on attempt ${attempt}, retrying after backoff`);
          await sleep(1000 * attempt);
          continue;
        }
        postLog(`createDefaultMapWithRetries unknown error: ${msg}`);
        throw error;
      }
    }
    throw lastError || new Error('VFS init failed after retries');
  }

  // public: defaultMap ã‹ã‚™æº–å‚™ã•ã‚Œã‚‹ã¾ã¦ã‚™å¾…ã¤(æ—¢å­˜ ensureReady ã¨äº’æ›)
  async ensureReady(retry = 3, timeoutMs = 5000) {
    if (this.#vfsReady && this.#cachedDefaultMap) {
      postLog('Using existing cachedDefaultMap (already ready)');
      // env ã‹ã‚™ç„¡ã„å ´åˆã¯ä½œã‚‹
      if (!this.#env) {
        this.createEnvironment();
      }
      return;
    }
    if (this.#ensurePromise) {
      return this.#ensurePromise;
    }

    this.#ensurePromise = (async () => {
      try {
        if (!this.#cachedDefaultMap) {
          this.#cachedDefaultMap = await this.#createDefaultMapWithRetries(
            retry,
            timeoutMs
          );
        } else {
          postLog('Using existing cachedDefaultMap (populate)');
        }
        this.#vfsReady = true;
        // â˜…ã“ã“ã¦ã‚™ env ã‚’ä½œã‚‹
        if (!this.#env) {
          this.createEnvironment();
        }

        postLog('VFS ensureReady complete');
      } finally {
        this.#ensurePromise = null;
      }
    })();

    return this.#ensurePromise;
  }

  // public: ç¾åœ¨ã® defaultMap ã‚’è¿”ã™(ãƒ†ã‚¹ãƒˆã‚„å¤–éƒ¨å‚ç…§å‘ã‘)
  getDefaultMap() {
    return this.#cachedDefaultMap;
  }

  // public: ãƒ†ã‚™ãƒ•ã‚©ãƒ«ãƒˆã® compilerOptions
  getDefaultCompilerOptions() {
    return {
      target: ts.ScriptTarget.ES2022,
      module: ts.ModuleKind.ESNext,
      moduleResolution: ts.ModuleResolutionKind.Bundler,
      strict: true,
      allowImportingTsExtensions: true,
      allowArbitraryExtensions: true,
      resolvePackageJsonExports: true,
      resolvePackageJsonImports: true,
      skipLibCheck: true,
      useDefineForClassFields: true,
      noEmit: true,
    };
  }

  /**
   * public: VFS ç’°å¢ƒã‚’ä½œæˆã—ã¦è¿”ã™
   * - æ—¢å­˜ createEnvironment ã¨äº’æ›ã«ãªã‚‹ã‚ˆã†ã«è¨­è¨ˆ
   * - è¿”å´ã™ã‚‹ env ã«ä¸€æ„ã® __vfsId ã‚’ä»˜ä¸ã—ã¦ä¿æŒ(ãƒ†ã‚¹ãƒˆã¦ã‚™ env ã®åŒä¸€æ€§ã‚’æ¯”è¼ƒã¦ã‚™ãã‚‹ã‚ˆã†ã«ã™ã‚‹)
   */
  createEnvironment(compilerOptions = {}, rootFiles = [], initialFiles = {}) {
    if (!this.#cachedDefaultMap) {
      throw new Error('VFS not initialized. Call ensureReady() first.');
    }

    const mapForEnv = this.#mapClone(this.#cachedDefaultMap);

    const normalizedInitialFiles = {};
    for (const [rawKey, content] of Object.entries(initialFiles || {})) {
      try {
        const key = this.#normalizeVfsPath(rawKey);
        const data = String(content ?? '');
        normalizedInitialFiles[key] = data;
        mapForEnv.set(key, data);
        postLog(`createEnvironment: injected initial file: ${key}`);
      } catch (e) {
        postLog(
          `createEnvironment: failed to inject initial file ${rawKey}: ${String(
            e?.message ?? e
          )}`
        );
      }
    }

    const system = vfs.createSystem(mapForEnv);
    const rootPaths = (rootFiles || []).map((r) => this.#normalizeVfsPath(r));

    const defaultOptions = this.getDefaultCompilerOptions();
    const opts = Object.assign({}, defaultOptions, compilerOptions);

    postLog(
      `createEnvironment: about to create env; roots: [${rootPaths.join(
        ', '
      )}], initialFiles: [${Object.keys(normalizedInitialFiles).join(
        ', '
      )}], opts: ${JSON.stringify(opts)}`
    );

    const env = vfs.createVirtualTypeScriptEnvironment(
      system,
      rootPaths,
      ts,
      opts
    );

    // env ã«ä¸€æ„ ID ã‚’ä»˜ä¸ã—ã¦ä¿æŒ(@typescript/vfs ã® env ã«ãƒ•ã‚£ãƒ¼ãƒ«ãƒˆã‚™ã‚’ä»˜ä¸)
    if (!env.__vfsId) {
      env.__vfsId = ++this.#nextEnvId;
    }
    this.#lastEnv = env;
    this.#lastRootPaths = rootPaths.slice();
    this.#env = env; // æ­£å¼ã«ä¿æŒ

    postLog(
      `VFS environment created; roots: [${rootPaths.join(', ')}] (envId=${
        env.__vfsId
      })`
    );

    // åŒæœŸçš„ã«åˆæœŸãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’åæ˜ (createFile/updateFile)
    for (const [path, content] of Object.entries(normalizedInitialFiles)) {
      try {
        if (env.getSourceFile && env.getSourceFile(path)) {
          env.updateFile(path, content);
        } else {
          env.createFile(path, content);
        }
      } catch (e) {
        postLog(
          `createEnvironment sync apply failed for ${path}: ${String(
            e?.message ?? e
          )}`
        );
      }
    }

    try {
      env.languageService.getProgram();
    } catch (e) {
      postLog(
        `getProgram() failed after env creation: ${String(e?.message ?? e)}`
      );
    }

    return env;
  }

  getEnv() {
    return this.#env;
  }

  openFile(path, content) {
    if (!this.#env) {
      throw new Error('VFS env not created');
    }
    const normalized = this.#normalizeVfsPath(path);
    if (this.#env.getSourceFile(normalized)) {
      this.#env.updateFile(normalized, content);
    } else {
      this.#env.createFile(normalized, content);
    }
    return { ok: true, path: normalized }; // â˜… path ã‚’è¿½åŠ 
  }

  // public: ãƒ†ã‚¹ãƒˆç”¨ã«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
  resetForTest() {
    this.#cachedDefaultMap = null;
    this.#vfsReady = false;
    this.#ensurePromise = null;
    this.#nextEnvId = 0;
    this.#lastEnv = null;
    this.#lastRootPaths = [];
    postLog('VfsCore resetForTest() called');
  }

  // public: æº–å‚™æ¸ˆã¿ã‹ã¨ã‚™ã†ã‹
  isReady() {
    return !!(this.#vfsReady && this.#cachedDefaultMap);
  }

  // public: ãƒ†ã‚¹ãƒˆç”¨ã® env æƒ…å ±ã‚’è¿”ã™
  getEnvInfo() {
    return {
      envId: this.#lastEnv?.__vfsId ?? null,
      defaultMapSize: this.#cachedDefaultMap?.size ?? 0,
      lastRootPaths: this.#lastRootPaths.slice(),
    };
  }

  _getFile(path) {
    if (!this.#env) {
      throw new Error('VFS env not created');
    }
    const normalized = this.#normalizeVfsPath(path);
    const sf = this.#env.getSourceFile(normalized);
    if (!sf) {
      return { path: normalized, content: null };
    }
    return {
      path: normalized,
      content: sf.text ?? null,
    };
  }
}

// ã‚·ãƒ³ã‚¯ã‚™ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ã‚¨ã‚¯ã‚¹ãƒ›ã‚šãƒ¼ãƒˆ(æ—¢å­˜ã‚³ãƒ¼ãƒˆã‚™ã‹ã‚‰ã®äº’æ›ã®ãŸã‚)
export const VfsCore = new VfsCoreClass();

// æ—§ API äº’æ›: é–¢æ•°ã¨ã—ã¦ã‚‚å‘¼ã¸ã‚™ã‚‹ã‚ˆã†ã«ãƒã‚™ã‚¤ãƒ³ãƒˆã‚™ã—ã¦ãŠã
export const ensureReady = VfsCore.ensureReady.bind(VfsCore);
export const createEnvironment = VfsCore.createEnvironment.bind(VfsCore);
export const resetForTest = VfsCore.resetForTest.bind(VfsCore);
export const getDefaultMap = VfsCore.getDefaultMap.bind(VfsCore);
export const getDefaultCompilerOptions =
  VfsCore.getDefaultCompilerOptions.bind(VfsCore);
export const isReady = VfsCore.isReady.bind(VfsCore);
export const getEnvInfo = VfsCore.getEnvInfo.bind(VfsCore);
export const openFile = VfsCore.openFile.bind(VfsCore);
export const _getFile = VfsCore._getFile.bind(VfsCore);
```

### `test/`


#### `test/test-runner.js`

```test/test-runner.js
// test/test-runner.js
// v0.0.3.3

console.log('ğŸš€ test-runner.js loaded');

//import './v0.0.3/vfs-ensureReady.basic.test.js';
//import './v0.0.3/lsp-initialize-and-openFile.basic.test.js';
//import './v0.0.3/vfs-class-singleton.test.js';

import './v0.0.3/vfs-openFile.test.js';
```


#### `test/v0.0.3/test-utils.js`

```test-utils.js
// test/v0.0.3/test-utils.js
// v0.0.3

let requestId = 0;

/**
 * Workerã‚’ç”Ÿæˆã—ã€ãƒ­ã‚¯ã‚™ãƒ¡ãƒƒã‚»ãƒ¼ã‚·ã‚™ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›ã™ã‚‹ãƒªã‚¹ãƒŠãƒ¼ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ•ã‚šã—ã¾ã™ã€‚
 * @param {string} path - Workerã‚¹ã‚¯ãƒªãƒ•ã‚šãƒˆã®ãƒã‚šã‚¹
 * @returns {Worker}
 */
export const createTestWorker = (path, onLog) => {
  const worker = new Worker(path, { type: 'module' });

  worker.addEventListener('message', (event) => {
    const data = event.data || {};
    if (data?.method === 'worker/log' && data.params?.message) {
      const formatted = `[${
        data.params.timestamp ?? new Date().toISOString()
      } | WorkerLog] ${data.params.message}`;
      console.log(formatted);
      onLog?.(formatted);
    }
  });

  // ãƒ†ã‚¹ãƒˆç’°å¢ƒã¦ã‚™ã¯ã€ãƒ†ã‚™ãƒ•ã‚©ãƒ«ãƒˆã¦ã‚™ãƒ†ã‚™ãƒã‚™ãƒƒã‚¯ã‚™ãƒ­ã‚¯ã‚™ã‚’æœ‰åŠ¹ã«ã™ã‚‹
  worker.postMessage('debug:on');

  return worker;
};

/**
 * Workerã‹ã‚™ 'worker/ready' é€šçŸ¥ã‚’é€ä¿¡ã™ã‚‹ã¾ã¦ã‚™å¾…æ©Ÿã—ã¾ã™ã€‚
 * @param {Worker} worker
 * @param {number} timeout
 * @returns {Promise<void>}
 */
export const waitForWorkerReady = (worker, timeout = 5000) => {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(
      () => reject(new Error(`Worker ready timeout (${timeout}ms)`)),
      timeout
    );

    const handler = (event) => {
      if (event.data?.method === 'worker/ready') {
        clearTimeout(timer);
        worker.removeEventListener('message', handler);
        resolve();
      }
    };

    worker.addEventListener('message', handler);
  });
};

/**
 * Workerã«JSON-RPCãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã—ã€å¯¾å¿œã™ã‚‹ãƒ¬ã‚¹ãƒ›ã‚šãƒ³ã‚¹ã‚’å¾…ã¡ã¾ã™ã€‚
 * @param {Worker} worker
 * @param {string} method
 * @param {object} params
 * @param {number} timeout
 * @returns {Promise<any>}
 */
export const sendRequest = (worker, method, params = {}, timeout = 30000) => {
  const id = ++requestId;
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      worker.removeEventListener('message', handler);
      reject(new Error(`Request timeout for method: ${method} (${timeout}ms)`));
    }, timeout);

    const handler = (event) => {
      const response = event.data;
      if (response?.id === id) {
        clearTimeout(timer);
        worker.removeEventListener('message', handler);
        if (response.error) {
          reject(
            new Error(response.error.message || JSON.stringify(response.error))
          );
        } else {
          resolve(response.result);
        }
      }
    };

    worker.addEventListener('message', handler);
    worker.postMessage({ jsonrpc: '2.0', id, method, params });
  });
};

/**
 * Workerã«JSON-RPCé€šçŸ¥ã‚’é€ä¿¡ã—ã¾ã™ã€‚ãƒ¬ã‚¹ãƒ›ã‚šãƒ³ã‚¹ã¯å¾…ã¡ã¾ã›ã‚“ã€‚
 * @param {Worker} worker
 * @param {string} method
 * @param {object} params
 */
export const sendNotification = (worker, method, params = {}) => {
  worker.postMessage({ jsonrpc: '2.0', method, params });
};

/**
 * Workerã‹ã‚‰ç‰¹å®šã®ãƒ¡ã‚½ãƒƒãƒˆã‚™ã®é€šçŸ¥ã‹ã‚™é€ä¿¡ã•ã‚Œã‚‹ã®ã‚’å¾…ã¡ã¾ã™ã€‚
 * @param {Worker} worker
 * @param {string} expectedMethod - å¾…æ©Ÿã™ã‚‹é€šçŸ¥ã®ãƒ¡ã‚½ãƒƒãƒˆã‚™å
 * @param {(params: any) => boolean} [paramsMatcher] - é€šçŸ¥ã®paramsã‹ã‚™æœŸå¾…é€šã‚Šã‹åˆ¤å®šã™ã‚‹é–¢æ•°
 * @param {number} timeout
 * @returns {Promise<any>} é€šçŸ¥ã® `params` ã‚ªãƒ•ã‚™ã‚·ã‚™ã‚§ã‚¯ãƒˆ
 */
export const waitForNotification = (
  worker,
  expectedMethod,
  paramsMatcher = () => true, // ãƒ†ã‚™ãƒ•ã‚©ãƒ«ãƒˆã¦ã‚™ã¯å¸¸ã«trueã‚’è¿”ã™
  timeout = 5000
) => {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(
      () =>
        reject(
          new Error(
            `Timeout waiting for notification: ${expectedMethod} (${timeout}ms)`
          )
        ),
      timeout
    );

    const handler = (event) => {
      const notification = event.data;
      if (
        notification?.method === expectedMethod &&
        paramsMatcher(notification.params)
      ) {
        clearTimeout(timer);
        worker.removeEventListener('message', handler);
        resolve(notification.params);
      }
    };

    worker.addEventListener('message', handler);
  });
};

/**
 * ãƒ†ã‚¹ãƒˆçµæœã‚’HTMLãƒªã‚¹ãƒˆã«è¡¨ç¤ºã—ã¾ã™ã€‚
 * @param {string} name - ãƒ†ã‚¹ãƒˆå
 * @param {boolean} passed - åˆå¦
 * @param {string} [details=''] - è©³ç´°ãƒ¡ãƒƒã‚»ãƒ¼ã‚·ã‚™
 */
export const addResult = (name, passed, details = '') => {
  const resultsList = document.getElementById('testOrdered');
  if (!resultsList) return;

  const li = document.createElement('li');
  const status = passed ? 'âœ…' : 'âŒ';
  const message = passed ? details || 'Passed' : details;
  li.textContent = `${status} ${name}: ${message}`;
  li.style.color = passed ? 'green' : 'red';
  resultsList.appendChild(li);
};

```

#### `test/v0.0.3/lsp-initialize-and-openFile.basic.test.js`

```lsp-initialize-and-openFile.basic.test.js
// test/v0.0.3/lsp-initialize-and-openFile.basic.test.js
// v0.0.3.1

import { expect } from 'chai';
import {
  createTestWorker,
  waitForWorkerReady,
  sendRequest,
  sendNotification,
  waitForNotification,
  addResult,
} from './test-utils.js';

console.log('ğŸ§© lsp-initialize-and-openFile.basic.test loaded');

(async () => {
  const testName = 'LSP: initialize and didOpen basic flow';
  let worker;
  try {
    worker = createTestWorker('./js/worker.js');

    await waitForWorkerReady(worker);
    await sendRequest(worker, 'vfs/ensureReady');
    await sendRequest(worker, 'lsp/initialize', { capabilities: {} });

    const fileUri = 'file:///basic-open.ts';
    const content = `export const v = 1;`;

    sendNotification(worker, 'textDocument/didOpen', {
      textDocument: {
        uri: fileUri,
        languageId: 'typescript',
        version: 1,
        text: content,
      },
    });

    const diag = await waitForNotification(
      worker,
      'textDocument/publishDiagnostics',
      (p) => p.uri === fileUri
    );
    expect(diag.uri).to.equal(fileUri);
    expect(diag.diagnostics).to.be.an('array');

    addResult(testName, true);
  } catch (err) {
    addResult(testName, false, err.message);
  } finally {
    worker?.terminate();
  }
})();
```


#### `test/v0.0.3/vfs-ensureReady.basic.test.js`

```vfs-ensureReady.basic.test.js
// test/v0.0.3/vfs-ensureReady.basic.test.js
// v0.0.3.0

import {
  createTestWorker,
  waitForWorkerReady,
  sendRequest,
  addResult,
} from './test-utils.js';

console.log('ğŸ§© vfs-ensureReady.basic.test loaded');

(async () => {
  const testName = 'VFS: ensureReady should complete without error';
  let worker;
  try {
    worker = createTestWorker('./js/worker.js');

    await waitForWorkerReady(worker);
    await sendRequest(worker, 'vfs/ensureReady');

    // no exception -> success
    addResult(testName, true);
  } catch (err) {
    addResult(testName, false, err.message);
  } finally {
    worker?.terminate();
  }
})();
```

#### `test/v0.0.3/vfs-openFile.test.js`

```vfs-openFile.test.js
// test/v0.0.3/vfs-openFile.test.js
// v0.0.3.3

import { expect } from 'chai';
import {
  createTestWorker,
  waitForWorkerReady,
  sendRequest,
  addResult,
} from './test-utils.js';

console.log('ğŸ§© vfs-openFile.test loaded');

(async () => {
  const testName = 'VfsCore openFile: basic create test';
  let worker;
  try {
    worker = createTestWorker('./js/worker.js');
    await waitForWorkerReady(worker);

    await sendRequest(worker, 'vfs/resetForTest');
    await sendRequest(worker, 'vfs/ensureReady');

    // 1. openFile ã‚’å‘¼ã¶
    const filePath = '/src/foo.ts';
    const fileContent = 'export const x = 1;';
    const result = await sendRequest(worker, 'vfs/openFile', {
      path: filePath,
      content: fileContent,
    });

    // 2. openFile ã®åŸºæœ¬ä»•æ§˜ãƒã‚§ãƒƒã‚¯
    expect(result.ok).to.equal(true);
    expect(result.path).to.equal(filePath);

    // 3. _getFile ãƒ¡ã‚½ãƒƒãƒ‰ã§å†…å®¹ç¢ºèª
    const stored = await sendRequest(worker, 'vfs/_getFile', {
      path: filePath,
    });

    expect(stored.path).to.equal(filePath);
    expect(stored.content).to.equal(fileContent);

    addResult(testName, true);
  } catch (err) {
    addResult(testName, false, err.message);
  } finally {
    worker?.terminate();
  }
})();
```

### `util/`

#### `util/async-utils.js`

```async-utils.js
// util/async-utils.js

/** æŒ‡å®šã•ã‚ŒãŸæ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰ã ã‘å¾…æ©Ÿã—ã¾ã™ã€‚ */
export const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
```


#### 

`util/logger.js`

```logger.js
// util/logger.js

let isDebugEnabled = false;

/**
 * ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã®æœ‰åŠ¹/ç„¡åŠ¹ã‚’åˆ‡ã‚Šæ›¿ãˆã¾ã™ã€‚
 * @param {boolean} enabled
 */
export const setDebug = (enabled) => {
  isDebugEnabled = !!enabled;
};

function formatTime() {
  const now = new Date();
  return now.toLocaleTimeString('ja-JP', {
    hour12: false,
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    fractionalSecondDigits: 3,
  });
}

/**
 * Worker å†…éƒ¨ã‹ã‚‰ã®ãƒ­ã‚°é€ä¿¡
 * - debug ãƒ¢ãƒ¼ãƒ‰ã®ã¨ãã®ã¿ send
 * - payload ã¯ JSON-RPC notification å½¢å¼
 */
export const postLog = (message) => {
  if (!isDebugEnabled) {
    return;
  }
  try {
    self.postMessage({
      jsonrpc: '2.0',
      method: 'worker/log',
      params: {
        timestamp: formatTime(),
        message: `[Worker] ${message}`,
      },
    });
  } catch (e) {
    // postMessage ãŒä¾‹å¤–ã«ãªã£ã¦ã‚‚æ²ˆé»™ï¼ˆãƒ†ã‚¹ãƒˆã®é‚ªé­”ã‚’ã—ãªã„ï¼‰
  }
};
```



### `worker.js`


```worker.js
// worker.js
// v0.0.3.3

import { VfsCore } from './core/vfs-core.js';
import { LspCore } from './core/lsp-core.js';
import { JsonRpcErrorCode } from './core/error-codes.js';
import { postLog, setDebug } from './util/logger.js';

// Enable debug by default for test runner visibility
setDebug(true);

// handlers: "method" -> async function(params)
// - Requests (with id) return a result via JSON-RPC response
// - Notifications (no id) do not return a response
const handlers = {
  // VFS
  'vfs/ensureReady': async (params) => await VfsCore.ensureReady(),

  // ãƒ†ã‚¹ãƒˆå°‚ç”¨: VFS ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦å˜ä¸€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åˆæœŸçŠ¶æ…‹ã«æˆ»ã™
  'vfs/resetForTest': async () => {
    return VfsCore.resetForTest();
  },
  // ãƒ†ã‚¹ãƒˆå°‚ç”¨: ãƒ†ã‚¹ãƒˆå°‚ç”¨å†…éƒ¨æƒ…å ±ã®å–å¾—
  'vfs/_getEnvInfo': async () => {
    return VfsCore.getEnvInfo();
  },

  'vfs/openFile': async (params) => {
    const { path, content } = params;
    return VfsCore.openFile(path, content);
  },

  'vfs/createEnvironment': async (params) => {
    return VfsCore.createEnvironment(
      params.compilerOptions,
      params.rootFiles,
      params.initialFiles
    );
  },
  'vfs/_getFile': (params) => VfsCore._getFile(params.path),

  // LSP lifecycle / utility
  'lsp/ping': async () => 'pong',
  'lsp/shutdown': async () => {
    postLog('Worker shutting down...');
    setTimeout(() => self.close(), 100);
    return 'shutdown-complete';
  },
  'lsp/initialize': async (params) => await LspCore.initialize(params),

  // Document sync (VFS required)
  'textDocument/didOpen': async (params) => await LspCore.didOpen(params),
  'textDocument/didChange': async (params) => await LspCore.didChange(params),
  'textDocument/didClose': async (params) => await LspCore.didClose(params),
};

// ============================================================
// JSON-RPC Message Processing
// ============================================================

/**
 * Handle incoming JSON-RPC message object.
 * Validates JSON-RPC 2.0 structure, VFS precondition for LSP methods, and dispatches to handlers.
 *
 * @param {object} msg JSON-RPC message
 */
async function handleJsonRpcMessage(msg) {
  const { jsonrpc, id, method, params } = msg || {};

  if (jsonrpc !== '2.0' || typeof method !== 'string') {
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: {
          code: JsonRpcErrorCode.InvalidRequest,
          message: 'Invalid JSON-RPC 2.0 payload',
        },
      });
    }
    return;
  }

  postLog(`Received: ${method} (id:${id ?? '-'})`);

  // Methods that assume VFS / LSP presence:
  // - textDocument/* always requires VFS
  // - lsp/* except initialize/ping/shutdown require VFS
  const requiresVfs =
    method.startsWith('textDocument/') ||
    (method.startsWith('lsp/') &&
      !['lsp/initialize', 'lsp/ping', 'lsp/shutdown'].includes(method));

  if (requiresVfs && !VfsCore.isReady()) {
    const message = 'VFS not ready. Call `vfs/ensureReady` first.';
    postLog(`Error: ${message}`);
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: JsonRpcErrorCode.ServerNotInitialized, message },
      });
    }
    return;
  }

  const handler = handlers[method];
  if (!handler) {
    const message = `Unknown method: ${method}`;
    postLog(`Error: ${message}`);
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: JsonRpcErrorCode.MethodNotFound, message },
      });
    }
    return;
  }

  try {
    const result = await handler(params);
    postLog(`Finished: ${method}`);
    if (id) {
      // JSON-RPC response for requests
      self.postMessage({
        jsonrpc: '2.0',
        id,
        result: result !== undefined ? result : null,
      });
    }
    // For notifications (no id) - no response sent
  } catch (err) {
    const message = `${method} failed: ${err?.message ?? String(err)}`;
    postLog(`Error: ${message}`);
    if (id) {
      self.postMessage({
        jsonrpc: '2.0',
        id,
        error: { code: JsonRpcErrorCode.ServerError, message },
      });
    }
  }
}

// Message event listener
self.addEventListener('message', async (event) => {
  const { data } = event;

  // Toggle debug mode via simple string messages 'debug:on' | 'debug:off'
  if (typeof data === 'string' && data.startsWith('debug:')) {
    const enabled = data === 'debug:on';
    setDebug(enabled);
    postLog(`Debug mode set ${enabled}`);
    return;
  }

  // JSON-RPC
  if (data?.jsonrpc === '2.0') {
    await handleJsonRpcMessage(data);
    return;
  }

  // Unknown non-jsonrpc message: keep for backwards compatibility
  postLog(`Received unknown message format: ${JSON.stringify(data)}`);
});

// Announce ready
postLog('Worker loaded and ready.');
self.postMessage({ jsonrpc: '2.0', method: 'worker/ready' });
```


## ä¾é ¼

ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–“ã‚’ã€è€ƒæ…®ã—ã¦æ¬²ã—ã„ã€‚

- VfsCore ã¯ static ã¨ private ã®æ··åˆ
- private ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä¸»ä½“ã¨ã—ã¤ã¤ã€shared state ãŒå¿…è¦ãªç®‡æ‰€ã§ã¯ static ã‚’ä½¿ã†
- æ—§æ¥ã®ã€Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«èª­ã¿è¾¼ã¿æ™‚ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã€ã‚’ç ´æ£„
- lsp-core.js ã¨ vfs-core.js ã®ãƒ¬ã‚¤ãƒ¤å¢ƒç•Œã‚’æ˜ç¢ºã«ã™ã‚‹
- CodeMirror LSP çµ±åˆã‚’å‰æã«ã™ã‚‹

ã“ã®æ§‹é€ ã§ã€ãƒ¢ãƒ€ãƒ³ã«æ›¸ã„ã¦ã€‚
å…ˆã»ã©ã‚ãªãŸãŒå‡ºã—ãŸã‚³ãƒ¼ãƒ‰ãŒ17ç‚¹ã ã‹ã‚‰ã€100ç‚¹ã«ã—ã¦ã€‚



æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ï¼ˆv0.0.3.4ï¼‰ ã¨ã—ã¦ã€

1. VfsCore: multi-file read ãƒ†ã‚¹ãƒˆå¼·åŒ–
    - openFileã€updateFileã€getFileSnapshot ã®ä¸€è²«æ€§æ¤œè¨¼
2. VfsCore: incremental update ãƒ†ã‚¹ãƒˆé–‹å§‹
    - ç‰¹ã« TS incremental program ã¾ã§ã¯è¡Œã‹ãšã€ãƒ¡ãƒ¢ãƒªä¸Šã® TS VFS ã®å¢—æ¸›ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ãƒ•ã‚§ãƒ¼ã‚º
3. LspServerCore ã¨ã®é€£çµãƒ†ã‚¹ãƒˆæº–å‚™
    - VFS ã®æº–å‚™ãŒæ•´ã£ãŸã®ã§ã€LSP å´ã¨çµåˆã™ã‚‹åœŸå°ã¥ãã‚Š
4. worker.js ã® RPC ã®æ•´ç†
    - vfs/* ç³» RPC ã®å‘½åã¨å®Ÿè£…ã®è»½é‡åŒ–




ã„ã¾ã®ã‚ãªãŸã®æµã‚Œã§æœ€é©ãªã®ã¯ã€
1 â†’ 3 â†’ 2 â†’ 4
ã®é †ã€‚

ã©ã‚Œã‚’ v0.0.3.3 ã«ã™ã‚‹ï¼Ÿ

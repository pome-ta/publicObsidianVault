もう面倒だから、全部書き落としていくか

# 📝 2025/11/01

```
CodeMirror
  ⇅ (codemirror/lsp-client)
WorkerClient (自前実装)
  ⇅ (vscode-languageserver-protocol + vscode-jsonrpc)
LspServerCore (自前実装)
  ⇅ (typescript + @typescript/vfs + @typescript/ata)
TypeScript LanguageService
```

## GPT とGemini Code Assist の連携

気軽にコピペする運用。gpt との取り決めをVSCode 上でも齟齬なく行うために。


### 最初の指示用のテンプレ

```markdown
# Project Design Guide

この文書は、Gemini Code Assist および他の開発支援AIに対し、
本プロジェクトの設計方針・コーディングルール・構成方針を伝えるためのメモである。

---

## 1. 基本方針

- コードはできる限り **既存標準（LSP仕様、CodeMirror仕様など）に準拠**する
- **自前実装を最小限にし、メンテナンス性を優先**する
- コードの動作説明コメントは「変更・追加した部分のみ」に記述する
- ロジック上の同期・初期化は race condition を避け、`__ready` などのシグナルで同期を取る

---

## 2. コーディング規約

- 変数は変更されない限り `const` を使う
- ファイル内での順序は「クラス定義 → エクスポート → 補助関数」
- 関数名・メソッド名は動詞始まり（例: `createWorkerRpc`, `handleRequest`）
- コメントは箇条書き形式で簡潔に記述する（文末句点不要）
- LSP 通信（JSON-RPC）は仕様に忠実に。独自プロトコルは避ける

---

## 3. ファイル構成方針

| ファイル | 役割 |
|---------:|------|
| `worker-client.js` | メインスレッド側。Worker との JSON-RPC 通信を行う |
| `worker.js` | LSPサーバロジックを実装。`LspServerCore` と `LSPWorker` を含む |
| `main.js` | Editor 初期化および LSP の起動シーケンス（`initialize → initialized → shutdown`）を管理 |

将来的に、`worker-client.js` は `worker-client.js` と `worker-rpc.js` に分割予定

---

## 4. 実装指針

- `WorkerClient` は LSP リクエスト（`send`）と通知（`notify`）を区別して扱う
- `LSPWorker` は JSON-RPC のループを担当し、未定義メソッドにはエラーを返す
- `LspServerCore` は `initialize`, `initialized`, `ping`, `shutdown` を実装済みであること
- 追加機能はまず LSP 標準メソッドに適合する形で検討する

---

## 5. CodeMirror 連携方針

- `@codemirror/language` と `@codemirror/lsp-client` を基本利用
- LSP 側での診断結果や補完は、CodeMirror の組み込み処理に委ねる
- エディタイベントやドキュメント同期のカスタム処理は最小限にする

---

## 6. 命名・コメントルール（補足）

- ファイル内コメントは **変更箇所のみに限定**
- コメントの書式（例）
    - `// 変更: initialize() の呼び出し順を修正`
- 定数・クラス名は PascalCase、メソッド・関数名は camelCase

---

## 7. 補助メモ（AI補完向け）

AI 補完（Gemini / ChatGPT など）でこの方針を踏まえるための指示（プロジェクト内に置く場合）:

このプロジェクトでは上記 design.md に記載された方針を前提として補完・生成を行うこと。  
構成や命名、通信仕様はこれに反しないようにすること。

---

## 8. 今後の拡張メモ（任意）

- `exit` 通知の追加（`shutdown` 後の後処理）
- ファイル監視による VFS 更新
- `textDocument/didChange` の最小差分同期
- `CodeMirror` の診断表示と LSP 結果同期

---
```

### 修正や編集テンプレとして提案されたもの

```markdown
# Edit Instruction Guide

このファイルは、ChatGPT（設計アシスタント）に対して  
`design.md` の内容を **正確に追加・修正・削除** するための指示テンプレート。

---

## ✅ 基本ルール

1. 対象範囲を明示する  
   - どの章・セクション・箇条書きを触るかを明記  
   - 例: 「第3章『ファイル構成方針』」「第2章の2つ目の箇条書き」

2. 操作種別を明記する  
   - 「追加」「修正」「削除」「置換」「追記」など

3. 最終的に入れたい形で書く  
   - ChatGPTに自然文を解釈させず、最終形のMarkdownをそのまま示す

4. 出力形式を指定する  
   - 「変更箇所のみMarkdownで出力」または「design.md全体を再出力」など

---

## 🧩 指示テンプレート（標準形式）

# 編集指示

対象: 第◯章「章タイトル」  
操作: （追加／修正／削除／置換／追記）  
位置: （任意。例: 章の末尾、2行目の箇条書きなど）  
内容:  
（ここに最終的に入れたいMarkdown形式の文を記載）  

出力形式: （例: 修正箇所のみMarkdownで出力）

---

## 📘 指示例

### 例1: 追記
対象: 第2章「コーディング規約」  
操作: 追記  
内容:  
- import 文の順序は、外部ライブラリ → ローカルモジュール の順に統一する  
出力形式: 修正箇所のみMarkdownで出力

---

### 例2: 修正
対象: 第1章「基本方針」  
操作: 修正  
内容:  
「自前実装を最小限にし、メンテナンス性を優先する」  
→ 「自前実装は必要最低限にとどめ、再利用性を優先する」  
出力形式: 修正箇所のみMarkdownで出力

---

### 例3: 削除
対象: 第8章「今後の拡張メモ」  
操作: 削除  
内容:  
- `exit` 通知の追加（`shutdown` 後の後処理）  
出力形式: 修正箇所のみMarkdownで出力

---

### 例4: 全体再構成
対象: design.md 全体  
操作: 章構成を再編成  
内容:  
- 「命名・コメントルール」と「コーディング規約」を統合し、第2章にまとめる  
出力形式: design.md 全体を再出力

---

## ⚡ 簡易ショート形式（慣れたら）

「2章に import 順序ルール追加して」  
「1章の方針を“再利用性を優先”に書き換えて」  
「8章の exit 通知削除して」

この短縮形でも処理可能。  
ただし、複数の変更を同時に行う場合は正式テンプレートを使う。

---

## 🧠 複数変更を一度に指示する場合

# 編集指示

---変更1---  
対象: 第2章「コーディング規約」  
操作: 追記  
内容:  
- import 文の順序は、外部ライブラリ → ローカルモジュール の順に統一する  

---変更2---  
対象: 第5章「CodeMirror 連携方針」  
操作: 修正  
内容:  
- 「CodeMirror の組み込み処理に委ねる」を  
  「CodeMirror の LSP クライアント機能を利用して処理する」に変更

---

## ✅ 出力依頼時のおすすめ文例

- 「上記の指示に従って修正を反映して」  
- 「修正後のMarkdownを出力して」  
- 「修正箇所だけ出力して」  
- 「design.md全体を再出力して」

---

## 🧾 運用メモ

- この `edit-instruction.md` は ChatGPT への指示テンプレートとして維持する  
- `design.md` と同じディレクトリに置くと便利  
- `design.md` の変更履歴を管理したい場合は Git でコミット前に差分を確認する

---
```


# 📝 2025/10/29

## 改めてLSP を理解し直す

```
CodeMirror
⇅
codemirror/lsp-client
⇅ （JSON-RPC 通信）
LSPWorker（実装中の worker.js 内）
⇅ （関数呼び出し）
ts.LanguageService
```


```
┌────────────────────────┐
│ LSP プロトコル層（JSON-RPC で通信） │  ←  initialize, completion などの受付
├────────────────────────┤
│ 言語サービス層（TypeScript API など） │  ←  実際の補完・解析・診断処理
├────────────────────────┤
│ ファイルシステム層（VFSなど）        │  ←  ファイルの内容・依存解決
└────────────────────────┘
```


```
───────────────────────────────────────────────
🧩 CodeMirror + codemirror/lsp-client  (共通層)
───────────────────────────────────────────────
          ↓ JSON-RPC (LSP プロトコル)
───────────────────────────────────────────────
   通信層 (Transport)
───────────────────────────────────────────────
  WebSocket版                      WebWorker版
───────────────────────────────────────────────
  WebSocket(JSON-RPC)              postMessage(JSON-RPC)
  ↳ WebSocketServer                ↳ WorkerClient
  ↳ vscode-ws-jsonrpc              ↳ MessagePort Transport
───────────────────────────────────────────────
   LSPサーバー層 (Server Core)
───────────────────────────────────────────────
  vscode-languageserver/node       LspServerCore（自作）
  ↳ LSPの各メソッド実装            ↳ initialize / didOpen / didChange …
  ↳ 診断・補完・hover など         ↳ 同様のLSPメソッドを再現
───────────────────────────────────────────────
   TypeScript LanguageService
───────────────────────────────────────────────
  typescript（Node.js）             typescript（ブラウザ）
  ↳ ファイルIOあり（fs）            ↳ @typescript/vfs 経由で仮想FS利用
───────────────────────────────────────────────
   ファイル管理層 (FS)
───────────────────────────────────────────────
  Node.js FS or ts.sys             @typescript/vfs.createSystem()
  ↳ 実際のファイル操作              ↳ メモリ上のファイルマップ
───────────────────────────────────────────────
   実行環境
───────────────────────────────────────────────
  Node.js                         Browser (Worker)
───────────────────────────────────────────────
```

[目的：Web Worker でも極力「パッケージだけ」で LSP を動かす構成 | ChatGPT - @codemirror/lsp-client](https://chatgpt.com/s/t_6901a2b7da5c81919eaaed894133f8c8)


# Web Test Runner vs Mocha（ブラウザ向け）比較

以下は **Web Test Runner**（modern-web.dev の実装）と **Mocha（ブラウザ実行）** を、実務で比較して選べるように主要な観点で対比した表。各セルは短く要点を列挙している。選定方針に合わせて最後に推奨ケースも示す。

| 比較項目 | Web Test Runner | Mocha（ブラウザ実行） |
|---|---:|---|
|主目的 / 設計思想|ブラウザ（ES Module）でのモダンなテスト実行。E2Eに近いブラウザ実行を意図。|汎用的なテストフレームワーク。Node／ブラウザ両対応だが、ブラウザで使うときはランタイムやバンドラ等の補助が必要。|
|ESModuleサポート|ネイティブESMを前提に最適化。import ベースでそのまま読み込める。|元来はCommonJS志向。ブラウザでESMを直接使うには設定やバンドラ（または esm CDN）が必要。|
|Worker（Web Worker）テスト|そのままWorkerを spawn してテスト可能。Worker／window 間の統合テストが容易。|Workerテストは可能だが、手動で Worker を生成してメッセージを待つ形。環境整備やhelperが必要になる場合が多い。|
|ブラウザAPI（DOM, postMessage 等）|ブラウザ上で動く実テストランナー。ブラウザAPIをそのまま使える。|ブラウザで実行すればブラウザAPIを使える。ただしセットアップで HTML ラッパーが必要。|
|セットアップ難易度|比較的簡単（設定は柔軟）。ESM + テスト用プラグイン中心で済む。|基本は低いがブラウザ実行にすると `index.html` と読み込み順、スクリプトタグ管理が必要。ESMでの運用は追加設定が発生しやすい。|
|拡張性 / プラグイン|プラグイン設計（プラグインで Babel、TypeScript、ファイル監視、ブラウザマトリクス等追加可能）。|多数の周辺ライブラリ（chai, sinon等）とは互換あり。プラグイン体系は Web Test Runner より古典的。|
|TypeScript 対応|公式に TypeScript サポートが良い（プラグインでトランスパイル）。ソースマップ連携が良好。|TypeScriptは `ts-node` やトランスパイル手順が必要。ブラウザで直接テストするには事前ビルドかCDNトランスパイルが必要。|
|並列・分散・マルチブラウザ|ブラウザプール／並列ラン実行に対応するプラグインがあり、マルチブラウザ・クラウド連携しやすい。|並列実行は自前やラッパー（karma等）に依存することが多い。|
|CI適性（ヘッドレス）|ヘッドレスブラウザを使ったCI実行に対応（PlaywrightやPuppeteerと組み合わせ）。|ヘッドレス実行は可能だが、セットアップ（ヘッドレスブラウザの起動）がやや手動。Karma等と組むと良い。|
|デバッグ体験|ブラウザのDevToolsでそのままデバッグ。ソースマップでステップ実行が自然。|同様にDevToolsでデバッグ可能だが、ブラウザ向けに整えるための手間（HTML/スクリプトラップ等）がある場合がある。|
|レポーター/出力|多数のレポーターやカスタム出力機能をプラグインで追加可能。|大量の既存レポーター（spec, nyan等）あり。CI向け junit 等も豊富。|
|エコシステム安定度|比較的新しく、モダンなワークフローに最適化。活発だが Mocha に比べ成熟度はやや劣る点あり。|非常に成熟・広く使われている。プラグイン・ドキュメント・事例が豊富。|
|依存関係 / バンドリング|ESMネイティブ運用前提で依存解決がシンプル。CDN読み込みやローカルファイル直接読み込みが自然。|依存ライブラリ次第でバンドラ（Rollup, Webpack）やCDN経由が必要になることが多い。|
|学習コスト|テスト概念は既知なら低い。ESMやプラグイン利用の理解が必要。|テストAPI自体は簡単。ブラウザ実行の細かな設定で時間を取ることがある。|
|長所まとめ|モダンなブラウザネイティブテスト、Worker/DOMの統合テストが容易、TypeScriptやソースマップサポート良好。|汎用性・互換性が高く成熟。大量の既存資産（例：chai, sinon, レポーター）が使える。|
|短所まとめ|比較的新しいため既存プラグインに乏しいケースがある。|ブラウザ向けに最適化されていない部分があり、ESM/Worker中心に使うと追加設定が必要。|

---

## 追加の実用メモ（選定の補助）
- **ES Modules と WebWorker を多用するブラウザネイティブ実装**（あなたのケース） → **Web Test Runner が優位**。Workerをそのまま spawn でき、import ベースのソースを直接テストできるため手間が少ない。
- **既に Mocha ベースの大量テスト資産がある／Node とブラウザ両方で同じランナーを使いたい** → **Mocha**。ただしブラウザ実行は `index.html` テンプレートやバンドル準備が必要になる場合がある。
- **CI での安定・広範なレポートが必要** → Mocha の既存エコシステム（ジャッジ用レポーター等）が便利。ただし Web Test Runner も Playwright 等と組めば十分対応可能。

---

## 推奨（あなたの状況を踏まえて）
- あなたは「ブラウザ」「Web Worker」「ESM（CDN 経由も含む）」を積極的に使っているため、**まずは Web Test Runner を試作環境に導入**することを勧める。  
  理由：Worker のテストが自然に書け、TypeScript（トランスパイル）やソースマップ連携も楽で、テストのデバッグがブラウザDevToolsで直感的に行えるため、開発速度とデバッグ効率が上がる。
- ただし既に Mocha のテスト資産が多数ある場合は、**Mocha を選んで移行コストを減らす**のが合理的。

---

もっと具体的な手順が欲しい場合（例：Web Test Runner を使って `worker.js` の ping/pong テストを書く、あるいは Mocha で同等のテストを作る）は、どちらを先に試したいか指定してくれれば、すぐに実際のテストコード（index.html / テストファイル / 実行手順）を用意する。



| 観点 | `<script src="https://cdn.jsdelivr.net/...">` 形式 | `import eruda from 'eruda'` + importmap 形式 |
|------|----------------------------------------------------|---------------------------------------------|
| **読み込みタイミング** | HTML 解析時に即ロードされ、グローバル (`window.eruda`) に登録される | モジュールスクリプト内で `import` 時にロードされる |
| **スコープ** | グローバルスコープ（どのスクリプトからもアクセス可能） | モジュールスコープ（`import` したモジュール内のみ） |
| **依存管理** | CDN URL を直書きするため、依存関係を importmap で管理できない | importmap で一元管理でき、依存バージョンを固定しやすい |
| **ブラウザ対応** | すべてのブラウザ（古い Safari 含む）で動作 | ES Modules 対応ブラウザ限定（iOS 12 以降） |
| **初期化タイミング** | `eruda.init()` を `<body>` 末尾で呼べば即可 | `import` 完了後に明示的に `eruda.init()` を呼ぶ必要あり |
| **キャッシュ** | CDN が最適化済みで高速キャッシュあり | esm.sh が動的にビルドするため初回ロードはやや遅い |
| **利便性** | 最短で動かせる（スニペット1行でOK） | よりモジュラーで、他の import と統一的に扱える |
| **使用例** | デバッグ専用・すぐ試したいとき | プロジェクト内で統一したモジュール構成を保ちたいとき |
| **推奨用途** | 手動検証・実験・PoC | 本番に近い構成（importmapベースのTDD環境） |


# 📝 2025/10/27

## `@types/p5` を入れてみる

```js
// 例: worker.js / LspServerCore 内
async #bootVfs() {
  if (this.#env) return;
  
  const fsMap = await createDefaultMapFromCDN({
    target: ts.ScriptTarget.ES2022,
    lib: ['es2022', 'dom'],
  }, ts);

  // 独自の型定義を追加
  const customDts = `
    declare global {
      interface Window {
        myCustomValue: string;
      }
      function myGlobalFunction(msg: string): void;
    }
  `;
  fsMap.set('/custom-globals.d.ts', customDts);

  const system = createSystem(fsMap);
  const host = createVirtualLanguageServiceHost(system, fsMap, ts, '/index.ts');
  const service = ts.createLanguageService(host);

  this.#env = { fsMap, system, host, languageService: service };
}
```


```js
// worker.js 内
import { createDefaultMapFromCDN } from '@typescript/vfs'

async function loadExtraDTS(vfs) {
  const url = 'https://esm.sh/@types/p5/index.d.ts'
  const res = await fetch(url)
  if (!res.ok) throw new Error(`Failed to load ${url}`)
  const code = await res.text()

  // 仮想ファイルとして追加
  vfs.set('/node_modules/@types/p5/index.d.ts', code)
}
```


``` js
//実際の仕様
import { createDefaultMapFromCDN } from '@typescript/vfs'

// この関数は TypeScript チームが管理している CDN から
// lib.es2022.d.ts や lib.dom.d.ts などを自動取得する
const defaultMap = await createDefaultMapFromCDN({
  target: ts.ScriptTarget.ES2022,
  module: ts.ModuleKind.ESNext,
  lib: ['es2022', 'dom']
})
```


# 📝 2025/10/20

## ChatGPT やり取りログ

やり取りが多くて、過去の確認したい所に移動できないのでメモ。

[GitHub - pome-ta/challengeTestWebWorkerLSP](https://github.com/pome-ta/challengeTestWebWorkerLSP)

この実装。

### `LSP Coverage Map`


> `LSP Coverage Map`

スコープが大きい、実装状況。

- `$/cancelRequest` これは、不要なのかしら？
- `Capability Negotiation (ServerCapabilities)` これはなんだなんだ？
- 






# 📝2025/10/19

## codemirror とLSP

#codemirror #lsp 

AI に聞きながら、ゆっくりと実験中。

[GitHub - pome-ta/challengeTestWebWorkerLSP](https://github.com/pome-ta/challengeTestWebWorkerLSP)

（あとでAI に頼るとして）

- サーバーを立てずにLSP を使う
- Worker で使うこともできる
- `@typescript/vfs` と、`typescript` でいい感じにできる
- これをサーバーとして、通信する
- [GitHub - codemirror/lsp-client: Language server protocol client for CodeMirror](https://github.com/codemirror/lsp-client)
- クライアントは、これを窓口にするのを必須とする
- 裏側をコネコネと実装していく


# 📝2025/10/17

## AI との付き合い

#ai #google

### モバイル

chatGPT のfree でなんとかやってる

### PC

VSCode でGemini Code Assist 使ってみてる

いまは、プロンプトに質問投げるかたちの、いつもの使い方をしている。
なんだかんだ、chatGPT （free）より、質問できる回数は多いかも。

実質無制限の使い方を調べていきたい感じ。



# 📝2025/09/26


## codemirror とlsp


- [Building a better online editor for TypeScript | Val Town Blog](https://blog.val.town/vtlsp?utm_source=chatgpt.com)
- [Bringing the TypeScript Language Server to Observable | Observable](https://observablehq.com/blog/bringing-the-typescript-language-server-to-observable?utm_source=chatgpt.com)
- [Codemirror 6 and Typescript LSP - v6 - discuss.CodeMirror](https://discuss.codemirror.net/t/codemirror-6-and-typescript-lsp/3398)


まず、server 建てて試した方がいいかもしれないけども、、、


# 📝 2025/09/16

## [p5SketchBook/dumpDirectlyTree.py at main · pome-ta/p5SketchBook · GitHub](https://github.com/pome-ta/p5SketchBook/blob/main/dumpDirectlyTree.py)

[`dialog` 要素に「ダイアログの外側クリックで閉じる」処理の追加](https://zenn.dev/de_teiu_tkg/articles/96a46374655e56)




# 📝 2025/09/13

## rubion-objc

[GitHub - pome-ta/pystaUIKitCatalogChallenge: Implemented Apple's official sample UIKitCatalog with Pythonista3 and rubicon-objc.](https://github.com/pome-ta/pystaUIKitCatalogChallenge)

`0.5.2` にupdate してみた

多分だけど、変更なく実行できてると思う


### mac でのPythonista3(rubicon) 実行

iPad でも問題なさそうなのに、mac だとクラッシュしてくれる。
クラッシュレポートちゃんと読んでないけど、何かしら実行環境が違うみたい。

Pythonista3 でもa-shell でも同様

`UIColor` をインスタンスとして呼び出す時に、`ObjCInstance` が呼べないとかなる



# 📝 2025/09/11

p5 の色々な環境

- [GitHub - pome-ta/p5js4codemirror6](https://github.com/pome-ta/p5js4codemirror6)
    - もりもりとコードを書いていくところ
    - エディタ機能もつけて編集ができる
    - 新しく何かを書くところ
- [GitHub - pome-ta/p5SketchBook](https://github.com/pome-ta/p5SketchBook)
    - Fix したコード置き場
    - ファイル一覧を`.json` で管理
    - `_` が先頭にあるファイル名が（多分読めない？）
        - ローカル実行だと大丈夫そう？
        - GitHub pages だとだめかも？
            - 要。原因検討

似通ったリポジトリになってしまった。が、入力保存機能のキャッチが、面倒。同一機能として統合はしないかも


## `importmap` がおもろい

[`<script type="importmap">` - HTML | MDN](https://developer.mozilla.org/ja/docs/Web/HTML/Reference/Elements/script/type/importmap)

`../.../` と設置場所依存な呼び出し方をしてたが、スッキリ読み込みの書き方ができそう






# 📝 2025/09/03

## [p5SketchBook/dumpDirectlyTree.py at main · pome-ta/p5SketchBook · GitHub](https://github.com/pome-ta/p5SketchBook/blob/main/dumpDirectlyTree.py)


`.json` のdump をつくる

- 作成日
- 更新日
- type
- 拡張子？

# 📝 2025/09/02

#api #github 

## GitHub REST API (Contents API)

多分今回は使わないけど

```js
const owner = 'pome-ta';
const repo = 'p5SketchBook'

const endPoint = 'https://api.github.com/repos';
const kind = 'contents'



async function getRepoContents() {
  const res = await fetch([endPoint, owner, repo, kind].join('/'));
  const data = await res.json();
  console.log(data);
}

getRepoContents();
```

オブジェクトで、4つ（リポジトリ直下のもの）を持って来てる


```js
(info): [
  {
    "name": "LICENSE",
    "path": "LICENSE",
    "sha": "a72ad48a1d26d5d69d4fa705a91eb3f32e888189",
    "size": 1064,
    "url": "https://api.github.com/repos/pome-ta/p5SketchBook/contents/LICENSE?ref=main",
    "html_url": "https://github.com/pome-ta/p5SketchBook/blob/main/LICENSE",
    "git_url": "https://api.github.com/repos/pome-ta/p5SketchBook/git/blobs/a72ad48a1d26d5d69d4fa705a91eb3f32e888189",
    "download_url": "https://raw.githubusercontent.com/pome-ta/p5SketchBook/main/LICENSE",
    "type": "file",
    "_links": {
      "self": "https://api.github.com/repos/pome-ta/p5SketchBook/contents/LICENSE?ref=main",
      "git": "https://api.github.com/repos/pome-ta/p5SketchBook/git/blobs/a72ad48a1d26d5d69d4fa705a91eb3f32e888189",
      "html": "https://github.com/pome-ta/p5SketchBook/blob/main/LICENSE"
    }
  },
  {
    "name": "README.md",
    "path": "README.md",
    "sha": "b39dfa34417ea243c03142560593600b490afb61",
    "size": 14,
    "url": "https://api.github.com/repos/pome-ta/p5SketchBook/contents/README.md?ref=main",
    "html_url": "https://github.com/pome-ta/p5SketchBook/blob/main/README.md",
    "git_url": "https://api.github.com/repos/pome-ta/p5SketchBook/git/blobs/b39dfa34417ea243c03142560593600b490afb61",
    "download_url": "https://raw.githubusercontent.com/pome-ta/p5SketchBook/main/README.md",
    "type": "file",
    "_links": {
      "self": "https://api.github.com/repos/pome-ta/p5SketchBook/contents/README.md?ref=main",
      "git": "https://api.github.com/repos/pome-ta/p5SketchBook/git/blobs/b39dfa34417ea243c03142560593600b490afb61",
      "html": "https://github.com/pome-ta/p5SketchBook/blob/main/README.md"
    }
  },
  {
    "name": "modules",
    "path": "modules",
    "sha": "52cb3d3bbf2538ae4dd5d00a93d2676541522631",
    "size": 0,
    "url": "https://api.github.com/repos/pome-ta/p5SketchBook/contents/modules?ref=main",
    "html_url": "https://github.com/pome-ta/p5SketchBook/tree/main/modules",
    "git_url": "https://api.github.com/repos/pome-ta/p5SketchBook/git/trees/52cb3d3bbf2538ae4dd5d00a93d2676541522631",
    "download_url": null,
    "type": "dir",
    "_links": {
      "self": "https://api.github.com/repos/pome-ta/p5SketchBook/contents/modules?ref=main",
      "git": "https://api.github.com/repos/pome-ta/p5SketchBook/git/trees/52cb3d3bbf2538ae4dd5d00a93d2676541522631",
      "html": "https://github.com/pome-ta/p5SketchBook/tree/main/modules"
    }
  },
  {
    "name": "sounds",
    "path": "sounds",
    "sha": "02e73a230f836ee824920dab794fbb5972747707",
    "size": 0,
    "url": "https://api.github.com/repos/pome-ta/p5SketchBook/contents/sounds?ref=main",
    "html_url": "https://github.com/pome-ta/p5SketchBook/tree/main/sounds",
    "git_url": "https://api.github.com/repos/pome-ta/p5SketchBook/git/trees/02e73a230f836ee824920dab794fbb5972747707",
    "download_url": null,
    "type": "dir",
    "_links": {
      "self": "https://api.github.com/repos/pome-ta/p5SketchBook/contents/sounds?ref=main",
      "git": "https://api.github.com/repos/pome-ta/p5SketchBook/git/trees/02e73a230f836ee824920dab794fbb5972747707",
      "html": "https://github.com/pome-ta/p5SketchBook/tree/main/sounds"
    }
  }
]

```

# 📝 2025/09/01

過去自分が書いたmodule みたいなのの整理

```js
export default class DomFactory {
  #element;
  #buildEvent;

  constructor(domTag) {
    this.#element = typeof domTag === 'string' ? document.createElement(domTag) : domTag;

    this.#buildEvent = new CustomEvent('build', {detail: this.#element});
  }

  get element() {
    return this.#element;
  }

  get buildEvent() {
    return this.#buildEvent;
  }

  static create(tag, options) {
    const instance = new this(tag);
    options ? Object.entries(options).forEach(([key, value]) => instance[key](value)) : null;
    instance.element.dispatchEvent(instance.buildEvent);

    return instance.element;
  }

  setAttr(name, val) {
    this.#element.setAttribute(name, val);

    return this;
  }

  setAttrs(attrs) {
    Object.entries(attrs).forEach(([key, value]) => this.setAttr(key, value));

    return this;
  }

  setStyle(prop, val) {
    this.#element.style.setProperty(prop, val);

    return this;
  }

  setStyles(styles) {
    Object.entries(styles).forEach(([key, value]) => this.setStyle(key, value));

    return this;
  }

  addClassList(nameList) {
    this.#element.classList.add(...nameList);

    return this;
  }

  textContent(value) {
    this.#element.textContent = value;

    return this;
  }

  addEventListener({type, listener, options}) {
    this.#element.addEventListener(type, listener, options);

    return this;
  }

  addEventListeners(args) {
    [...args].forEach((arg) => this.addEventListener(arg));

    return this;
  }

  targetAddEventListener({target, type, listener, options}) {
    target.addEventListener(type, listener, options);

    return this;
  }

  targetAddEventListeners(args) {
    [...args].forEach((arg) => this.targetAddEventListener(arg));

    return this;
  }

  appendChildren(children) {
    [...children].forEach((child) => this.#element.appendChild(child));

    return this;
  }

  appendParent(parent) {
    parent.appendChild(this.#element);

    return this;
  }
}

```


```js
/**
 * メソッドチェーン（fluent interface）を用いてDOM要素の生成と操作を効率化するファクトリークラス。
 * @example
 * const button = DomFactory.create('button', { textContent: 'Click Me' });
 * document.body.appendChild(button);
 */
export default class DomFactory {
  /**
   * 内部で管理しているDOM要素。
   * @private
   * @type {HTMLElement}
   */
  #element;

  /**
   * 要素が生成されたことを示すカスタムイベント。
   * @private
   * @type {CustomEvent}
   */
  #buildEvent;

  /**
   * @param {string | HTMLElement} domTag - 作成する要素のタグ名（'div'など）、または既存のDOM要素。
   */
  constructor(domTag) {
    this.#element = typeof domTag === 'string' ? document.createElement(domTag) : domTag;
    this.#buildEvent = new CustomEvent('build', { detail: this.#element });
  }

  /**
   * 現在のDOM要素を返します。
   * @returns {HTMLElement}
   */
  get element() {
    return this.#element;
  }

  /**
   * 'build'カスタムイベントを返します。
   * @returns {CustomEvent}
   */
  get buildEvent() {
    return this.#buildEvent;
  }

  /**
   * 新しいDOM要素を生成し、オプションを適用します。
   * @param {string} tag - 生成する要素のHTMLタグ名。
   * @param {object} [options] - 要素に適用するメソッドと値のキーペア。例: { textContent: 'Hello' }
   * @returns {HTMLElement} - 生成・設定済みのDOM要素。
   */
  static create(tag, options) {
    const instance = new this(tag);
    options ? Object.entries(options).forEach(([key, value]) => instance[key](value)) : null;
    instance.element.dispatchEvent(instance.buildEvent);

    return instance.element;
  }

  /**
   * 要素に属性を1つ設定します。
   * @param {string} name - 属性名。
   * @param {string} val - 属性値。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  setAttr(name, val) {
    this.#element.setAttribute(name, val);
    return this;
  }

  /**
   * 要素に複数の属性を一度に設定します。
   * @param {Record<string, string>} attrs - 属性のキーと値のペアを持つオブジェクト。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  setAttrs(attrs) {
    Object.entries(attrs).forEach(([key, value]) => this.setAttr(key, value));
    return this;
  }

  /**
   * 要素にCSSスタイルを1つ設定します。
   * @param {string} prop - CSSプロパティ名。
   * @param {string} val - CSSプロパティの値。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  setStyle(prop, val) {
    this.#element.style.setProperty(prop, val);
    return this;
  }

  /**
   * 要素に複数のCSSスタイルを一度に設定します。
   * @param {Record<string, string>} styles - CSSプロパティのキーと値のペアを持つオブジェクト。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  setStyles(styles) {
    Object.entries(styles).forEach(([key, value]) => this.setStyle(key, value));
    return this;
  }

  /**
   * 要素のクラスリストに複数のクラスを追加します。
   * @param {string[]} nameList - 追加するクラス名の配列。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  addClassList(nameList) {
    this.#element.classList.add(...nameList);
    return this;
  }

  /**
   * 要素のテキストコンテンツを設定します。
   * @param {string} value - 設定するテキスト。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  textContent(value) {
    this.#element.textContent = value;
    return this;
  }

  /**
   * 要素にイベントリスナーを1つ追加します。
   * @param {object} eventArgs - イベントリスナーの引数オブジェクト。
   * @param {string} eventArgs.type - イベントタイプ。
   * @param {EventListenerOrEventListenerObject} eventArgs.listener - イベントリスナー関数。
   * @param {boolean | AddEventListenerOptions} [eventArgs.options] - イベントリスナーのオプション。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  addEventListener({ type, listener, options }) {
    this.#element.addEventListener(type, listener, options);
    return this;
  }

  /**
   * 要素に複数のイベントリスナーを一度に追加します。
   * @param {Array<object>} args - `addEventListener`に渡す引数オブジェクトの配列。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  addEventListeners(args) {
    [...args].forEach((arg) => this.addEventListener(arg));
    return this;
  }

  /**
   * 任意のターゲットにイベントリスナーを1つ追加します。
   * @param {object} eventArgs - イベントリスナーの引数オブジェクト。
   * @param {EventTarget} eventArgs.target - イベントリスナーを追加するターゲット。
   * @param {string} eventArgs.type - イベントタイプ。
   * @param {EventListenerOrEventListenerObject} eventArgs.listener - イベントリスナー関数。
   * @param {boolean | AddEventListenerOptions} [eventArgs.options] - イベントリスナーのオプション。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  targetAddEventListener({ target, type, listener, options }) {
    target.addEventListener(type, listener, options);
    return this;
  }

  /**
   * 任意のターゲットに複数のイベントリスナーを一度に追加します。
   * @param {Array<object>} args - `targetAddEventListener`に渡す引数オブジェクトの配列。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  targetAddEventListeners(args) {
    [...args].forEach((arg) => this.targetAddEventListener(arg));
    return this;
  }

  /**
   * 要素に複数の子要素を追加します。
   * @param {HTMLElement[]} children - 追加する子要素の配列。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  appendChildren(children) {
    [...children].forEach((child) => this.#element.appendChild(child));
    return this;
  }

  /**
   * 指定された親要素に自身を追加します。
   * @param {HTMLElement} parent - 親となるDOM要素。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  appendParent(parent) {
    parent.appendChild(this.#element);
    return this;
  }
}

```

# 📝 2025/08/31

p5 のsketch を選択して変更させたい

ローカルではなく、リポジトリ上のを読み込む

# 📝 2025/08/25

codemirror は、依存関係が面倒だからやーめた


p5.sound(v1) の方で、`loadSound` が外部から呼べるようだったので、v1 で色々なexample を実行することにする。

私の実装だと、sound 関係を一旦リセット（コード読み直し時）したい。が、`preload` 時に読み込みをしてしまうと
`setup` でリセットされてしまう。


であれば、addon として、sketch code に書かずとも、勝手に実行してもらうことにしたい

## p5.js のaddon


[Creating an Addon Library](https://p5js.org/contribute/creating_libraries/)


`beta` もあるので、気をつけたし

[Creating an Addon Library](https://beta.p5js.org/contribute/creating_libraries/)

[GitHub - processing/p5.js-addon-template](https://github.com/processing/p5.js-addon-template)

このtmp のリポジトリは、v2 の方っぽい。

beta の

```js
function loadCSVAddon(p5, fn, lifecycles){

}

```

と、なっているため。

v1 は、`.prototype` をゴリゴリ使う：

```js
p5.Element.prototype.shout = function () {
  this.elt.innerHTML += '<span>!</span>';
};
```


ChatGPT に無理やり翻訳させたけど、ちょっと返答内容が気持ち悪い（step3 までしか出さないとか）ので

のんびりと、翻訳かけながら確認をするか。。。


### 実装整理

```js
function soundReStart() {
  // wip: クリップノイズ対策
  p.disposeSound();

  const soundArray = p.soundOut.soundArray;
  for (let soundIdx = soundArray.length - 1; soundIdx >= 0; soundIdx--) {
    const sound = soundArray[soundIdx];
    // todo: 過剰処理?
    sound?.stop && sound.stop();
    sound?.dispose && sound.dispose();
    sound?.disconnect && sound.disconnect();

    soundArray.splice(soundIdx, 1);
  }

  const parts = p.soundOut.parts;
  for (let partIdx = parts.length - 1; partIdx >= 0; partIdx--) {
    const phrases = parts[partIdx].phrases;
    for (let phraseIdx = phrases.length - 1; phraseIdx >= 0; phraseIdx--) {
      phrases.splice(phraseIdx, 1);
    }
    parts.splice(partIdx, 1);
  }

  p.soundOut.soundArray = [];
  p.soundOut.parts = [];
  p.soundOut.extensions = []; // todo: 対応必要?

  p.userStartAudio();
}
```

この処理を、`preload` の一番最初か、呼び出し直前に実行する。
addon とするので、`index.html` で読み込みをする。
sketch のコードには、記載しない（読み込みで勝手に実行する）。

#### 懸念

- 実行タイミングに寄って、読み込みが前後して壊れないように
- instance mode でもglobal mode でも実行できる
- `p5.sound` が呼ばれてないなら、そもそも実行しない


### 今後

他にも、個人的にaddon として設定しているのもあるので、マナーを揃えて書いていきたい





# 📝 2025/08/24

## codemirror のesm.sh

さて、どれを呼んでいくか、、、

- [CodeMirror6の概要と基本的な使い方](https://toach.biz/blog/codemirror6-basics/#2-2)
- [ESM-compatible CodeMirror build (directly importable in browser) - v6 - discuss.CodeMirror](https://discuss.codemirror.net/t/esm-compatible-codemirror-build-directly-importable-in-browser/5933)

キャレット出ないやつ
- [text selection grabbers no longer show on iOS (18.3.1) since 6.35.1 · Issue #1538 · codemirror/dev](https://github.com/codemirror/dev/issues/1538)

## `web-console-log` テスト

[GitHub - tkihira/web-console-log](https://github.com/tkihira/web-console-log)

ローカルにつっこんだら、素直に出てきた？

`eruda` と共存できないだけか？

```html
  <script type="module">
    import eruda from 'https://esm.sh/eruda';

    eruda.init();
  </script>
```

# 📝 2025/08/21

## todo ?

- スクリプトを選択できるように？
- `v0.1` の音データの外部読み込み
- ems.sh でcodemirror 組んでみる
    - キャレットがで出てくるまで戻す
    - それで相互互換性が保てるか
- [GitHub - tkihira/web-console-log](https://github.com/tkihira/web-console-log) 検証

# 📝 2025/08/20

- [GitHub - processing/p5.sound](https://github.com/processing/p5.sound.js)
- [GitHub - Tonejs/Tone.js: A Web Audio framework for making interactive music in the browser.](https://github.com/Tonejs/Tone.js)

`v0.2` は、まだ先かなぁ、、、

音止めたりするのが、全く違うかも。

# 📝 2025/08/16

gas の非同期実行のやつ、まとめておきたい。しかし、実際に走るコード見ながらでないと、難しいな。。。

## 参照あさり

- [Make google.script.run looks a promise · GitHub](https://gist.github.com/torufurukawa/64339baf16efd3598e71dd763d1db0cf)
    - これでいいんだっけ？
- [Asynchronous execution for Google App Scripts (gas) · GitHub](https://gist.github.com/sdesalas/2972f8647897d5481fd8e01f03122805)
    - こっちの方が多く引っかかる？
- [【GASの起動時間の制限を回避せよ】分割実行や非同期処理を使って高速実行を実現してみた！ - ポンコツエンジニアのごじゃっぺ開発日記。](https://www.pnkts.net/2019/12/25/gas-split-execution-and-_asynchronous-processing)
- [GASの関数をPromiseでラップする (魔法のオブジェクトProxy) #JavaScript - Qiita](https://qiita.com/Shankou/items/7b73686c3aa9364c20ce)
    - `Proxy` ?
    - [Proxy - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Proxy)


## もってきたやつ

### menu 系

```js
const activeSpreadsheet = SpreadsheetApp.getActiveSpreadsheet();

function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('📂 ScriptMenus')
    .addItem('一括処理', 'customUpdate')
    .addToUi();
}

/**
* カスタムメニューがクリックされた時に走る処理
*/
function customUpdate() {
  // xxx: ボタン誘導のコンテクスト
  // const selector = Browser.msgBox("じっこうするー", "実行することの意味を理解していますか？", Browser.Buttons.OK_CANCEL);
  // if (selector === 'cancel') {
  // return
  // }
const html = HtmlService.createTemplateFromFile('customUpdate.html').evaluate();
SpreadsheetApp.getUi().showModalDialog(html, '処理を止めたい場合は[x] 押す →');
}

function getDeploySheetDataList() {
  const dataSheet = activeSpreadsheet.getSheetByName('社員リスト');
  const lastRow = dataSheet.getLastRow();
  const deployData = dataSheet.getRange(`A2:C${lastRow}`).getValues();
  return deployData
}

/**
* 実行ログの吐き出し
*/
function setStatusLogs(times, logs) {
  const ws = activeSpreadsheet.insertSheet(`log:${times[0]}`);
  console.log('------------- set')
  SpreadsheetApp.flush();
  ws.getRange('A1:A2').setValues([[times[0]], [times[1]]]);
  const length = logs.length;
  ws.getRange(`B1:E${length}`).setValues(logs);
}
```

### 実行のコア

```html
<!DOCTYPE html>
<html>

<head>
  <base target="_top" />
  <script>
// --- 非同期処理準備
/* gasの関数で、Promise が返せるように */
// https://gist.github.com/torufurukawa/64339baf16efd3598e71dd763d1db0cf
function scriptRunPromise() {
  const gs = {};
  const keys = Object.keys(google.script.run);
  for (let i = 0; i < keys.length; i++) {
    gs[keys[i]] = (function (key) {
      return function (...args) {
        return new Promise(function (resolve, reject) {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            [key].apply(google.script.run, args);
        });
      };
    })(keys[i]);
  }
  return gs;
}

/**
 * 与えられたイテラブルから得られる関数を順に、
 * 指定された数まで並列に実行する。
 *
 * @param iterable {Iterable<() => Promise<void>}
 *  実行したい関数を要素に持つイテラブル。
 *  各関数は引数を持たず、Promise を返す。
 * @param concurrency {number} この数まで並列に実行する。
 * @return {Promise<void>}
 *  全ての関数を実行し終えると resolve される Promise。
 */
async function runConcurrentlyAsync(iterable, concurrency) {
  const iterator = iterable[Symbol.iterator]();
  let index = 0; // ログ用
  const promises = Array.from({ length: concurrency }, (_, id) => {
    return new Promise(async (resolve) => {
      for (
        let result = iterator.next();
        !result.done;
        result = iterator.next()
      ) {
        const i = index++;
        console.log(`${id}: ${i}...`);
        await result.value();
        console.log(`        ...${id}: ${i}`);
        prgrsbr.value = i; // プログレスバー用
      }
      resolve();
    });
  });
  await Promise.all(promises);
}
// --- 非同期処理準備終わり/

let prgrsbr, logDiv; // プログレスバー用
let startTimeLog, finishTimeLog;
let statusLogs = [];

window.addEventListener('load', () => {
  console.log('load: start');
  // sv-SEロケールはYYYY-MM-DD形式の日付文字列を戻す
  const _ymd = new Date().toLocaleDateString('sv-SE');
  const _time = new Date().toLocaleTimeString('ja-JP', { hour12: false });
  startTimeLog = `${_ymd}_${_time}`;

  setUpUI();
  // todo: 初回に一括でデータを取ってくるところ
  scriptRunPromise()
    .getDeploySheetDataList()
    .then((resolve) => asyncTouchSheets(resolve));
});
// エリアグループ名と、URL の配列が入っている
function asyncTouchSheets(arrayNameURLs) {
  const INIT = 0;
  const MAX = arrayNameURLs.length;
  const CONCURRENCY = 2; // 同時実行できる数を定義
  prgrsbr.max = MAX; // プログレスバー用

  const generator = (function* createGenerator() {
    for (let i = INIT; i < MAX; i++) {
      const [staffNum, staffName, mailAddress] = arrayNameURLs[i];
      const idx = i + 1;

      let stateSignal;

      // todo: 最終的に実行させる関数
      yield async () => {
        try {
          await scriptRunPromise().allCallFunc(
            staffNum,
            staffName,
            mailAddress
          );
          stateSignal = ['🟢', ''];
        } catch (error) {
          stateSignal = ['🔴', `${error}`];
        } finally {
          addLogText(
            `${stateSignal[0]}\t${idx}:\t${staffNum} \t${stateSignal[1]}`
          );
          statusLogs = [
            ...statusLogs,
            [stateSignal[0], idx, staffNum, stateSignal[1]],
          ];
        }
      };
    }
  })();

  runConcurrentlyAsync(generator, CONCURRENCY).then((resolve) => {
    const _ymd = new Date().toLocaleDateString('sv-SE');
    const _time = new Date().toLocaleTimeString('ja-JP', { hour12: false });
    finishTimeLog = `${_ymd}_${_time}`;

    google.script.run.setStatusLogs([startTimeLog, finishTimeLog], statusLogs);
    google.script.host.close();
  });
}

// 進捗プログレスバー作成用
function addLogText(logWord) {
  const logText = document.createElement('p');
  logText.style.margin = 0;
  logText.style.padding = 0;
  logText.textContent = `${logWord}`;
  // logDiv.appendChild(logText);
  logDiv.prepend(logText);
}

function setUpUI() {
  const wrap = document.createElement('main');
  prgrsbr = document.createElement('progress');
  prgrsbr.style.width = '100%';
  prgrsbr.min = 0;
  prgrsbr.value = 0;
  prgrsbr.style.position = 'sticky';
  prgrsbr.style.top = 0;
  const memo = document.createTextNode('😤 処理が終わったら自動で消えます');
  logDiv = document.createElement('div');
  logDiv.style.fontSize = '0.8rem';
  document.body.appendChild(wrap);
  wrap.appendChild(prgrsbr);
  wrap.appendChild(memo);
  wrap.appendChild(logDiv);
}

  </script>
</head>

<body></body>

</html>

```

### 逐次処理

```js
function allCallFunc(num, name, mail) {
  console.log(num);
  const s = SpreadsheetApp.openByUrl(mail);
  s.getSheetByName('a').getRange('A1').getValue()
}

```



## うーん

aside とかclap とか入れてやってみる？


# 📝 2025/08/12


## p5.sound の`reset`

> 
`p5.soundOut` is the p5.sound final output bus. It sends output to the destination of this window's web audio context. It contains Web Audio API nodes including a dyanmicsCompressor (<code>.limiter</code>), and Gain Nodes for <code>.input</code> and <code>.output</code>.
> `p5.soundOut` は p5.sound の最終出力バスです。このウィンドウの Web Audio コンテキストの宛先に出力を送信します。このバスには、Web Audio API ノード（dynamicsCompressor (<code>.limiter</code>) を含む）と、<code>.input</code> および <code>.output</code> 用の Gain ノードが含まれています。




# 📝 2025/08/11

[GitHub - tkihira/web-console-log](https://github.com/tkihira/web-console-log)



# 📝 2025/08/09

## `p5.Envelope`

[p5.Envelope](https://p5js.org/reference/p5.sound/p5.Envelope/)

play とかtrigger とか

ADSR の指定と、`constructor` のデフォルトとか





# 📝 2025/08/02


## p5 sound

- [getOctaveBands](https://p5js.org/reference/p5.FFT/getOctaveBands/)
- [logAverages](https://p5js.org/reference/p5.FFT/logAverages/)

ここら辺、良い感じにつかえるのかしら？

## module 化？

そもそも、`import` 読み込み設定せんとあかんか

spectrum analyzer とか、大きくなってしまったので、分けて使うか？



# 📝 2025/07/31

ai にコード聞くようになってから、ここで書かなくなってるや

スペクトラムアナライザーとしてlog スケールとかもごもごやってる





# 📝 2025/07/16

## [GitHub - pome-ta/p5js4codemirror6](https://github.com/pome-ta/p5js4codemirror6) todo


- module 化
    - 依存減らす
        - 具体的な変数で参照させない？
        - `querySelector` も極力使わないとか
    - 自由度高く
- プレビューの画面
    - 全画面
        - header を出したり、隠したり
        - canvas の指定サイズには忠実でありたい
- autocomplete
    - p5 用に
    - lsp でなくてもいい
- エディタ設定
    - テーマ関係が雑
- `.css`
    - module ごとの考え方とか
    - 全体のは、ほぼ使わないとか？
- スケッチファイル
    - 切り替えできると良き？
    - ストレージとか？
- console 出せるようにする？
- 音のノイズ
  - 終了時、更新時のノイズ
  - クリップノイズをなるべく排除したい
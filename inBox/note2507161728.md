もう面倒だから、全部書き落としていくか


# 📝2025/09/26


## codemirror とlsp


- [Building a better online editor for TypeScript | Val Town Blog](https://blog.val.town/vtlsp?utm_source=chatgpt.com)
- [Bringing the TypeScript Language Server to Observable | Observable](https://observablehq.com/blog/bringing-the-typescript-language-server-to-observable?utm_source=chatgpt.com)
- 

# 📝 2025/09/16

## [p5SketchBook/dumpDirectlyTree.py at main · pome-ta/p5SketchBook · GitHub](https://github.com/pome-ta/p5SketchBook/blob/main/dumpDirectlyTree.py)

[`dialog` 要素に「ダイアログの外側クリックで閉じる」処理の追加](https://zenn.dev/de_teiu_tkg/articles/96a46374655e56)




# 📝 2025/09/13

## rubion-objc

[GitHub - pome-ta/pystaUIKitCatalogChallenge: Implemented Apple's official sample UIKitCatalog with Pythonista3 and rubicon-objc.](https://github.com/pome-ta/pystaUIKitCatalogChallenge)

`0.5.2` にupdate してみた

多分だけど、変更なく実行できてると思う


### mac でのPythonista3(rubicon) 実行

iPad でも問題なさそうなのに、mac だとクラッシュしてくれる。
クラッシュレポートちゃんと読んでないけど、何かしら実行環境が違うみたい。

Pythonista3 でもa-shell でも同様

`UIColor` をインスタンスとして呼び出す時に、`ObjCInstance` が呼べないとかなる



# 📝 2025/09/11

p5 の色々な環境

- [GitHub - pome-ta/p5js4codemirror6](https://github.com/pome-ta/p5js4codemirror6)
    - もりもりとコードを書いていくところ
    - エディタ機能もつけて編集ができる
    - 新しく何かを書くところ
- [GitHub - pome-ta/p5SketchBook](https://github.com/pome-ta/p5SketchBook)
    - Fix したコード置き場
    - ファイル一覧を`.json` で管理
    - `_` が先頭にあるファイル名が（多分読めない？）
        - ローカル実行だと大丈夫そう？
        - GitHub pages だとだめかも？
            - 要。原因検討

似通ったリポジトリになってしまった。が、入力保存機能のキャッチが、面倒。同一機能として統合はしないかも


## `importmap` がおもろい

[`<script type="importmap">` - HTML | MDN](https://developer.mozilla.org/ja/docs/Web/HTML/Reference/Elements/script/type/importmap)

`../.../` と設置場所依存な呼び出し方をしてたが、スッキリ読み込みの書き方ができそう






# 📝 2025/09/03

## [p5SketchBook/dumpDirectlyTree.py at main · pome-ta/p5SketchBook · GitHub](https://github.com/pome-ta/p5SketchBook/blob/main/dumpDirectlyTree.py)


`.json` のdump をつくる

- 作成日
- 更新日
- type
- 拡張子？

# 📝 2025/09/02

#api #github 

## GitHub REST API (Contents API)

多分今回は使わないけど

```js
const owner = 'pome-ta';
const repo = 'p5SketchBook'

const endPoint = 'https://api.github.com/repos';
const kind = 'contents'



async function getRepoContents() {
  const res = await fetch([endPoint, owner, repo, kind].join('/'));
  const data = await res.json();
  console.log(data);
}

getRepoContents();
```

オブジェクトで、4つ（リポジトリ直下のもの）を持って来てる


```js
(info): [
  {
    "name": "LICENSE",
    "path": "LICENSE",
    "sha": "a72ad48a1d26d5d69d4fa705a91eb3f32e888189",
    "size": 1064,
    "url": "https://api.github.com/repos/pome-ta/p5SketchBook/contents/LICENSE?ref=main",
    "html_url": "https://github.com/pome-ta/p5SketchBook/blob/main/LICENSE",
    "git_url": "https://api.github.com/repos/pome-ta/p5SketchBook/git/blobs/a72ad48a1d26d5d69d4fa705a91eb3f32e888189",
    "download_url": "https://raw.githubusercontent.com/pome-ta/p5SketchBook/main/LICENSE",
    "type": "file",
    "_links": {
      "self": "https://api.github.com/repos/pome-ta/p5SketchBook/contents/LICENSE?ref=main",
      "git": "https://api.github.com/repos/pome-ta/p5SketchBook/git/blobs/a72ad48a1d26d5d69d4fa705a91eb3f32e888189",
      "html": "https://github.com/pome-ta/p5SketchBook/blob/main/LICENSE"
    }
  },
  {
    "name": "README.md",
    "path": "README.md",
    "sha": "b39dfa34417ea243c03142560593600b490afb61",
    "size": 14,
    "url": "https://api.github.com/repos/pome-ta/p5SketchBook/contents/README.md?ref=main",
    "html_url": "https://github.com/pome-ta/p5SketchBook/blob/main/README.md",
    "git_url": "https://api.github.com/repos/pome-ta/p5SketchBook/git/blobs/b39dfa34417ea243c03142560593600b490afb61",
    "download_url": "https://raw.githubusercontent.com/pome-ta/p5SketchBook/main/README.md",
    "type": "file",
    "_links": {
      "self": "https://api.github.com/repos/pome-ta/p5SketchBook/contents/README.md?ref=main",
      "git": "https://api.github.com/repos/pome-ta/p5SketchBook/git/blobs/b39dfa34417ea243c03142560593600b490afb61",
      "html": "https://github.com/pome-ta/p5SketchBook/blob/main/README.md"
    }
  },
  {
    "name": "modules",
    "path": "modules",
    "sha": "52cb3d3bbf2538ae4dd5d00a93d2676541522631",
    "size": 0,
    "url": "https://api.github.com/repos/pome-ta/p5SketchBook/contents/modules?ref=main",
    "html_url": "https://github.com/pome-ta/p5SketchBook/tree/main/modules",
    "git_url": "https://api.github.com/repos/pome-ta/p5SketchBook/git/trees/52cb3d3bbf2538ae4dd5d00a93d2676541522631",
    "download_url": null,
    "type": "dir",
    "_links": {
      "self": "https://api.github.com/repos/pome-ta/p5SketchBook/contents/modules?ref=main",
      "git": "https://api.github.com/repos/pome-ta/p5SketchBook/git/trees/52cb3d3bbf2538ae4dd5d00a93d2676541522631",
      "html": "https://github.com/pome-ta/p5SketchBook/tree/main/modules"
    }
  },
  {
    "name": "sounds",
    "path": "sounds",
    "sha": "02e73a230f836ee824920dab794fbb5972747707",
    "size": 0,
    "url": "https://api.github.com/repos/pome-ta/p5SketchBook/contents/sounds?ref=main",
    "html_url": "https://github.com/pome-ta/p5SketchBook/tree/main/sounds",
    "git_url": "https://api.github.com/repos/pome-ta/p5SketchBook/git/trees/02e73a230f836ee824920dab794fbb5972747707",
    "download_url": null,
    "type": "dir",
    "_links": {
      "self": "https://api.github.com/repos/pome-ta/p5SketchBook/contents/sounds?ref=main",
      "git": "https://api.github.com/repos/pome-ta/p5SketchBook/git/trees/02e73a230f836ee824920dab794fbb5972747707",
      "html": "https://github.com/pome-ta/p5SketchBook/tree/main/sounds"
    }
  }
]

```

# 📝 2025/09/01

過去自分が書いたmodule みたいなのの整理

```js
export default class DomFactory {
  #element;
  #buildEvent;

  constructor(domTag) {
    this.#element = typeof domTag === 'string' ? document.createElement(domTag) : domTag;

    this.#buildEvent = new CustomEvent('build', {detail: this.#element});
  }

  get element() {
    return this.#element;
  }

  get buildEvent() {
    return this.#buildEvent;
  }

  static create(tag, options) {
    const instance = new this(tag);
    options ? Object.entries(options).forEach(([key, value]) => instance[key](value)) : null;
    instance.element.dispatchEvent(instance.buildEvent);

    return instance.element;
  }

  setAttr(name, val) {
    this.#element.setAttribute(name, val);

    return this;
  }

  setAttrs(attrs) {
    Object.entries(attrs).forEach(([key, value]) => this.setAttr(key, value));

    return this;
  }

  setStyle(prop, val) {
    this.#element.style.setProperty(prop, val);

    return this;
  }

  setStyles(styles) {
    Object.entries(styles).forEach(([key, value]) => this.setStyle(key, value));

    return this;
  }

  addClassList(nameList) {
    this.#element.classList.add(...nameList);

    return this;
  }

  textContent(value) {
    this.#element.textContent = value;

    return this;
  }

  addEventListener({type, listener, options}) {
    this.#element.addEventListener(type, listener, options);

    return this;
  }

  addEventListeners(args) {
    [...args].forEach((arg) => this.addEventListener(arg));

    return this;
  }

  targetAddEventListener({target, type, listener, options}) {
    target.addEventListener(type, listener, options);

    return this;
  }

  targetAddEventListeners(args) {
    [...args].forEach((arg) => this.targetAddEventListener(arg));

    return this;
  }

  appendChildren(children) {
    [...children].forEach((child) => this.#element.appendChild(child));

    return this;
  }

  appendParent(parent) {
    parent.appendChild(this.#element);

    return this;
  }
}

```


```js
/**
 * メソッドチェーン（fluent interface）を用いてDOM要素の生成と操作を効率化するファクトリークラス。
 * @example
 * const button = DomFactory.create('button', { textContent: 'Click Me' });
 * document.body.appendChild(button);
 */
export default class DomFactory {
  /**
   * 内部で管理しているDOM要素。
   * @private
   * @type {HTMLElement}
   */
  #element;

  /**
   * 要素が生成されたことを示すカスタムイベント。
   * @private
   * @type {CustomEvent}
   */
  #buildEvent;

  /**
   * @param {string | HTMLElement} domTag - 作成する要素のタグ名（'div'など）、または既存のDOM要素。
   */
  constructor(domTag) {
    this.#element = typeof domTag === 'string' ? document.createElement(domTag) : domTag;
    this.#buildEvent = new CustomEvent('build', { detail: this.#element });
  }

  /**
   * 現在のDOM要素を返します。
   * @returns {HTMLElement}
   */
  get element() {
    return this.#element;
  }

  /**
   * 'build'カスタムイベントを返します。
   * @returns {CustomEvent}
   */
  get buildEvent() {
    return this.#buildEvent;
  }

  /**
   * 新しいDOM要素を生成し、オプションを適用します。
   * @param {string} tag - 生成する要素のHTMLタグ名。
   * @param {object} [options] - 要素に適用するメソッドと値のキーペア。例: { textContent: 'Hello' }
   * @returns {HTMLElement} - 生成・設定済みのDOM要素。
   */
  static create(tag, options) {
    const instance = new this(tag);
    options ? Object.entries(options).forEach(([key, value]) => instance[key](value)) : null;
    instance.element.dispatchEvent(instance.buildEvent);

    return instance.element;
  }

  /**
   * 要素に属性を1つ設定します。
   * @param {string} name - 属性名。
   * @param {string} val - 属性値。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  setAttr(name, val) {
    this.#element.setAttribute(name, val);
    return this;
  }

  /**
   * 要素に複数の属性を一度に設定します。
   * @param {Record<string, string>} attrs - 属性のキーと値のペアを持つオブジェクト。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  setAttrs(attrs) {
    Object.entries(attrs).forEach(([key, value]) => this.setAttr(key, value));
    return this;
  }

  /**
   * 要素にCSSスタイルを1つ設定します。
   * @param {string} prop - CSSプロパティ名。
   * @param {string} val - CSSプロパティの値。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  setStyle(prop, val) {
    this.#element.style.setProperty(prop, val);
    return this;
  }

  /**
   * 要素に複数のCSSスタイルを一度に設定します。
   * @param {Record<string, string>} styles - CSSプロパティのキーと値のペアを持つオブジェクト。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  setStyles(styles) {
    Object.entries(styles).forEach(([key, value]) => this.setStyle(key, value));
    return this;
  }

  /**
   * 要素のクラスリストに複数のクラスを追加します。
   * @param {string[]} nameList - 追加するクラス名の配列。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  addClassList(nameList) {
    this.#element.classList.add(...nameList);
    return this;
  }

  /**
   * 要素のテキストコンテンツを設定します。
   * @param {string} value - 設定するテキスト。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  textContent(value) {
    this.#element.textContent = value;
    return this;
  }

  /**
   * 要素にイベントリスナーを1つ追加します。
   * @param {object} eventArgs - イベントリスナーの引数オブジェクト。
   * @param {string} eventArgs.type - イベントタイプ。
   * @param {EventListenerOrEventListenerObject} eventArgs.listener - イベントリスナー関数。
   * @param {boolean | AddEventListenerOptions} [eventArgs.options] - イベントリスナーのオプション。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  addEventListener({ type, listener, options }) {
    this.#element.addEventListener(type, listener, options);
    return this;
  }

  /**
   * 要素に複数のイベントリスナーを一度に追加します。
   * @param {Array<object>} args - `addEventListener`に渡す引数オブジェクトの配列。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  addEventListeners(args) {
    [...args].forEach((arg) => this.addEventListener(arg));
    return this;
  }

  /**
   * 任意のターゲットにイベントリスナーを1つ追加します。
   * @param {object} eventArgs - イベントリスナーの引数オブジェクト。
   * @param {EventTarget} eventArgs.target - イベントリスナーを追加するターゲット。
   * @param {string} eventArgs.type - イベントタイプ。
   * @param {EventListenerOrEventListenerObject} eventArgs.listener - イベントリスナー関数。
   * @param {boolean | AddEventListenerOptions} [eventArgs.options] - イベントリスナーのオプション。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  targetAddEventListener({ target, type, listener, options }) {
    target.addEventListener(type, listener, options);
    return this;
  }

  /**
   * 任意のターゲットに複数のイベントリスナーを一度に追加します。
   * @param {Array<object>} args - `targetAddEventListener`に渡す引数オブジェクトの配列。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  targetAddEventListeners(args) {
    [...args].forEach((arg) => this.targetAddEventListener(arg));
    return this;
  }

  /**
   * 要素に複数の子要素を追加します。
   * @param {HTMLElement[]} children - 追加する子要素の配列。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  appendChildren(children) {
    [...children].forEach((child) => this.#element.appendChild(child));
    return this;
  }

  /**
   * 指定された親要素に自身を追加します。
   * @param {HTMLElement} parent - 親となるDOM要素。
   * @returns {this} メソッドチェーンのための自身のインスタンス。
   */
  appendParent(parent) {
    parent.appendChild(this.#element);
    return this;
  }
}

```

# 📝 2025/08/31

p5 のsketch を選択して変更させたい

ローカルではなく、リポジトリ上のを読み込む

# 📝 2025/08/25

codemirror は、依存関係が面倒だからやーめた


p5.sound(v1) の方で、`loadSound` が外部から呼べるようだったので、v1 で色々なexample を実行することにする。

私の実装だと、sound 関係を一旦リセット（コード読み直し時）したい。が、`preload` 時に読み込みをしてしまうと
`setup` でリセットされてしまう。


であれば、addon として、sketch code に書かずとも、勝手に実行してもらうことにしたい

## p5.js のaddon


[Creating an Addon Library](https://p5js.org/contribute/creating_libraries/)


`beta` もあるので、気をつけたし

[Creating an Addon Library](https://beta.p5js.org/contribute/creating_libraries/)

[GitHub - processing/p5.js-addon-template](https://github.com/processing/p5.js-addon-template)

このtmp のリポジトリは、v2 の方っぽい。

beta の

```js
function loadCSVAddon(p5, fn, lifecycles){

}

```

と、なっているため。

v1 は、`.prototype` をゴリゴリ使う：

```js
p5.Element.prototype.shout = function () {
  this.elt.innerHTML += '<span>!</span>';
};
```


ChatGPT に無理やり翻訳させたけど、ちょっと返答内容が気持ち悪い（step3 までしか出さないとか）ので

のんびりと、翻訳かけながら確認をするか。。。


### 実装整理

```js
function soundReStart() {
  // wip: クリップノイズ対策
  p.disposeSound();

  const soundArray = p.soundOut.soundArray;
  for (let soundIdx = soundArray.length - 1; soundIdx >= 0; soundIdx--) {
    const sound = soundArray[soundIdx];
    // todo: 過剰処理?
    sound?.stop && sound.stop();
    sound?.dispose && sound.dispose();
    sound?.disconnect && sound.disconnect();

    soundArray.splice(soundIdx, 1);
  }

  const parts = p.soundOut.parts;
  for (let partIdx = parts.length - 1; partIdx >= 0; partIdx--) {
    const phrases = parts[partIdx].phrases;
    for (let phraseIdx = phrases.length - 1; phraseIdx >= 0; phraseIdx--) {
      phrases.splice(phraseIdx, 1);
    }
    parts.splice(partIdx, 1);
  }

  p.soundOut.soundArray = [];
  p.soundOut.parts = [];
  p.soundOut.extensions = []; // todo: 対応必要?

  p.userStartAudio();
}
```

この処理を、`preload` の一番最初か、呼び出し直前に実行する。
addon とするので、`index.html` で読み込みをする。
sketch のコードには、記載しない（読み込みで勝手に実行する）。

#### 懸念

- 実行タイミングに寄って、読み込みが前後して壊れないように
- instance mode でもglobal mode でも実行できる
- `p5.sound` が呼ばれてないなら、そもそも実行しない


### 今後

他にも、個人的にaddon として設定しているのもあるので、マナーを揃えて書いていきたい





# 📝 2025/08/24

## codemirror のesm.sh

さて、どれを呼んでいくか、、、

- [CodeMirror6の概要と基本的な使い方](https://toach.biz/blog/codemirror6-basics/#2-2)
- [ESM-compatible CodeMirror build (directly importable in browser) - v6 - discuss.CodeMirror](https://discuss.codemirror.net/t/esm-compatible-codemirror-build-directly-importable-in-browser/5933)

キャレット出ないやつ
- [text selection grabbers no longer show on iOS (18.3.1) since 6.35.1 · Issue #1538 · codemirror/dev](https://github.com/codemirror/dev/issues/1538)

## `web-console-log` テスト

[GitHub - tkihira/web-console-log](https://github.com/tkihira/web-console-log)

ローカルにつっこんだら、素直に出てきた？

`eruda` と共存できないだけか？

```html
  <script type="module">
    import eruda from 'https://esm.sh/eruda';

    eruda.init();
  </script>
```

# 📝 2025/08/21

## todo ?

- スクリプトを選択できるように？
- `v0.1` の音データの外部読み込み
- ems.sh でcodemirror 組んでみる
    - キャレットがで出てくるまで戻す
    - それで相互互換性が保てるか
- [GitHub - tkihira/web-console-log](https://github.com/tkihira/web-console-log) 検証

# 📝 2025/08/20

- [GitHub - processing/p5.sound](https://github.com/processing/p5.sound.js)
- [GitHub - Tonejs/Tone.js: A Web Audio framework for making interactive music in the browser.](https://github.com/Tonejs/Tone.js)

`v0.2` は、まだ先かなぁ、、、

音止めたりするのが、全く違うかも。

# 📝 2025/08/16

gas の非同期実行のやつ、まとめておきたい。しかし、実際に走るコード見ながらでないと、難しいな。。。

## 参照あさり

- [Make google.script.run looks a promise · GitHub](https://gist.github.com/torufurukawa/64339baf16efd3598e71dd763d1db0cf)
    - これでいいんだっけ？
- [Asynchronous execution for Google App Scripts (gas) · GitHub](https://gist.github.com/sdesalas/2972f8647897d5481fd8e01f03122805)
    - こっちの方が多く引っかかる？
- [【GASの起動時間の制限を回避せよ】分割実行や非同期処理を使って高速実行を実現してみた！ - ポンコツエンジニアのごじゃっぺ開発日記。](https://www.pnkts.net/2019/12/25/gas-split-execution-and-_asynchronous-processing)
- [GASの関数をPromiseでラップする (魔法のオブジェクトProxy) #JavaScript - Qiita](https://qiita.com/Shankou/items/7b73686c3aa9364c20ce)
    - `Proxy` ?
    - [Proxy - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Proxy)


## もってきたやつ

### menu 系

```js
const activeSpreadsheet = SpreadsheetApp.getActiveSpreadsheet();

function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('📂 ScriptMenus')
    .addItem('一括処理', 'customUpdate')
    .addToUi();
}

/**
* カスタムメニューがクリックされた時に走る処理
*/
function customUpdate() {
  // xxx: ボタン誘導のコンテクスト
  // const selector = Browser.msgBox("じっこうするー", "実行することの意味を理解していますか？", Browser.Buttons.OK_CANCEL);
  // if (selector === 'cancel') {
  // return
  // }
const html = HtmlService.createTemplateFromFile('customUpdate.html').evaluate();
SpreadsheetApp.getUi().showModalDialog(html, '処理を止めたい場合は[x] 押す →');
}

function getDeploySheetDataList() {
  const dataSheet = activeSpreadsheet.getSheetByName('社員リスト');
  const lastRow = dataSheet.getLastRow();
  const deployData = dataSheet.getRange(`A2:C${lastRow}`).getValues();
  return deployData
}

/**
* 実行ログの吐き出し
*/
function setStatusLogs(times, logs) {
  const ws = activeSpreadsheet.insertSheet(`log:${times[0]}`);
  console.log('------------- set')
  SpreadsheetApp.flush();
  ws.getRange('A1:A2').setValues([[times[0]], [times[1]]]);
  const length = logs.length;
  ws.getRange(`B1:E${length}`).setValues(logs);
}
```

### 実行のコア

```html
<!DOCTYPE html>
<html>

<head>
  <base target="_top" />
  <script>
// --- 非同期処理準備
/* gasの関数で、Promise が返せるように */
// https://gist.github.com/torufurukawa/64339baf16efd3598e71dd763d1db0cf
function scriptRunPromise() {
  const gs = {};
  const keys = Object.keys(google.script.run);
  for (let i = 0; i < keys.length; i++) {
    gs[keys[i]] = (function (key) {
      return function (...args) {
        return new Promise(function (resolve, reject) {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            [key].apply(google.script.run, args);
        });
      };
    })(keys[i]);
  }
  return gs;
}

/**
 * 与えられたイテラブルから得られる関数を順に、
 * 指定された数まで並列に実行する。
 *
 * @param iterable {Iterable<() => Promise<void>}
 *  実行したい関数を要素に持つイテラブル。
 *  各関数は引数を持たず、Promise を返す。
 * @param concurrency {number} この数まで並列に実行する。
 * @return {Promise<void>}
 *  全ての関数を実行し終えると resolve される Promise。
 */
async function runConcurrentlyAsync(iterable, concurrency) {
  const iterator = iterable[Symbol.iterator]();
  let index = 0; // ログ用
  const promises = Array.from({ length: concurrency }, (_, id) => {
    return new Promise(async (resolve) => {
      for (
        let result = iterator.next();
        !result.done;
        result = iterator.next()
      ) {
        const i = index++;
        console.log(`${id}: ${i}...`);
        await result.value();
        console.log(`        ...${id}: ${i}`);
        prgrsbr.value = i; // プログレスバー用
      }
      resolve();
    });
  });
  await Promise.all(promises);
}
// --- 非同期処理準備終わり/

let prgrsbr, logDiv; // プログレスバー用
let startTimeLog, finishTimeLog;
let statusLogs = [];

window.addEventListener('load', () => {
  console.log('load: start');
  // sv-SEロケールはYYYY-MM-DD形式の日付文字列を戻す
  const _ymd = new Date().toLocaleDateString('sv-SE');
  const _time = new Date().toLocaleTimeString('ja-JP', { hour12: false });
  startTimeLog = `${_ymd}_${_time}`;

  setUpUI();
  // todo: 初回に一括でデータを取ってくるところ
  scriptRunPromise()
    .getDeploySheetDataList()
    .then((resolve) => asyncTouchSheets(resolve));
});
// エリアグループ名と、URL の配列が入っている
function asyncTouchSheets(arrayNameURLs) {
  const INIT = 0;
  const MAX = arrayNameURLs.length;
  const CONCURRENCY = 2; // 同時実行できる数を定義
  prgrsbr.max = MAX; // プログレスバー用

  const generator = (function* createGenerator() {
    for (let i = INIT; i < MAX; i++) {
      const [staffNum, staffName, mailAddress] = arrayNameURLs[i];
      const idx = i + 1;

      let stateSignal;

      // todo: 最終的に実行させる関数
      yield async () => {
        try {
          await scriptRunPromise().allCallFunc(
            staffNum,
            staffName,
            mailAddress
          );
          stateSignal = ['🟢', ''];
        } catch (error) {
          stateSignal = ['🔴', `${error}`];
        } finally {
          addLogText(
            `${stateSignal[0]}\t${idx}:\t${staffNum} \t${stateSignal[1]}`
          );
          statusLogs = [
            ...statusLogs,
            [stateSignal[0], idx, staffNum, stateSignal[1]],
          ];
        }
      };
    }
  })();

  runConcurrentlyAsync(generator, CONCURRENCY).then((resolve) => {
    const _ymd = new Date().toLocaleDateString('sv-SE');
    const _time = new Date().toLocaleTimeString('ja-JP', { hour12: false });
    finishTimeLog = `${_ymd}_${_time}`;

    google.script.run.setStatusLogs([startTimeLog, finishTimeLog], statusLogs);
    google.script.host.close();
  });
}

// 進捗プログレスバー作成用
function addLogText(logWord) {
  const logText = document.createElement('p');
  logText.style.margin = 0;
  logText.style.padding = 0;
  logText.textContent = `${logWord}`;
  // logDiv.appendChild(logText);
  logDiv.prepend(logText);
}

function setUpUI() {
  const wrap = document.createElement('main');
  prgrsbr = document.createElement('progress');
  prgrsbr.style.width = '100%';
  prgrsbr.min = 0;
  prgrsbr.value = 0;
  prgrsbr.style.position = 'sticky';
  prgrsbr.style.top = 0;
  const memo = document.createTextNode('😤 処理が終わったら自動で消えます');
  logDiv = document.createElement('div');
  logDiv.style.fontSize = '0.8rem';
  document.body.appendChild(wrap);
  wrap.appendChild(prgrsbr);
  wrap.appendChild(memo);
  wrap.appendChild(logDiv);
}

  </script>
</head>

<body></body>

</html>

```

### 逐次処理

```js
function allCallFunc(num, name, mail) {
  console.log(num);
  const s = SpreadsheetApp.openByUrl(mail);
  s.getSheetByName('a').getRange('A1').getValue()
}

```



## うーん

aside とかclap とか入れてやってみる？


# 📝 2025/08/12


## p5.sound の`reset`

> 
`p5.soundOut` is the p5.sound final output bus. It sends output to the destination of this window's web audio context. It contains Web Audio API nodes including a dyanmicsCompressor (<code>.limiter</code>), and Gain Nodes for <code>.input</code> and <code>.output</code>.
> `p5.soundOut` は p5.sound の最終出力バスです。このウィンドウの Web Audio コンテキストの宛先に出力を送信します。このバスには、Web Audio API ノード（dynamicsCompressor (<code>.limiter</code>) を含む）と、<code>.input</code> および <code>.output</code> 用の Gain ノードが含まれています。




# 📝 2025/08/11

[GitHub - tkihira/web-console-log](https://github.com/tkihira/web-console-log)



# 📝 2025/08/09

## `p5.Envelope`

[p5.Envelope](https://p5js.org/reference/p5.sound/p5.Envelope/)

play とかtrigger とか

ADSR の指定と、`constructor` のデフォルトとか





# 📝 2025/08/02


## p5 sound

- [getOctaveBands](https://p5js.org/reference/p5.FFT/getOctaveBands/)
- [logAverages](https://p5js.org/reference/p5.FFT/logAverages/)

ここら辺、良い感じにつかえるのかしら？

## module 化？

そもそも、`import` 読み込み設定せんとあかんか

spectrum analyzer とか、大きくなってしまったので、分けて使うか？



# 📝 2025/07/31

ai にコード聞くようになってから、ここで書かなくなってるや

スペクトラムアナライザーとしてlog スケールとかもごもごやってる





# 📝 2025/07/16

## [GitHub - pome-ta/p5js4codemirror6](https://github.com/pome-ta/p5js4codemirror6) todo


- module 化
    - 依存減らす
        - 具体的な変数で参照させない？
        - `querySelector` も極力使わないとか
    - 自由度高く
- プレビューの画面
    - 全画面
        - header を出したり、隠したり
        - canvas の指定サイズには忠実でありたい
- autocomplete
    - p5 用に
    - lsp でなくてもいい
- エディタ設定
    - テーマ関係が雑
- `.css`
    - module ごとの考え方とか
    - 全体のは、ほぼ使わないとか？
- スケッチファイル
    - 切り替えできると良き？
    - ストレージとか？
- console 出せるようにする？
- 音のノイズ
  - 終了時、更新時のノイズ
  - クリップノイズをなるべく排除したい